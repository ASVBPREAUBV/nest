<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>App</title>
</head>
<body>
Index says:
{{ message }} & {{id}}
<button>Click me</button>
</body>
<script>
    (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
        module.exports = after

        function after(count, callback, err_cb) {
            var bail = false
            err_cb = err_cb || noop
            proxy.count = count

            return (count === 0) ? callback() : proxy

            function proxy(err, result) {
                if (proxy.count <= 0) {
                    throw new Error('after called too many times')
                }
                --proxy.count

                // after first error, rest are passed to err_cb
                if (err) {
                    bail = true
                    callback(err)
                    // future error callbacks will go to error handler
                    callback = err_cb
                } else if (proxy.count === 0 && !bail) {
                    callback(null, result)
                }
            }
        }

        function noop() {}

    },{}],2:[function(require,module,exports){
        /**
         * An abstraction for slicing an arraybuffer even when
         * ArrayBuffer.prototype.slice is not supported
         *
         * @api public
         */

        module.exports = function(arraybuffer, start, end) {
            var bytes = arraybuffer.byteLength;
            start = start || 0;
            end = end || bytes;

            if (arraybuffer.slice) { return arraybuffer.slice(start, end); }

            if (start < 0) { start += bytes; }
            if (end < 0) { end += bytes; }
            if (end > bytes) { end = bytes; }

            if (start >= bytes || start >= end || bytes === 0) {
                return new ArrayBuffer(0);
            }

            var abv = new Uint8Array(arraybuffer);
            var result = new Uint8Array(end - start);
            for (var i = start, ii = 0; i < end; i++, ii++) {
                result[ii] = abv[i];
            }
            return result.buffer;
        };

    },{}],3:[function(require,module,exports){

        /**
         * Expose `Backoff`.
         */

        module.exports = Backoff;

        /**
         * Initialize backoff timer with `opts`.
         *
         * - `min` initial timeout in milliseconds [100]
         * - `max` max timeout [10000]
         * - `jitter` [0]
         * - `factor` [2]
         *
         * @param {Object} opts
         * @api public
         */

        function Backoff(opts) {
            opts = opts || {};
            this.ms = opts.min || 100;
            this.max = opts.max || 10000;
            this.factor = opts.factor || 2;
            this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
            this.attempts = 0;
        }

        /**
         * Return the backoff duration.
         *
         * @return {Number}
         * @api public
         */

        Backoff.prototype.duration = function(){
            var ms = this.ms * Math.pow(this.factor, this.attempts++);
            if (this.jitter) {
                var rand =  Math.random();
                var deviation = Math.floor(rand * this.jitter * ms);
                ms = (Math.floor(rand * 10) & 1) == 0  ? ms - deviation : ms + deviation;
            }
            return Math.min(ms, this.max) | 0;
        };

        /**
         * Reset the number of attempts.
         *
         * @api public
         */

        Backoff.prototype.reset = function(){
            this.attempts = 0;
        };

        /**
         * Set the minimum duration
         *
         * @api public
         */

        Backoff.prototype.setMin = function(min){
            this.ms = min;
        };

        /**
         * Set the maximum duration
         *
         * @api public
         */

        Backoff.prototype.setMax = function(max){
            this.max = max;
        };

        /**
         * Set the jitter
         *
         * @api public
         */

        Backoff.prototype.setJitter = function(jitter){
            this.jitter = jitter;
        };


    },{}],4:[function(require,module,exports){
        /*
 * base64-arraybuffer
 * https://github.com/niklasvh/base64-arraybuffer
 *
 * Copyright (c) 2012 Niklas von Hertzen
 * Licensed under the MIT license.
 */
        (function(){
            "use strict";

            var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

            // Use a lookup table to find the index.
            var lookup = new Uint8Array(256);
            for (var i = 0; i < chars.length; i++) {
                lookup[chars.charCodeAt(i)] = i;
            }

            exports.encode = function(arraybuffer) {
                var bytes = new Uint8Array(arraybuffer),
                        i, len = bytes.length, base64 = "";

                for (i = 0; i < len; i+=3) {
                    base64 += chars[bytes[i] >> 2];
                    base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];
                    base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];
                    base64 += chars[bytes[i + 2] & 63];
                }

                if ((len % 3) === 2) {
                    base64 = base64.substring(0, base64.length - 1) + "=";
                } else if (len % 3 === 1) {
                    base64 = base64.substring(0, base64.length - 2) + "==";
                }

                return base64;
            };

            exports.decode =  function(base64) {
                var bufferLength = base64.length * 0.75,
                        len = base64.length, i, p = 0,
                        encoded1, encoded2, encoded3, encoded4;

                if (base64[base64.length - 1] === "=") {
                    bufferLength--;
                    if (base64[base64.length - 2] === "=") {
                        bufferLength--;
                    }
                }

                var arraybuffer = new ArrayBuffer(bufferLength),
                        bytes = new Uint8Array(arraybuffer);

                for (i = 0; i < len; i+=4) {
                    encoded1 = lookup[base64.charCodeAt(i)];
                    encoded2 = lookup[base64.charCodeAt(i+1)];
                    encoded3 = lookup[base64.charCodeAt(i+2)];
                    encoded4 = lookup[base64.charCodeAt(i+3)];

                    bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);
                    bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
                    bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);
                }

                return arraybuffer;
            };
        })();

    },{}],5:[function(require,module,exports){
        'use strict'

        exports.byteLength = byteLength
        exports.toByteArray = toByteArray
        exports.fromByteArray = fromByteArray

        var lookup = []
        var revLookup = []
        var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

        var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
        for (var i = 0, len = code.length; i < len; ++i) {
            lookup[i] = code[i]
            revLookup[code.charCodeAt(i)] = i
        }

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
        revLookup['-'.charCodeAt(0)] = 62
        revLookup['_'.charCodeAt(0)] = 63

        function getLens (b64) {
            var len = b64.length

            if (len % 4 > 0) {
                throw new Error('Invalid string. Length must be a multiple of 4')
            }

            // Trim off extra bytes after placeholder bytes are found
            // See: https://github.com/beatgammit/base64-js/issues/42
            var validLen = b64.indexOf('=')
            if (validLen === -1) validLen = len

            var placeHoldersLen = validLen === len
                    ? 0
                    : 4 - (validLen % 4)

            return [validLen, placeHoldersLen]
        }

// base64 is 4/3 + up to two characters of the original data
        function byteLength (b64) {
            var lens = getLens(b64)
            var validLen = lens[0]
            var placeHoldersLen = lens[1]
            return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
        }

        function _byteLength (b64, validLen, placeHoldersLen) {
            return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
        }

        function toByteArray (b64) {
            var tmp
            var lens = getLens(b64)
            var validLen = lens[0]
            var placeHoldersLen = lens[1]

            var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

            var curByte = 0

            // if there are placeholders, only get up to the last complete 4 chars
            var len = placeHoldersLen > 0
                    ? validLen - 4
                    : validLen

            for (var i = 0; i < len; i += 4) {
                tmp =
                        (revLookup[b64.charCodeAt(i)] << 18) |
                        (revLookup[b64.charCodeAt(i + 1)] << 12) |
                        (revLookup[b64.charCodeAt(i + 2)] << 6) |
                        revLookup[b64.charCodeAt(i + 3)]
                arr[curByte++] = (tmp >> 16) & 0xFF
                arr[curByte++] = (tmp >> 8) & 0xFF
                arr[curByte++] = tmp & 0xFF
            }

            if (placeHoldersLen === 2) {
                tmp =
                        (revLookup[b64.charCodeAt(i)] << 2) |
                        (revLookup[b64.charCodeAt(i + 1)] >> 4)
                arr[curByte++] = tmp & 0xFF
            }

            if (placeHoldersLen === 1) {
                tmp =
                        (revLookup[b64.charCodeAt(i)] << 10) |
                        (revLookup[b64.charCodeAt(i + 1)] << 4) |
                        (revLookup[b64.charCodeAt(i + 2)] >> 2)
                arr[curByte++] = (tmp >> 8) & 0xFF
                arr[curByte++] = tmp & 0xFF
            }

            return arr
        }

        function tripletToBase64 (num) {
            return lookup[num >> 18 & 0x3F] +
                    lookup[num >> 12 & 0x3F] +
                    lookup[num >> 6 & 0x3F] +
                    lookup[num & 0x3F]
        }

        function encodeChunk (uint8, start, end) {
            var tmp
            var output = []
            for (var i = start; i < end; i += 3) {
                tmp =
                        ((uint8[i] << 16) & 0xFF0000) +
                        ((uint8[i + 1] << 8) & 0xFF00) +
                        (uint8[i + 2] & 0xFF)
                output.push(tripletToBase64(tmp))
            }
            return output.join('')
        }

        function fromByteArray (uint8) {
            var tmp
            var len = uint8.length
            var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
            var parts = []
            var maxChunkLength = 16383 // must be multiple of 3

            // go through the array every three bytes, we'll deal with trailing stuff later
            for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
                parts.push(encodeChunk(
                        uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
                ))
            }

            // pad the end with zeros, but make sure to not forget the extra bytes
            if (extraBytes === 1) {
                tmp = uint8[len - 1]
                parts.push(
                        lookup[tmp >> 2] +
                        lookup[(tmp << 4) & 0x3F] +
                        '=='
                )
            } else if (extraBytes === 2) {
                tmp = (uint8[len - 2] << 8) + uint8[len - 1]
                parts.push(
                        lookup[tmp >> 10] +
                        lookup[(tmp >> 4) & 0x3F] +
                        lookup[(tmp << 2) & 0x3F] +
                        '='
                )
            }

            return parts.join('')
        }

    },{}],6:[function(require,module,exports){
        (function (global){
            /**
             * Create a blob builder even when vendor prefixes exist
             */

            var BlobBuilder = global.BlobBuilder
                    || global.WebKitBlobBuilder
                    || global.MSBlobBuilder
                    || global.MozBlobBuilder;

            /**
             * Check if Blob constructor is supported
             */

            var blobSupported = (function() {
                try {
                    var a = new Blob(['hi']);
                    return a.size === 2;
                } catch(e) {
                    return false;
                }
            })();

            /**
             * Check if Blob constructor supports ArrayBufferViews
             * Fails in Safari 6, so we need to map to ArrayBuffers there.
             */

            var blobSupportsArrayBufferView = blobSupported && (function() {
                        try {
                            var b = new Blob([new Uint8Array([1,2])]);
                            return b.size === 2;
                        } catch(e) {
                            return false;
                        }
                    })();

            /**
             * Check if BlobBuilder is supported
             */

            var blobBuilderSupported = BlobBuilder
                    && BlobBuilder.prototype.append
                    && BlobBuilder.prototype.getBlob;

            /**
             * Helper function that maps ArrayBufferViews to ArrayBuffers
             * Used by BlobBuilder constructor and old browsers that didn't
             * support it in the Blob constructor.
             */

            function mapArrayBufferViews(ary) {
                for (var i = 0; i < ary.length; i++) {
                    var chunk = ary[i];
                    if (chunk.buffer instanceof ArrayBuffer) {
                        var buf = chunk.buffer;

                        // if this is a subarray, make a copy so we only
                        // include the subarray region from the underlying buffer
                        if (chunk.byteLength !== buf.byteLength) {
                            var copy = new Uint8Array(chunk.byteLength);
                            copy.set(new Uint8Array(buf, chunk.byteOffset, chunk.byteLength));
                            buf = copy.buffer;
                        }

                        ary[i] = buf;
                    }
                }
            }

            function BlobBuilderConstructor(ary, options) {
                options = options || {};

                var bb = new BlobBuilder();
                mapArrayBufferViews(ary);

                for (var i = 0; i < ary.length; i++) {
                    bb.append(ary[i]);
                }

                return (options.type) ? bb.getBlob(options.type) : bb.getBlob();
            };

            function BlobConstructor(ary, options) {
                mapArrayBufferViews(ary);
                return new Blob(ary, options || {});
            };

            module.exports = (function() {
                if (blobSupported) {
                    return blobSupportsArrayBufferView ? global.Blob : BlobConstructor;
                } else if (blobBuilderSupported) {
                    return BlobBuilderConstructor;
                } else {
                    return undefined;
                }
            })();

        }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
    },{}],7:[function(require,module,exports){

    },{}],8:[function(require,module,exports){
        /*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
        /* eslint-disable no-proto */

        'use strict'

        var base64 = require('base64-js')
        var ieee754 = require('ieee754')

        exports.Buffer = Buffer
        exports.SlowBuffer = SlowBuffer
        exports.INSPECT_MAX_BYTES = 50

        var K_MAX_LENGTH = 0x7fffffff
        exports.kMaxLength = K_MAX_LENGTH

        /**
         * If `Buffer.TYPED_ARRAY_SUPPORT`:
         *   === true    Use Uint8Array implementation (fastest)
         *   === false   Print warning and recommend using `buffer` v4.x which has an Object
         *               implementation (most compatible, even IE6)
         *
         * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
         * Opera 11.6+, iOS 4.2+.
         *
         * We report that the browser does not support typed arrays if the are not subclassable
         * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
         * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
         * for __proto__ and has a buggy typed array implementation.
         */
        Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

        if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
                typeof console.error === 'function') {
            console.error(
                    'This browser lacks typed array (Uint8Array) support which is required by ' +
                    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
            )
        }

        function typedArraySupport () {
            // Can typed array instances can be augmented?
            try {
                var arr = new Uint8Array(1)
                arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
                return arr.foo() === 42
            } catch (e) {
                return false
            }
        }

        Object.defineProperty(Buffer.prototype, 'parent', {
            get: function () {
                if (!(this instanceof Buffer)) {
                    return undefined
                }
                return this.buffer
            }
        })

        Object.defineProperty(Buffer.prototype, 'offset', {
            get: function () {
                if (!(this instanceof Buffer)) {
                    return undefined
                }
                return this.byteOffset
            }
        })

        function createBuffer (length) {
            if (length > K_MAX_LENGTH) {
                throw new RangeError('Invalid typed array length')
            }
            // Return an augmented `Uint8Array` instance
            var buf = new Uint8Array(length)
            buf.__proto__ = Buffer.prototype
            return buf
        }

        /**
         * The Buffer constructor returns instances of `Uint8Array` that have their
         * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
         * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
         * and the `Uint8Array` methods. Square bracket notation works as expected -- it
         * returns a single octet.
         *
         * The `Uint8Array` prototype remains unmodified.
         */

        function Buffer (arg, encodingOrOffset, length) {
            // Common case.
            if (typeof arg === 'number') {
                if (typeof encodingOrOffset === 'string') {
                    throw new Error(
                            'If encoding is specified then the first argument must be a string'
                    )
                }
                return allocUnsafe(arg)
            }
            return from(arg, encodingOrOffset, length)
        }

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
        if (typeof Symbol !== 'undefined' && Symbol.species &&
                Buffer[Symbol.species] === Buffer) {
            Object.defineProperty(Buffer, Symbol.species, {
                value: null,
                configurable: true,
                enumerable: false,
                writable: false
            })
        }

        Buffer.poolSize = 8192 // not used by this implementation

        function from (value, encodingOrOffset, length) {
            if (typeof value === 'number') {
                throw new TypeError('"value" argument must not be a number')
            }

            if (isArrayBuffer(value) || (value && isArrayBuffer(value.buffer))) {
                return fromArrayBuffer(value, encodingOrOffset, length)
            }

            if (typeof value === 'string') {
                return fromString(value, encodingOrOffset)
            }

            return fromObject(value)
        }

        /**
         * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
         * if value is a number.
         * Buffer.from(str[, encoding])
         * Buffer.from(array)
         * Buffer.from(buffer)
         * Buffer.from(arrayBuffer[, byteOffset[, length]])
         **/
        Buffer.from = function (value, encodingOrOffset, length) {
            return from(value, encodingOrOffset, length)
        }

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
        Buffer.prototype.__proto__ = Uint8Array.prototype
        Buffer.__proto__ = Uint8Array

        function assertSize (size) {
            if (typeof size !== 'number') {
                throw new TypeError('"size" argument must be of type number')
            } else if (size < 0) {
                throw new RangeError('"size" argument must not be negative')
            }
        }

        function alloc (size, fill, encoding) {
            assertSize(size)
            if (size <= 0) {
                return createBuffer(size)
            }
            if (fill !== undefined) {
                // Only pay attention to encoding if it's a string. This
                // prevents accidentally sending in a number that would
                // be interpretted as a start offset.
                return typeof encoding === 'string'
                        ? createBuffer(size).fill(fill, encoding)
                        : createBuffer(size).fill(fill)
            }
            return createBuffer(size)
        }

        /**
         * Creates a new filled Buffer instance.
         * alloc(size[, fill[, encoding]])
         **/
        Buffer.alloc = function (size, fill, encoding) {
            return alloc(size, fill, encoding)
        }

        function allocUnsafe (size) {
            assertSize(size)
            return createBuffer(size < 0 ? 0 : checked(size) | 0)
        }

        /**
         * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
         * */
        Buffer.allocUnsafe = function (size) {
            return allocUnsafe(size)
        }
        /**
         * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
         */
        Buffer.allocUnsafeSlow = function (size) {
            return allocUnsafe(size)
        }

        function fromString (string, encoding) {
            if (typeof encoding !== 'string' || encoding === '') {
                encoding = 'utf8'
            }

            if (!Buffer.isEncoding(encoding)) {
                throw new TypeError('Unknown encoding: ' + encoding)
            }

            var length = byteLength(string, encoding) | 0
            var buf = createBuffer(length)

            var actual = buf.write(string, encoding)

            if (actual !== length) {
                // Writing a hex string, for example, that contains invalid characters will
                // cause everything after the first invalid character to be ignored. (e.g.
                // 'abxxcd' will be treated as 'ab')
                buf = buf.slice(0, actual)
            }

            return buf
        }

        function fromArrayLike (array) {
            var length = array.length < 0 ? 0 : checked(array.length) | 0
            var buf = createBuffer(length)
            for (var i = 0; i < length; i += 1) {
                buf[i] = array[i] & 255
            }
            return buf
        }

        function fromArrayBuffer (array, byteOffset, length) {
            if (byteOffset < 0 || array.byteLength < byteOffset) {
                throw new RangeError('"offset" is outside of buffer bounds')
            }

            if (array.byteLength < byteOffset + (length || 0)) {
                throw new RangeError('"length" is outside of buffer bounds')
            }

            var buf
            if (byteOffset === undefined && length === undefined) {
                buf = new Uint8Array(array)
            } else if (length === undefined) {
                buf = new Uint8Array(array, byteOffset)
            } else {
                buf = new Uint8Array(array, byteOffset, length)
            }

            // Return an augmented `Uint8Array` instance
            buf.__proto__ = Buffer.prototype
            return buf
        }

        function fromObject (obj) {
            if (Buffer.isBuffer(obj)) {
                var len = checked(obj.length) | 0
                var buf = createBuffer(len)

                if (buf.length === 0) {
                    return buf
                }

                obj.copy(buf, 0, 0, len)
                return buf
            }

            if (obj) {
                if (ArrayBuffer.isView(obj) || 'length' in obj) {
                    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
                        return createBuffer(0)
                    }
                    return fromArrayLike(obj)
                }

                if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
                    return fromArrayLike(obj.data)
                }
            }

            throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object.')
        }

        function checked (length) {
            // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
            // length is NaN (which is otherwise coerced to zero.)
            if (length >= K_MAX_LENGTH) {
                throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                        'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
            }
            return length | 0
        }

        function SlowBuffer (length) {
            if (+length != length) { // eslint-disable-line eqeqeq
                length = 0
            }
            return Buffer.alloc(+length)
        }

        Buffer.isBuffer = function isBuffer (b) {
            return b != null && b._isBuffer === true
        }

        Buffer.compare = function compare (a, b) {
            if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
                throw new TypeError('Arguments must be Buffers')
            }

            if (a === b) return 0

            var x = a.length
            var y = b.length

            for (var i = 0, len = Math.min(x, y); i < len; ++i) {
                if (a[i] !== b[i]) {
                    x = a[i]
                    y = b[i]
                    break
                }
            }

            if (x < y) return -1
            if (y < x) return 1
            return 0
        }

        Buffer.isEncoding = function isEncoding (encoding) {
            switch (String(encoding).toLowerCase()) {
                case 'hex':
                case 'utf8':
                case 'utf-8':
                case 'ascii':
                case 'latin1':
                case 'binary':
                case 'base64':
                case 'ucs2':
                case 'ucs-2':
                case 'utf16le':
                case 'utf-16le':
                    return true
                default:
                    return false
            }
        }

        Buffer.concat = function concat (list, length) {
            if (!Array.isArray(list)) {
                throw new TypeError('"list" argument must be an Array of Buffers')
            }

            if (list.length === 0) {
                return Buffer.alloc(0)
            }

            var i
            if (length === undefined) {
                length = 0
                for (i = 0; i < list.length; ++i) {
                    length += list[i].length
                }
            }

            var buffer = Buffer.allocUnsafe(length)
            var pos = 0
            for (i = 0; i < list.length; ++i) {
                var buf = list[i]
                if (ArrayBuffer.isView(buf)) {
                    buf = Buffer.from(buf)
                }
                if (!Buffer.isBuffer(buf)) {
                    throw new TypeError('"list" argument must be an Array of Buffers')
                }
                buf.copy(buffer, pos)
                pos += buf.length
            }
            return buffer
        }

        function byteLength (string, encoding) {
            if (Buffer.isBuffer(string)) {
                return string.length
            }
            if (ArrayBuffer.isView(string) || isArrayBuffer(string)) {
                return string.byteLength
            }
            if (typeof string !== 'string') {
                string = '' + string
            }

            var len = string.length
            if (len === 0) return 0

            // Use a for loop to avoid recursion
            var loweredCase = false
            for (;;) {
                switch (encoding) {
                    case 'ascii':
                    case 'latin1':
                    case 'binary':
                        return len
                    case 'utf8':
                    case 'utf-8':
                    case undefined:
                        return utf8ToBytes(string).length
                    case 'ucs2':
                    case 'ucs-2':
                    case 'utf16le':
                    case 'utf-16le':
                        return len * 2
                    case 'hex':
                        return len >>> 1
                    case 'base64':
                        return base64ToBytes(string).length
                    default:
                        if (loweredCase) return utf8ToBytes(string).length // assume utf8
                        encoding = ('' + encoding).toLowerCase()
                        loweredCase = true
                }
            }
        }
        Buffer.byteLength = byteLength

        function slowToString (encoding, start, end) {
            var loweredCase = false

            // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
            // property of a typed array.

            // This behaves neither like String nor Uint8Array in that we set start/end
            // to their upper/lower bounds if the value passed is out of range.
            // undefined is handled specially as per ECMA-262 6th Edition,
            // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
            if (start === undefined || start < 0) {
                start = 0
            }
            // Return early if start > this.length. Done here to prevent potential uint32
            // coercion fail below.
            if (start > this.length) {
                return ''
            }

            if (end === undefined || end > this.length) {
                end = this.length
            }

            if (end <= 0) {
                return ''
            }

            // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
            end >>>= 0
            start >>>= 0

            if (end <= start) {
                return ''
            }

            if (!encoding) encoding = 'utf8'

            while (true) {
                switch (encoding) {
                    case 'hex':
                        return hexSlice(this, start, end)

                    case 'utf8':
                    case 'utf-8':
                        return utf8Slice(this, start, end)

                    case 'ascii':
                        return asciiSlice(this, start, end)

                    case 'latin1':
                    case 'binary':
                        return latin1Slice(this, start, end)

                    case 'base64':
                        return base64Slice(this, start, end)

                    case 'ucs2':
                    case 'ucs-2':
                    case 'utf16le':
                    case 'utf-16le':
                        return utf16leSlice(this, start, end)

                    default:
                        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
                        encoding = (encoding + '').toLowerCase()
                        loweredCase = true
                }
            }
        }

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
        Buffer.prototype._isBuffer = true

        function swap (b, n, m) {
            var i = b[n]
            b[n] = b[m]
            b[m] = i
        }

        Buffer.prototype.swap16 = function swap16 () {
            var len = this.length
            if (len % 2 !== 0) {
                throw new RangeError('Buffer size must be a multiple of 16-bits')
            }
            for (var i = 0; i < len; i += 2) {
                swap(this, i, i + 1)
            }
            return this
        }

        Buffer.prototype.swap32 = function swap32 () {
            var len = this.length
            if (len % 4 !== 0) {
                throw new RangeError('Buffer size must be a multiple of 32-bits')
            }
            for (var i = 0; i < len; i += 4) {
                swap(this, i, i + 3)
                swap(this, i + 1, i + 2)
            }
            return this
        }

        Buffer.prototype.swap64 = function swap64 () {
            var len = this.length
            if (len % 8 !== 0) {
                throw new RangeError('Buffer size must be a multiple of 64-bits')
            }
            for (var i = 0; i < len; i += 8) {
                swap(this, i, i + 7)
                swap(this, i + 1, i + 6)
                swap(this, i + 2, i + 5)
                swap(this, i + 3, i + 4)
            }
            return this
        }

        Buffer.prototype.toString = function toString () {
            var length = this.length
            if (length === 0) return ''
            if (arguments.length === 0) return utf8Slice(this, 0, length)
            return slowToString.apply(this, arguments)
        }

        Buffer.prototype.toLocaleString = Buffer.prototype.toString

        Buffer.prototype.equals = function equals (b) {
            if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
            if (this === b) return true
            return Buffer.compare(this, b) === 0
        }

        Buffer.prototype.inspect = function inspect () {
            var str = ''
            var max = exports.INSPECT_MAX_BYTES
            if (this.length > 0) {
                str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
                if (this.length > max) str += ' ... '
            }
            return '<Buffer ' + str + '>'
        }

        Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
            if (!Buffer.isBuffer(target)) {
                throw new TypeError('Argument must be a Buffer')
            }

            if (start === undefined) {
                start = 0
            }
            if (end === undefined) {
                end = target ? target.length : 0
            }
            if (thisStart === undefined) {
                thisStart = 0
            }
            if (thisEnd === undefined) {
                thisEnd = this.length
            }

            if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
                throw new RangeError('out of range index')
            }

            if (thisStart >= thisEnd && start >= end) {
                return 0
            }
            if (thisStart >= thisEnd) {
                return -1
            }
            if (start >= end) {
                return 1
            }

            start >>>= 0
            end >>>= 0
            thisStart >>>= 0
            thisEnd >>>= 0

            if (this === target) return 0

            var x = thisEnd - thisStart
            var y = end - start
            var len = Math.min(x, y)

            var thisCopy = this.slice(thisStart, thisEnd)
            var targetCopy = target.slice(start, end)

            for (var i = 0; i < len; ++i) {
                if (thisCopy[i] !== targetCopy[i]) {
                    x = thisCopy[i]
                    y = targetCopy[i]
                    break
                }
            }

            if (x < y) return -1
            if (y < x) return 1
            return 0
        }

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
        function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
            // Empty buffer means no match
            if (buffer.length === 0) return -1

            // Normalize byteOffset
            if (typeof byteOffset === 'string') {
                encoding = byteOffset
                byteOffset = 0
            } else if (byteOffset > 0x7fffffff) {
                byteOffset = 0x7fffffff
            } else if (byteOffset < -0x80000000) {
                byteOffset = -0x80000000
            }
            byteOffset = +byteOffset  // Coerce to Number.
            if (numberIsNaN(byteOffset)) {
                // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
                byteOffset = dir ? 0 : (buffer.length - 1)
            }

            // Normalize byteOffset: negative offsets start from the end of the buffer
            if (byteOffset < 0) byteOffset = buffer.length + byteOffset
            if (byteOffset >= buffer.length) {
                if (dir) return -1
                else byteOffset = buffer.length - 1
            } else if (byteOffset < 0) {
                if (dir) byteOffset = 0
                else return -1
            }

            // Normalize val
            if (typeof val === 'string') {
                val = Buffer.from(val, encoding)
            }

            // Finally, search either indexOf (if dir is true) or lastIndexOf
            if (Buffer.isBuffer(val)) {
                // Special case: looking for empty string/buffer always fails
                if (val.length === 0) {
                    return -1
                }
                return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
            } else if (typeof val === 'number') {
                val = val & 0xFF // Search for a byte value [0-255]
                if (typeof Uint8Array.prototype.indexOf === 'function') {
                    if (dir) {
                        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
                    } else {
                        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
                    }
                }
                return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
            }

            throw new TypeError('val must be string, number or Buffer')
        }

        function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
            var indexSize = 1
            var arrLength = arr.length
            var valLength = val.length

            if (encoding !== undefined) {
                encoding = String(encoding).toLowerCase()
                if (encoding === 'ucs2' || encoding === 'ucs-2' ||
                        encoding === 'utf16le' || encoding === 'utf-16le') {
                    if (arr.length < 2 || val.length < 2) {
                        return -1
                    }
                    indexSize = 2
                    arrLength /= 2
                    valLength /= 2
                    byteOffset /= 2
                }
            }

            function read (buf, i) {
                if (indexSize === 1) {
                    return buf[i]
                } else {
                    return buf.readUInt16BE(i * indexSize)
                }
            }

            var i
            if (dir) {
                var foundIndex = -1
                for (i = byteOffset; i < arrLength; i++) {
                    if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
                        if (foundIndex === -1) foundIndex = i
                        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
                    } else {
                        if (foundIndex !== -1) i -= i - foundIndex
                        foundIndex = -1
                    }
                }
            } else {
                if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
                for (i = byteOffset; i >= 0; i--) {
                    var found = true
                    for (var j = 0; j < valLength; j++) {
                        if (read(arr, i + j) !== read(val, j)) {
                            found = false
                            break
                        }
                    }
                    if (found) return i
                }
            }

            return -1
        }

        Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
            return this.indexOf(val, byteOffset, encoding) !== -1
        }

        Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
            return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
        }

        Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
            return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
        }

        function hexWrite (buf, string, offset, length) {
            offset = Number(offset) || 0
            var remaining = buf.length - offset
            if (!length) {
                length = remaining
            } else {
                length = Number(length)
                if (length > remaining) {
                    length = remaining
                }
            }

            var strLen = string.length

            if (length > strLen / 2) {
                length = strLen / 2
            }
            for (var i = 0; i < length; ++i) {
                var parsed = parseInt(string.substr(i * 2, 2), 16)
                if (numberIsNaN(parsed)) return i
                buf[offset + i] = parsed
            }
            return i
        }

        function utf8Write (buf, string, offset, length) {
            return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
        }

        function asciiWrite (buf, string, offset, length) {
            return blitBuffer(asciiToBytes(string), buf, offset, length)
        }

        function latin1Write (buf, string, offset, length) {
            return asciiWrite(buf, string, offset, length)
        }

        function base64Write (buf, string, offset, length) {
            return blitBuffer(base64ToBytes(string), buf, offset, length)
        }

        function ucs2Write (buf, string, offset, length) {
            return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
        }

        Buffer.prototype.write = function write (string, offset, length, encoding) {
            // Buffer#write(string)
            if (offset === undefined) {
                encoding = 'utf8'
                length = this.length
                offset = 0
                // Buffer#write(string, encoding)
            } else if (length === undefined && typeof offset === 'string') {
                encoding = offset
                length = this.length
                offset = 0
                // Buffer#write(string, offset[, length][, encoding])
            } else if (isFinite(offset)) {
                offset = offset >>> 0
                if (isFinite(length)) {
                    length = length >>> 0
                    if (encoding === undefined) encoding = 'utf8'
                } else {
                    encoding = length
                    length = undefined
                }
            } else {
                throw new Error(
                        'Buffer.write(string, encoding, offset[, length]) is no longer supported'
                )
            }

            var remaining = this.length - offset
            if (length === undefined || length > remaining) length = remaining

            if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
                throw new RangeError('Attempt to write outside buffer bounds')
            }

            if (!encoding) encoding = 'utf8'

            var loweredCase = false
            for (;;) {
                switch (encoding) {
                    case 'hex':
                        return hexWrite(this, string, offset, length)

                    case 'utf8':
                    case 'utf-8':
                        return utf8Write(this, string, offset, length)

                    case 'ascii':
                        return asciiWrite(this, string, offset, length)

                    case 'latin1':
                    case 'binary':
                        return latin1Write(this, string, offset, length)

                    case 'base64':
                        // Warning: maxLength not taken into account in base64Write
                        return base64Write(this, string, offset, length)

                    case 'ucs2':
                    case 'ucs-2':
                    case 'utf16le':
                    case 'utf-16le':
                        return ucs2Write(this, string, offset, length)

                    default:
                        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
                        encoding = ('' + encoding).toLowerCase()
                        loweredCase = true
                }
            }
        }

        Buffer.prototype.toJSON = function toJSON () {
            return {
                type: 'Buffer',
                data: Array.prototype.slice.call(this._arr || this, 0)
            }
        }

        function base64Slice (buf, start, end) {
            if (start === 0 && end === buf.length) {
                return base64.fromByteArray(buf)
            } else {
                return base64.fromByteArray(buf.slice(start, end))
            }
        }

        function utf8Slice (buf, start, end) {
            end = Math.min(buf.length, end)
            var res = []

            var i = start
            while (i < end) {
                var firstByte = buf[i]
                var codePoint = null
                var bytesPerSequence = (firstByte > 0xEF) ? 4
                        : (firstByte > 0xDF) ? 3
                                : (firstByte > 0xBF) ? 2
                                        : 1

                if (i + bytesPerSequence <= end) {
                    var secondByte, thirdByte, fourthByte, tempCodePoint

                    switch (bytesPerSequence) {
                        case 1:
                            if (firstByte < 0x80) {
                                codePoint = firstByte
                            }
                            break
                        case 2:
                            secondByte = buf[i + 1]
                            if ((secondByte & 0xC0) === 0x80) {
                                tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
                                if (tempCodePoint > 0x7F) {
                                    codePoint = tempCodePoint
                                }
                            }
                            break
                        case 3:
                            secondByte = buf[i + 1]
                            thirdByte = buf[i + 2]
                            if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                                tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
                                if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                                    codePoint = tempCodePoint
                                }
                            }
                            break
                        case 4:
                            secondByte = buf[i + 1]
                            thirdByte = buf[i + 2]
                            fourthByte = buf[i + 3]
                            if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                                tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
                                if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                                    codePoint = tempCodePoint
                                }
                            }
                    }
                }

                if (codePoint === null) {
                    // we did not generate a valid codePoint so insert a
                    // replacement char (U+FFFD) and advance only 1 byte
                    codePoint = 0xFFFD
                    bytesPerSequence = 1
                } else if (codePoint > 0xFFFF) {
                    // encode to utf16 (surrogate pair dance)
                    codePoint -= 0x10000
                    res.push(codePoint >>> 10 & 0x3FF | 0xD800)
                    codePoint = 0xDC00 | codePoint & 0x3FF
                }

                res.push(codePoint)
                i += bytesPerSequence
            }

            return decodeCodePointsArray(res)
        }

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
        var MAX_ARGUMENTS_LENGTH = 0x1000

        function decodeCodePointsArray (codePoints) {
            var len = codePoints.length
            if (len <= MAX_ARGUMENTS_LENGTH) {
                return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
            }

            // Decode in chunks to avoid "call stack size exceeded".
            var res = ''
            var i = 0
            while (i < len) {
                res += String.fromCharCode.apply(
                        String,
                        codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
                )
            }
            return res
        }

        function asciiSlice (buf, start, end) {
            var ret = ''
            end = Math.min(buf.length, end)

            for (var i = start; i < end; ++i) {
                ret += String.fromCharCode(buf[i] & 0x7F)
            }
            return ret
        }

        function latin1Slice (buf, start, end) {
            var ret = ''
            end = Math.min(buf.length, end)

            for (var i = start; i < end; ++i) {
                ret += String.fromCharCode(buf[i])
            }
            return ret
        }

        function hexSlice (buf, start, end) {
            var len = buf.length

            if (!start || start < 0) start = 0
            if (!end || end < 0 || end > len) end = len

            var out = ''
            for (var i = start; i < end; ++i) {
                out += toHex(buf[i])
            }
            return out
        }

        function utf16leSlice (buf, start, end) {
            var bytes = buf.slice(start, end)
            var res = ''
            for (var i = 0; i < bytes.length; i += 2) {
                res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
            }
            return res
        }

        Buffer.prototype.slice = function slice (start, end) {
            var len = this.length
            start = ~~start
            end = end === undefined ? len : ~~end

            if (start < 0) {
                start += len
                if (start < 0) start = 0
            } else if (start > len) {
                start = len
            }

            if (end < 0) {
                end += len
                if (end < 0) end = 0
            } else if (end > len) {
                end = len
            }

            if (end < start) end = start

            var newBuf = this.subarray(start, end)
            // Return an augmented `Uint8Array` instance
            newBuf.__proto__ = Buffer.prototype
            return newBuf
        }

        /*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
        function checkOffset (offset, ext, length) {
            if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
            if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
        }

        Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
            offset = offset >>> 0
            byteLength = byteLength >>> 0
            if (!noAssert) checkOffset(offset, byteLength, this.length)

            var val = this[offset]
            var mul = 1
            var i = 0
            while (++i < byteLength && (mul *= 0x100)) {
                val += this[offset + i] * mul
            }

            return val
        }

        Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
            offset = offset >>> 0
            byteLength = byteLength >>> 0
            if (!noAssert) {
                checkOffset(offset, byteLength, this.length)
            }

            var val = this[offset + --byteLength]
            var mul = 1
            while (byteLength > 0 && (mul *= 0x100)) {
                val += this[offset + --byteLength] * mul
            }

            return val
        }

        Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
            offset = offset >>> 0
            if (!noAssert) checkOffset(offset, 1, this.length)
            return this[offset]
        }

        Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
            offset = offset >>> 0
            if (!noAssert) checkOffset(offset, 2, this.length)
            return this[offset] | (this[offset + 1] << 8)
        }

        Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
            offset = offset >>> 0
            if (!noAssert) checkOffset(offset, 2, this.length)
            return (this[offset] << 8) | this[offset + 1]
        }

        Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
            offset = offset >>> 0
            if (!noAssert) checkOffset(offset, 4, this.length)

            return ((this[offset]) |
                    (this[offset + 1] << 8) |
                    (this[offset + 2] << 16)) +
                    (this[offset + 3] * 0x1000000)
        }

        Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
            offset = offset >>> 0
            if (!noAssert) checkOffset(offset, 4, this.length)

            return (this[offset] * 0x1000000) +
                    ((this[offset + 1] << 16) |
                    (this[offset + 2] << 8) |
                    this[offset + 3])
        }

        Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
            offset = offset >>> 0
            byteLength = byteLength >>> 0
            if (!noAssert) checkOffset(offset, byteLength, this.length)

            var val = this[offset]
            var mul = 1
            var i = 0
            while (++i < byteLength && (mul *= 0x100)) {
                val += this[offset + i] * mul
            }
            mul *= 0x80

            if (val >= mul) val -= Math.pow(2, 8 * byteLength)

            return val
        }

        Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
            offset = offset >>> 0
            byteLength = byteLength >>> 0
            if (!noAssert) checkOffset(offset, byteLength, this.length)

            var i = byteLength
            var mul = 1
            var val = this[offset + --i]
            while (i > 0 && (mul *= 0x100)) {
                val += this[offset + --i] * mul
            }
            mul *= 0x80

            if (val >= mul) val -= Math.pow(2, 8 * byteLength)

            return val
        }

        Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
            offset = offset >>> 0
            if (!noAssert) checkOffset(offset, 1, this.length)
            if (!(this[offset] & 0x80)) return (this[offset])
            return ((0xff - this[offset] + 1) * -1)
        }

        Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
            offset = offset >>> 0
            if (!noAssert) checkOffset(offset, 2, this.length)
            var val = this[offset] | (this[offset + 1] << 8)
            return (val & 0x8000) ? val | 0xFFFF0000 : val
        }

        Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
            offset = offset >>> 0
            if (!noAssert) checkOffset(offset, 2, this.length)
            var val = this[offset + 1] | (this[offset] << 8)
            return (val & 0x8000) ? val | 0xFFFF0000 : val
        }

        Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
            offset = offset >>> 0
            if (!noAssert) checkOffset(offset, 4, this.length)

            return (this[offset]) |
                    (this[offset + 1] << 8) |
                    (this[offset + 2] << 16) |
                    (this[offset + 3] << 24)
        }

        Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
            offset = offset >>> 0
            if (!noAssert) checkOffset(offset, 4, this.length)

            return (this[offset] << 24) |
                    (this[offset + 1] << 16) |
                    (this[offset + 2] << 8) |
                    (this[offset + 3])
        }

        Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
            offset = offset >>> 0
            if (!noAssert) checkOffset(offset, 4, this.length)
            return ieee754.read(this, offset, true, 23, 4)
        }

        Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
            offset = offset >>> 0
            if (!noAssert) checkOffset(offset, 4, this.length)
            return ieee754.read(this, offset, false, 23, 4)
        }

        Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
            offset = offset >>> 0
            if (!noAssert) checkOffset(offset, 8, this.length)
            return ieee754.read(this, offset, true, 52, 8)
        }

        Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
            offset = offset >>> 0
            if (!noAssert) checkOffset(offset, 8, this.length)
            return ieee754.read(this, offset, false, 52, 8)
        }

        function checkInt (buf, value, offset, ext, max, min) {
            if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
            if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
            if (offset + ext > buf.length) throw new RangeError('Index out of range')
        }

        Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
            value = +value
            offset = offset >>> 0
            byteLength = byteLength >>> 0
            if (!noAssert) {
                var maxBytes = Math.pow(2, 8 * byteLength) - 1
                checkInt(this, value, offset, byteLength, maxBytes, 0)
            }

            var mul = 1
            var i = 0
            this[offset] = value & 0xFF
            while (++i < byteLength && (mul *= 0x100)) {
                this[offset + i] = (value / mul) & 0xFF
            }

            return offset + byteLength
        }

        Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
            value = +value
            offset = offset >>> 0
            byteLength = byteLength >>> 0
            if (!noAssert) {
                var maxBytes = Math.pow(2, 8 * byteLength) - 1
                checkInt(this, value, offset, byteLength, maxBytes, 0)
            }

            var i = byteLength - 1
            var mul = 1
            this[offset + i] = value & 0xFF
            while (--i >= 0 && (mul *= 0x100)) {
                this[offset + i] = (value / mul) & 0xFF
            }

            return offset + byteLength
        }

        Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
            value = +value
            offset = offset >>> 0
            if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
            this[offset] = (value & 0xff)
            return offset + 1
        }

        Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
            value = +value
            offset = offset >>> 0
            if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
            this[offset] = (value & 0xff)
            this[offset + 1] = (value >>> 8)
            return offset + 2
        }

        Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
            value = +value
            offset = offset >>> 0
            if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
            this[offset] = (value >>> 8)
            this[offset + 1] = (value & 0xff)
            return offset + 2
        }

        Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
            value = +value
            offset = offset >>> 0
            if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
            this[offset + 3] = (value >>> 24)
            this[offset + 2] = (value >>> 16)
            this[offset + 1] = (value >>> 8)
            this[offset] = (value & 0xff)
            return offset + 4
        }

        Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
            value = +value
            offset = offset >>> 0
            if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
            this[offset] = (value >>> 24)
            this[offset + 1] = (value >>> 16)
            this[offset + 2] = (value >>> 8)
            this[offset + 3] = (value & 0xff)
            return offset + 4
        }

        Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
            value = +value
            offset = offset >>> 0
            if (!noAssert) {
                var limit = Math.pow(2, (8 * byteLength) - 1)

                checkInt(this, value, offset, byteLength, limit - 1, -limit)
            }

            var i = 0
            var mul = 1
            var sub = 0
            this[offset] = value & 0xFF
            while (++i < byteLength && (mul *= 0x100)) {
                if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
                    sub = 1
                }
                this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
            }

            return offset + byteLength
        }

        Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
            value = +value
            offset = offset >>> 0
            if (!noAssert) {
                var limit = Math.pow(2, (8 * byteLength) - 1)

                checkInt(this, value, offset, byteLength, limit - 1, -limit)
            }

            var i = byteLength - 1
            var mul = 1
            var sub = 0
            this[offset + i] = value & 0xFF
            while (--i >= 0 && (mul *= 0x100)) {
                if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
                    sub = 1
                }
                this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
            }

            return offset + byteLength
        }

        Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
            value = +value
            offset = offset >>> 0
            if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
            if (value < 0) value = 0xff + value + 1
            this[offset] = (value & 0xff)
            return offset + 1
        }

        Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
            value = +value
            offset = offset >>> 0
            if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
            this[offset] = (value & 0xff)
            this[offset + 1] = (value >>> 8)
            return offset + 2
        }

        Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
            value = +value
            offset = offset >>> 0
            if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
            this[offset] = (value >>> 8)
            this[offset + 1] = (value & 0xff)
            return offset + 2
        }

        Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
            value = +value
            offset = offset >>> 0
            if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
            this[offset] = (value & 0xff)
            this[offset + 1] = (value >>> 8)
            this[offset + 2] = (value >>> 16)
            this[offset + 3] = (value >>> 24)
            return offset + 4
        }

        Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
            value = +value
            offset = offset >>> 0
            if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
            if (value < 0) value = 0xffffffff + value + 1
            this[offset] = (value >>> 24)
            this[offset + 1] = (value >>> 16)
            this[offset + 2] = (value >>> 8)
            this[offset + 3] = (value & 0xff)
            return offset + 4
        }

        function checkIEEE754 (buf, value, offset, ext, max, min) {
            if (offset + ext > buf.length) throw new RangeError('Index out of range')
            if (offset < 0) throw new RangeError('Index out of range')
        }

        function writeFloat (buf, value, offset, littleEndian, noAssert) {
            value = +value
            offset = offset >>> 0
            if (!noAssert) {
                checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
            }
            ieee754.write(buf, value, offset, littleEndian, 23, 4)
            return offset + 4
        }

        Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
            return writeFloat(this, value, offset, true, noAssert)
        }

        Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
            return writeFloat(this, value, offset, false, noAssert)
        }

        function writeDouble (buf, value, offset, littleEndian, noAssert) {
            value = +value
            offset = offset >>> 0
            if (!noAssert) {
                checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
            }
            ieee754.write(buf, value, offset, littleEndian, 52, 8)
            return offset + 8
        }

        Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
            return writeDouble(this, value, offset, true, noAssert)
        }

        Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
            return writeDouble(this, value, offset, false, noAssert)
        }

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
        Buffer.prototype.copy = function copy (target, targetStart, start, end) {
            if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
            if (!start) start = 0
            if (!end && end !== 0) end = this.length
            if (targetStart >= target.length) targetStart = target.length
            if (!targetStart) targetStart = 0
            if (end > 0 && end < start) end = start

            // Copy 0 bytes; we're done
            if (end === start) return 0
            if (target.length === 0 || this.length === 0) return 0

            // Fatal error conditions
            if (targetStart < 0) {
                throw new RangeError('targetStart out of bounds')
            }
            if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
            if (end < 0) throw new RangeError('sourceEnd out of bounds')

            // Are we oob?
            if (end > this.length) end = this.length
            if (target.length - targetStart < end - start) {
                end = target.length - targetStart + start
            }

            var len = end - start

            if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
                // Use built-in when available, missing from IE11
                this.copyWithin(targetStart, start, end)
            } else if (this === target && start < targetStart && targetStart < end) {
                // descending copy from end
                for (var i = len - 1; i >= 0; --i) {
                    target[i + targetStart] = this[i + start]
                }
            } else {
                Uint8Array.prototype.set.call(
                        target,
                        this.subarray(start, end),
                        targetStart
                )
            }

            return len
        }

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
        Buffer.prototype.fill = function fill (val, start, end, encoding) {
            // Handle string cases:
            if (typeof val === 'string') {
                if (typeof start === 'string') {
                    encoding = start
                    start = 0
                    end = this.length
                } else if (typeof end === 'string') {
                    encoding = end
                    end = this.length
                }
                if (encoding !== undefined && typeof encoding !== 'string') {
                    throw new TypeError('encoding must be a string')
                }
                if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
                    throw new TypeError('Unknown encoding: ' + encoding)
                }
                if (val.length === 1) {
                    var code = val.charCodeAt(0)
                    if ((encoding === 'utf8' && code < 128) ||
                            encoding === 'latin1') {
                        // Fast path: If `val` fits into a single byte, use that numeric value.
                        val = code
                    }
                }
            } else if (typeof val === 'number') {
                val = val & 255
            }

            // Invalid ranges are not set to a default, so can range check early.
            if (start < 0 || this.length < start || this.length < end) {
                throw new RangeError('Out of range index')
            }

            if (end <= start) {
                return this
            }

            start = start >>> 0
            end = end === undefined ? this.length : end >>> 0

            if (!val) val = 0

            var i
            if (typeof val === 'number') {
                for (i = start; i < end; ++i) {
                    this[i] = val
                }
            } else {
                var bytes = Buffer.isBuffer(val)
                        ? val
                        : new Buffer(val, encoding)
                var len = bytes.length
                if (len === 0) {
                    throw new TypeError('The value "' + val +
                            '" is invalid for argument "value"')
                }
                for (i = 0; i < end - start; ++i) {
                    this[i + start] = bytes[i % len]
                }
            }

            return this
        }

// HELPER FUNCTIONS
// ================

        var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

        function base64clean (str) {
            // Node takes equal signs as end of the Base64 encoding
            str = str.split('=')[0]
            // Node strips out invalid characters like \n and \t from the string, base64-js does not
            str = str.trim().replace(INVALID_BASE64_RE, '')
            // Node converts strings with length < 2 to ''
            if (str.length < 2) return ''
            // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
            while (str.length % 4 !== 0) {
                str = str + '='
            }
            return str
        }

        function toHex (n) {
            if (n < 16) return '0' + n.toString(16)
            return n.toString(16)
        }

        function utf8ToBytes (string, units) {
            units = units || Infinity
            var codePoint
            var length = string.length
            var leadSurrogate = null
            var bytes = []

            for (var i = 0; i < length; ++i) {
                codePoint = string.charCodeAt(i)

                // is surrogate component
                if (codePoint > 0xD7FF && codePoint < 0xE000) {
                    // last char was a lead
                    if (!leadSurrogate) {
                        // no lead yet
                        if (codePoint > 0xDBFF) {
                            // unexpected trail
                            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
                            continue
                        } else if (i + 1 === length) {
                            // unpaired lead
                            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
                            continue
                        }

                        // valid lead
                        leadSurrogate = codePoint

                        continue
                    }

                    // 2 leads in a row
                    if (codePoint < 0xDC00) {
                        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
                        leadSurrogate = codePoint
                        continue
                    }

                    // valid surrogate pair
                    codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
                } else if (leadSurrogate) {
                    // valid bmp char, but last char was a lead
                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
                }

                leadSurrogate = null

                // encode utf8
                if (codePoint < 0x80) {
                    if ((units -= 1) < 0) break
                    bytes.push(codePoint)
                } else if (codePoint < 0x800) {
                    if ((units -= 2) < 0) break
                    bytes.push(
                            codePoint >> 0x6 | 0xC0,
                            codePoint & 0x3F | 0x80
                    )
                } else if (codePoint < 0x10000) {
                    if ((units -= 3) < 0) break
                    bytes.push(
                            codePoint >> 0xC | 0xE0,
                            codePoint >> 0x6 & 0x3F | 0x80,
                            codePoint & 0x3F | 0x80
                    )
                } else if (codePoint < 0x110000) {
                    if ((units -= 4) < 0) break
                    bytes.push(
                            codePoint >> 0x12 | 0xF0,
                            codePoint >> 0xC & 0x3F | 0x80,
                            codePoint >> 0x6 & 0x3F | 0x80,
                            codePoint & 0x3F | 0x80
                    )
                } else {
                    throw new Error('Invalid code point')
                }
            }

            return bytes
        }

        function asciiToBytes (str) {
            var byteArray = []
            for (var i = 0; i < str.length; ++i) {
                // Node's code seems to be doing this and not & 0x7F..
                byteArray.push(str.charCodeAt(i) & 0xFF)
            }
            return byteArray
        }

        function utf16leToBytes (str, units) {
            var c, hi, lo
            var byteArray = []
            for (var i = 0; i < str.length; ++i) {
                if ((units -= 2) < 0) break

                c = str.charCodeAt(i)
                hi = c >> 8
                lo = c % 256
                byteArray.push(lo)
                byteArray.push(hi)
            }

            return byteArray
        }

        function base64ToBytes (str) {
            return base64.toByteArray(base64clean(str))
        }

        function blitBuffer (src, dst, offset, length) {
            for (var i = 0; i < length; ++i) {
                if ((i + offset >= dst.length) || (i >= src.length)) break
                dst[i + offset] = src[i]
            }
            return i
        }

// ArrayBuffers from another context (i.e. an iframe) do not pass the `instanceof` check
// but they should be treated as valid. See: https://github.com/feross/buffer/issues/166
        function isArrayBuffer (obj) {
            return obj instanceof ArrayBuffer ||
                    (obj != null && obj.constructor != null && obj.constructor.name === 'ArrayBuffer' &&
                    typeof obj.byteLength === 'number')
        }

        function numberIsNaN (obj) {
            return obj !== obj // eslint-disable-line no-self-compare
        }

    },{"base64-js":5,"ieee754":29}],9:[function(require,module,exports){
        /**
         * Slice reference.
         */

        var slice = [].slice;

        /**
         * Bind `obj` to `fn`.
         *
         * @param {Object} obj
         * @param {Function|String} fn or string
         * @return {Function}
         * @api public
         */

        module.exports = function(obj, fn){
            if ('string' == typeof fn) fn = obj[fn];
            if ('function' != typeof fn) throw new Error('bind() requires a function');
            var args = slice.call(arguments, 2);
            return function(){
                return fn.apply(obj, args.concat(slice.call(arguments)));
            }
        };

    },{}],10:[function(require,module,exports){

        /**
         * Expose `Emitter`.
         */

        if (typeof module !== 'undefined') {
            module.exports = Emitter;
        }

        /**
         * Initialize a new `Emitter`.
         *
         * @api public
         */

        function Emitter(obj) {
            if (obj) return mixin(obj);
        };

        /**
         * Mixin the emitter properties.
         *
         * @param {Object} obj
         * @return {Object}
         * @api private
         */

        function mixin(obj) {
            for (var key in Emitter.prototype) {
                obj[key] = Emitter.prototype[key];
            }
            return obj;
        }

        /**
         * Listen on the given `event` with `fn`.
         *
         * @param {String} event
         * @param {Function} fn
         * @return {Emitter}
         * @api public
         */

        Emitter.prototype.on =
                Emitter.prototype.addEventListener = function(event, fn){
                    this._callbacks = this._callbacks || {};
                    (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
                            .push(fn);
                    return this;
                };

        /**
         * Adds an `event` listener that will be invoked a single
         * time then automatically removed.
         *
         * @param {String} event
         * @param {Function} fn
         * @return {Emitter}
         * @api public
         */

        Emitter.prototype.once = function(event, fn){
            function on() {
                this.off(event, on);
                fn.apply(this, arguments);
            }

            on.fn = fn;
            this.on(event, on);
            return this;
        };

        /**
         * Remove the given callback for `event` or all
         * registered callbacks.
         *
         * @param {String} event
         * @param {Function} fn
         * @return {Emitter}
         * @api public
         */

        Emitter.prototype.off =
                Emitter.prototype.removeListener =
                        Emitter.prototype.removeAllListeners =
                                Emitter.prototype.removeEventListener = function(event, fn){
                                    this._callbacks = this._callbacks || {};

                                    // all
                                    if (0 == arguments.length) {
                                        this._callbacks = {};
                                        return this;
                                    }

                                    // specific event
                                    var callbacks = this._callbacks['$' + event];
                                    if (!callbacks) return this;

                                    // remove all handlers
                                    if (1 == arguments.length) {
                                        delete this._callbacks['$' + event];
                                        return this;
                                    }

                                    // remove specific handler
                                    var cb;
                                    for (var i = 0; i < callbacks.length; i++) {
                                        cb = callbacks[i];
                                        if (cb === fn || cb.fn === fn) {
                                            callbacks.splice(i, 1);
                                            break;
                                        }
                                    }
                                    return this;
                                };

        /**
         * Emit `event` with the given args.
         *
         * @param {String} event
         * @param {Mixed} ...
         * @return {Emitter}
         */

        Emitter.prototype.emit = function(event){
            this._callbacks = this._callbacks || {};
            var args = [].slice.call(arguments, 1)
                    , callbacks = this._callbacks['$' + event];

            if (callbacks) {
                callbacks = callbacks.slice(0);
                for (var i = 0, len = callbacks.length; i < len; ++i) {
                    callbacks[i].apply(this, args);
                }
            }

            return this;
        };

        /**
         * Return array of callbacks for `event`.
         *
         * @param {String} event
         * @return {Array}
         * @api public
         */

        Emitter.prototype.listeners = function(event){
            this._callbacks = this._callbacks || {};
            return this._callbacks['$' + event] || [];
        };

        /**
         * Check if this emitter has `event` handlers.
         *
         * @param {String} event
         * @return {Boolean}
         * @api public
         */

        Emitter.prototype.hasListeners = function(event){
            return !! this.listeners(event).length;
        };

    },{}],11:[function(require,module,exports){

        module.exports = function(a, b){
            var fn = function(){};
            fn.prototype = b.prototype;
            a.prototype = new fn;
            a.prototype.constructor = a;
        };
    },{}],12:[function(require,module,exports){
        (function (process){
            /**
             * This is the web browser implementation of `debug()`.
             *
             * Expose `debug()` as the module.
             */

            exports = module.exports = require('./debug');
            exports.log = log;
            exports.formatArgs = formatArgs;
            exports.save = save;
            exports.load = load;
            exports.useColors = useColors;
            exports.storage = 'undefined' != typeof chrome
            && 'undefined' != typeof chrome.storage
                    ? chrome.storage.local
                    : localstorage();

            /**
             * Colors.
             */

            exports.colors = [
                '#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC',
                '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF',
                '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC',
                '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF',
                '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC',
                '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033',
                '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366',
                '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933',
                '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC',
                '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF',
                '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'
            ];

            /**
             * Currently only WebKit-based Web Inspectors, Firefox >= v31,
             * and the Firebug extension (any Firefox version) are known
             * to support "%c" CSS customizations.
             *
             * TODO: add a `localStorage` variable to explicitly enable/disable colors
             */

            function useColors() {
                // NB: In an Electron preload script, document will be defined but not fully
                // initialized. Since we know we're in Chrome, we'll just detect this case
                // explicitly
                if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
                    return true;
                }

                // Internet Explorer and Edge do not support colors.
                if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
                    return false;
                }

                // is webkit? http://stackoverflow.com/a/16459606/376773
                // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
                return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
                        // is firebug? http://stackoverflow.com/a/398120/376773
                        (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
                        // is firefox >= v31?
                        // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
                        (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
                        // double check webkit in userAgent just in case we are in a worker
                        (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
            }

            /**
             * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
             */

            exports.formatters.j = function(v) {
                try {
                    return JSON.stringify(v);
                } catch (err) {
                    return '[UnexpectedJSONParseError]: ' + err.message;
                }
            };


            /**
             * Colorize log arguments if enabled.
             *
             * @api public
             */

            function formatArgs(args) {
                var useColors = this.useColors;

                args[0] = (useColors ? '%c' : '')
                        + this.namespace
                        + (useColors ? ' %c' : ' ')
                        + args[0]
                        + (useColors ? '%c ' : ' ')
                        + '+' + exports.humanize(this.diff);

                if (!useColors) return;

                var c = 'color: ' + this.color;
                args.splice(1, 0, c, 'color: inherit')

                // the final "%c" is somewhat tricky, because there could be other
                // arguments passed either before or after the %c, so we need to
                // figure out the correct index to insert the CSS into
                var index = 0;
                var lastC = 0;
                args[0].replace(/%[a-zA-Z%]/g, function(match) {
                    if ('%%' === match) return;
                    index++;
                    if ('%c' === match) {
                        // we only are interested in the *last* %c
                        // (the user may have provided their own)
                        lastC = index;
                    }
                });

                args.splice(lastC, 0, c);
            }

            /**
             * Invokes `console.log()` when available.
             * No-op when `console.log` is not a "function".
             *
             * @api public
             */

            function log() {
                // this hackery is required for IE8/9, where
                // the `console.log` function doesn't have 'apply'
                return 'object' === typeof console
                        && console.log
                        && Function.prototype.apply.call(console.log, console, arguments);
            }

            /**
             * Save `namespaces`.
             *
             * @param {String} namespaces
             * @api private
             */

            function save(namespaces) {
                try {
                    if (null == namespaces) {
                        exports.storage.removeItem('debug');
                    } else {
                        exports.storage.debug = namespaces;
                    }
                } catch(e) {}
            }

            /**
             * Load `namespaces`.
             *
             * @return {String} returns the previously persisted debug modes
             * @api private
             */

            function load() {
                var r;
                try {
                    r = exports.storage.debug;
                } catch(e) {}

                // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
                if (!r && typeof process !== 'undefined' && 'env' in process) {
                    r = process.env.DEBUG;
                }

                return r;
            }

            /**
             * Enable namespaces listed in `localStorage.debug` initially.
             */

            exports.enable(load());

            /**
             * Localstorage attempts to return the localstorage.
             *
             * This is necessary because safari throws
             * when a user disables cookies/localstorage
             * and you attempt to access it.
             *
             * @return {LocalStorage}
             * @api private
             */

            function localstorage() {
                try {
                    return window.localStorage;
                } catch (e) {}
            }

        }).call(this,require('_process'))
    },{"./debug":13,"_process":34}],13:[function(require,module,exports){

        /**
         * This is the common logic for both the Node.js and web browser
         * implementations of `debug()`.
         *
         * Expose `debug()` as the module.
         */

        exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
        exports.coerce = coerce;
        exports.disable = disable;
        exports.enable = enable;
        exports.enabled = enabled;
        exports.humanize = require('ms');

        /**
         * Active `debug` instances.
         */
        exports.instances = [];

        /**
         * The currently active debug mode names, and names to skip.
         */

        exports.names = [];
        exports.skips = [];

        /**
         * Map of special "%n" handling functions, for the debug "format" argument.
         *
         * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
         */

        exports.formatters = {};

        /**
         * Select a color.
         * @param {String} namespace
         * @return {Number}
         * @api private
         */

        function selectColor(namespace) {
            var hash = 0, i;

            for (i in namespace) {
                hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);
                hash |= 0; // Convert to 32bit integer
            }

            return exports.colors[Math.abs(hash) % exports.colors.length];
        }

        /**
         * Create a debugger with the given `namespace`.
         *
         * @param {String} namespace
         * @return {Function}
         * @api public
         */

        function createDebug(namespace) {

            var prevTime;

            function debug() {
                // disabled?
                if (!debug.enabled) return;

                var self = debug;

                // set `diff` timestamp
                var curr = +new Date();
                var ms = curr - (prevTime || curr);
                self.diff = ms;
                self.prev = prevTime;
                self.curr = curr;
                prevTime = curr;

                // turn the `arguments` into a proper Array
                var args = new Array(arguments.length);
                for (var i = 0; i < args.length; i++) {
                    args[i] = arguments[i];
                }

                args[0] = exports.coerce(args[0]);

                if ('string' !== typeof args[0]) {
                    // anything else let's inspect with %O
                    args.unshift('%O');
                }

                // apply any `formatters` transformations
                var index = 0;
                args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
                    // if we encounter an escaped % then don't increase the array index
                    if (match === '%%') return match;
                    index++;
                    var formatter = exports.formatters[format];
                    if ('function' === typeof formatter) {
                        var val = args[index];
                        match = formatter.call(self, val);

                        // now we need to remove `args[index]` since it's inlined in the `format`
                        args.splice(index, 1);
                        index--;
                    }
                    return match;
                });

                // apply env-specific formatting (colors, etc.)
                exports.formatArgs.call(self, args);

                var logFn = debug.log || exports.log || console.log.bind(console);
                logFn.apply(self, args);
            }

            debug.namespace = namespace;
            debug.enabled = exports.enabled(namespace);
            debug.useColors = exports.useColors();
            debug.color = selectColor(namespace);
            debug.destroy = destroy;

            // env-specific initialization logic for debug instances
            if ('function' === typeof exports.init) {
                exports.init(debug);
            }

            exports.instances.push(debug);

            return debug;
        }

        function destroy () {
            var index = exports.instances.indexOf(this);
            if (index !== -1) {
                exports.instances.splice(index, 1);
                return true;
            } else {
                return false;
            }
        }

        /**
         * Enables a debug mode by namespaces. This can include modes
         * separated by a colon and wildcards.
         *
         * @param {String} namespaces
         * @api public
         */

        function enable(namespaces) {
            exports.save(namespaces);

            exports.names = [];
            exports.skips = [];

            var i;
            var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
            var len = split.length;

            for (i = 0; i < len; i++) {
                if (!split[i]) continue; // ignore empty strings
                namespaces = split[i].replace(/\*/g, '.*?');
                if (namespaces[0] === '-') {
                    exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
                } else {
                    exports.names.push(new RegExp('^' + namespaces + '$'));
                }
            }

            for (i = 0; i < exports.instances.length; i++) {
                var instance = exports.instances[i];
                instance.enabled = exports.enabled(instance.namespace);
            }
        }

        /**
         * Disable debug output.
         *
         * @api public
         */

        function disable() {
            exports.enable('');
        }

        /**
         * Returns true if the given mode name is enabled, false otherwise.
         *
         * @param {String} name
         * @return {Boolean}
         * @api public
         */

        function enabled(name) {
            if (name[name.length - 1] === '*') {
                return true;
            }
            var i, len;
            for (i = 0, len = exports.skips.length; i < len; i++) {
                if (exports.skips[i].test(name)) {
                    return false;
                }
            }
            for (i = 0, len = exports.names.length; i < len; i++) {
                if (exports.names[i].test(name)) {
                    return true;
                }
            }
            return false;
        }

        /**
         * Coerce `val`.
         *
         * @param {Mixed} val
         * @return {Mixed}
         * @api private
         */

        function coerce(val) {
            if (val instanceof Error) return val.stack || val.message;
            return val;
        }

    },{"ms":31}],14:[function(require,module,exports){

        module.exports = require('./socket');

        /**
         * Exports parser
         *
         * @api public
         *
         */
        module.exports.parser = require('engine.io-parser');

    },{"./socket":15,"engine.io-parser":23}],15:[function(require,module,exports){
        (function (global){
            /**
             * Module dependencies.
             */

            var transports = require('./transports/index');
            var Emitter = require('component-emitter');
            var debug = require('debug')('engine.io-client:socket');
            var index = require('indexof');
            var parser = require('engine.io-parser');
            var parseuri = require('parseuri');
            var parseqs = require('parseqs');

            /**
             * Module exports.
             */

            module.exports = Socket;

            /**
             * Socket constructor.
             *
             * @param {String|Object} uri or options
             * @param {Object} options
             * @api public
             */

            function Socket (uri, opts) {
                if (!(this instanceof Socket)) return new Socket(uri, opts);

                opts = opts || {};

                if (uri && 'object' === typeof uri) {
                    opts = uri;
                    uri = null;
                }

                if (uri) {
                    uri = parseuri(uri);
                    opts.hostname = uri.host;
                    opts.secure = uri.protocol === 'https' || uri.protocol === 'wss';
                    opts.port = uri.port;
                    if (uri.query) opts.query = uri.query;
                } else if (opts.host) {
                    opts.hostname = parseuri(opts.host).host;
                }

                this.secure = null != opts.secure ? opts.secure
                        : (global.location && 'https:' === location.protocol);

                if (opts.hostname && !opts.port) {
                    // if no port is specified manually, use the protocol default
                    opts.port = this.secure ? '443' : '80';
                }

                this.agent = opts.agent || false;
                this.hostname = opts.hostname ||
                        (global.location ? location.hostname : 'localhost');
                this.port = opts.port || (global.location && location.port
                                ? location.port
                                : (this.secure ? 443 : 80));
                this.query = opts.query || {};
                if ('string' === typeof this.query) this.query = parseqs.decode(this.query);
                this.upgrade = false !== opts.upgrade;
                this.path = (opts.path || '/engine.io').replace(/\/$/, '') + '/';
                this.forceJSONP = !!opts.forceJSONP;
                this.jsonp = false !== opts.jsonp;
                this.forceBase64 = !!opts.forceBase64;
                this.enablesXDR = !!opts.enablesXDR;
                this.timestampParam = opts.timestampParam || 't';
                this.timestampRequests = opts.timestampRequests;
                this.transports = opts.transports || ['polling', 'websocket'];
                this.transportOptions = opts.transportOptions || {};
                this.readyState = '';
                this.writeBuffer = [];
                this.prevBufferLen = 0;
                this.policyPort = opts.policyPort || 843;
                this.rememberUpgrade = opts.rememberUpgrade || false;
                this.binaryType = null;
                this.onlyBinaryUpgrades = opts.onlyBinaryUpgrades;
                this.perMessageDeflate = false !== opts.perMessageDeflate ? (opts.perMessageDeflate || {}) : false;

                if (true === this.perMessageDeflate) this.perMessageDeflate = {};
                if (this.perMessageDeflate && null == this.perMessageDeflate.threshold) {
                    this.perMessageDeflate.threshold = 1024;
                }

                // SSL options for Node.js client
                this.pfx = opts.pfx || null;
                this.key = opts.key || null;
                this.passphrase = opts.passphrase || null;
                this.cert = opts.cert || null;
                this.ca = opts.ca || null;
                this.ciphers = opts.ciphers || null;
                this.rejectUnauthorized = opts.rejectUnauthorized === undefined ? true : opts.rejectUnauthorized;
                this.forceNode = !!opts.forceNode;

                // other options for Node.js client
                var freeGlobal = typeof global === 'object' && global;
                if (freeGlobal.global === freeGlobal) {
                    if (opts.extraHeaders && Object.keys(opts.extraHeaders).length > 0) {
                        this.extraHeaders = opts.extraHeaders;
                    }

                    if (opts.localAddress) {
                        this.localAddress = opts.localAddress;
                    }
                }

                // set on handshake
                this.id = null;
                this.upgrades = null;
                this.pingInterval = null;
                this.pingTimeout = null;

                // set on heartbeat
                this.pingIntervalTimer = null;
                this.pingTimeoutTimer = null;

                this.open();
            }

            Socket.priorWebsocketSuccess = false;

            /**
             * Mix in `Emitter`.
             */

            Emitter(Socket.prototype);

            /**
             * Protocol version.
             *
             * @api public
             */

            Socket.protocol = parser.protocol; // this is an int

            /**
             * Expose deps for legacy compatibility
             * and standalone browser access.
             */

            Socket.Socket = Socket;
            Socket.Transport = require('./transport');
            Socket.transports = require('./transports/index');
            Socket.parser = require('engine.io-parser');

            /**
             * Creates transport of the given type.
             *
             * @param {String} transport name
             * @return {Transport}
             * @api private
             */

            Socket.prototype.createTransport = function (name) {
                debug('creating transport "%s"', name);
                var query = clone(this.query);

                // append engine.io protocol identifier
                query.EIO = parser.protocol;

                // transport name
                query.transport = name;

                // per-transport options
                var options = this.transportOptions[name] || {};

                // session id if we already have one
                if (this.id) query.sid = this.id;

                var transport = new transports[name]({
                    query: query,
                    socket: this,
                    agent: options.agent || this.agent,
                    hostname: options.hostname || this.hostname,
                    port: options.port || this.port,
                    secure: options.secure || this.secure,
                    path: options.path || this.path,
                    forceJSONP: options.forceJSONP || this.forceJSONP,
                    jsonp: options.jsonp || this.jsonp,
                    forceBase64: options.forceBase64 || this.forceBase64,
                    enablesXDR: options.enablesXDR || this.enablesXDR,
                    timestampRequests: options.timestampRequests || this.timestampRequests,
                    timestampParam: options.timestampParam || this.timestampParam,
                    policyPort: options.policyPort || this.policyPort,
                    pfx: options.pfx || this.pfx,
                    key: options.key || this.key,
                    passphrase: options.passphrase || this.passphrase,
                    cert: options.cert || this.cert,
                    ca: options.ca || this.ca,
                    ciphers: options.ciphers || this.ciphers,
                    rejectUnauthorized: options.rejectUnauthorized || this.rejectUnauthorized,
                    perMessageDeflate: options.perMessageDeflate || this.perMessageDeflate,
                    extraHeaders: options.extraHeaders || this.extraHeaders,
                    forceNode: options.forceNode || this.forceNode,
                    localAddress: options.localAddress || this.localAddress,
                    requestTimeout: options.requestTimeout || this.requestTimeout,
                    protocols: options.protocols || void (0)
                });

                return transport;
            };

            function clone (obj) {
                var o = {};
                for (var i in obj) {
                    if (obj.hasOwnProperty(i)) {
                        o[i] = obj[i];
                    }
                }
                return o;
            }

            /**
             * Initializes transport to use and starts probe.
             *
             * @api private
             */
            Socket.prototype.open = function () {
                var transport;
                if (this.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf('websocket') !== -1) {
                    transport = 'websocket';
                } else if (0 === this.transports.length) {
                    // Emit error on next tick so it can be listened to
                    var self = this;
                    setTimeout(function () {
                        self.emit('error', 'No transports available');
                    }, 0);
                    return;
                } else {
                    transport = this.transports[0];
                }
                this.readyState = 'opening';

                // Retry with the next transport if the transport is disabled (jsonp: false)
                try {
                    transport = this.createTransport(transport);
                } catch (e) {
                    this.transports.shift();
                    this.open();
                    return;
                }

                transport.open();
                this.setTransport(transport);
            };

            /**
             * Sets the current transport. Disables the existing one (if any).
             *
             * @api private
             */

            Socket.prototype.setTransport = function (transport) {
                debug('setting transport %s', transport.name);
                var self = this;

                if (this.transport) {
                    debug('clearing existing transport %s', this.transport.name);
                    this.transport.removeAllListeners();
                }

                // set up transport
                this.transport = transport;

                // set up transport listeners
                transport
                        .on('drain', function () {
                            self.onDrain();
                        })
                        .on('packet', function (packet) {
                            self.onPacket(packet);
                        })
                        .on('error', function (e) {
                            self.onError(e);
                        })
                        .on('close', function () {
                            self.onClose('transport close');
                        });
            };

            /**
             * Probes a transport.
             *
             * @param {String} transport name
             * @api private
             */

            Socket.prototype.probe = function (name) {
                debug('probing transport "%s"', name);
                var transport = this.createTransport(name, { probe: 1 });
                var failed = false;
                var self = this;

                Socket.priorWebsocketSuccess = false;

                function onTransportOpen () {
                    if (self.onlyBinaryUpgrades) {
                        var upgradeLosesBinary = !this.supportsBinary && self.transport.supportsBinary;
                        failed = failed || upgradeLosesBinary;
                    }
                    if (failed) return;

                    debug('probe transport "%s" opened', name);
                    transport.send([{ type: 'ping', data: 'probe' }]);
                    transport.once('packet', function (msg) {
                        if (failed) return;
                        if ('pong' === msg.type && 'probe' === msg.data) {
                            debug('probe transport "%s" pong', name);
                            self.upgrading = true;
                            self.emit('upgrading', transport);
                            if (!transport) return;
                            Socket.priorWebsocketSuccess = 'websocket' === transport.name;

                            debug('pausing current transport "%s"', self.transport.name);
                            self.transport.pause(function () {
                                if (failed) return;
                                if ('closed' === self.readyState) return;
                                debug('changing transport and sending upgrade packet');

                                cleanup();

                                self.setTransport(transport);
                                transport.send([{ type: 'upgrade' }]);
                                self.emit('upgrade', transport);
                                transport = null;
                                self.upgrading = false;
                                self.flush();
                            });
                        } else {
                            debug('probe transport "%s" failed', name);
                            var err = new Error('probe error');
                            err.transport = transport.name;
                            self.emit('upgradeError', err);
                        }
                    });
                }

                function freezeTransport () {
                    if (failed) return;

                    // Any callback called by transport should be ignored since now
                    failed = true;

                    cleanup();

                    transport.close();
                    transport = null;
                }

                // Handle any error that happens while probing
                function onerror (err) {
                    var error = new Error('probe error: ' + err);
                    error.transport = transport.name;

                    freezeTransport();

                    debug('probe transport "%s" failed because of error: %s', name, err);

                    self.emit('upgradeError', error);
                }

                function onTransportClose () {
                    onerror('transport closed');
                }

                // When the socket is closed while we're probing
                function onclose () {
                    onerror('socket closed');
                }

                // When the socket is upgraded while we're probing
                function onupgrade (to) {
                    if (transport && to.name !== transport.name) {
                        debug('"%s" works - aborting "%s"', to.name, transport.name);
                        freezeTransport();
                    }
                }

                // Remove all listeners on the transport and on self
                function cleanup () {
                    transport.removeListener('open', onTransportOpen);
                    transport.removeListener('error', onerror);
                    transport.removeListener('close', onTransportClose);
                    self.removeListener('close', onclose);
                    self.removeListener('upgrading', onupgrade);
                }

                transport.once('open', onTransportOpen);
                transport.once('error', onerror);
                transport.once('close', onTransportClose);

                this.once('close', onclose);
                this.once('upgrading', onupgrade);

                transport.open();
            };

            /**
             * Called when connection is deemed open.
             *
             * @api public
             */

            Socket.prototype.onOpen = function () {
                debug('socket open');
                this.readyState = 'open';
                Socket.priorWebsocketSuccess = 'websocket' === this.transport.name;
                this.emit('open');
                this.flush();

                // we check for `readyState` in case an `open`
                // listener already closed the socket
                if ('open' === this.readyState && this.upgrade && this.transport.pause) {
                    debug('starting upgrade probes');
                    for (var i = 0, l = this.upgrades.length; i < l; i++) {
                        this.probe(this.upgrades[i]);
                    }
                }
            };

            /**
             * Handles a packet.
             *
             * @api private
             */

            Socket.prototype.onPacket = function (packet) {
                if ('opening' === this.readyState || 'open' === this.readyState ||
                        'closing' === this.readyState) {
                    debug('socket receive: type "%s", data "%s"', packet.type, packet.data);

                    this.emit('packet', packet);

                    // Socket is live - any packet counts
                    this.emit('heartbeat');

                    switch (packet.type) {
                        case 'open':
                            this.onHandshake(JSON.parse(packet.data));
                            break;

                        case 'pong':
                            this.setPing();
                            this.emit('pong');
                            break;

                        case 'error':
                            var err = new Error('server error');
                            err.code = packet.data;
                            this.onError(err);
                            break;

                        case 'message':
                            this.emit('data', packet.data);
                            this.emit('message', packet.data);
                            break;
                    }
                } else {
                    debug('packet received with socket readyState "%s"', this.readyState);
                }
            };

            /**
             * Called upon handshake completion.
             *
             * @param {Object} handshake obj
             * @api private
             */

            Socket.prototype.onHandshake = function (data) {
                this.emit('handshake', data);
                this.id = data.sid;
                this.transport.query.sid = data.sid;
                this.upgrades = this.filterUpgrades(data.upgrades);
                this.pingInterval = data.pingInterval;
                this.pingTimeout = data.pingTimeout;
                this.onOpen();
                // In case open handler closes socket
                if ('closed' === this.readyState) return;
                this.setPing();

                // Prolong liveness of socket on heartbeat
                this.removeListener('heartbeat', this.onHeartbeat);
                this.on('heartbeat', this.onHeartbeat);
            };

            /**
             * Resets ping timeout.
             *
             * @api private
             */

            Socket.prototype.onHeartbeat = function (timeout) {
                clearTimeout(this.pingTimeoutTimer);
                var self = this;
                self.pingTimeoutTimer = setTimeout(function () {
                    if ('closed' === self.readyState) return;
                    self.onClose('ping timeout');
                }, timeout || (self.pingInterval + self.pingTimeout));
            };

            /**
             * Pings server every `this.pingInterval` and expects response
             * within `this.pingTimeout` or closes connection.
             *
             * @api private
             */

            Socket.prototype.setPing = function () {
                var self = this;
                clearTimeout(self.pingIntervalTimer);
                self.pingIntervalTimer = setTimeout(function () {
                    debug('writing ping packet - expecting pong within %sms', self.pingTimeout);
                    self.ping();
                    self.onHeartbeat(self.pingTimeout);
                }, self.pingInterval);
            };

            /**
             * Sends a ping packet.
             *
             * @api private
             */

            Socket.prototype.ping = function () {
                var self = this;
                this.sendPacket('ping', function () {
                    self.emit('ping');
                });
            };

            /**
             * Called on `drain` event
             *
             * @api private
             */

            Socket.prototype.onDrain = function () {
                this.writeBuffer.splice(0, this.prevBufferLen);

                // setting prevBufferLen = 0 is very important
                // for example, when upgrading, upgrade packet is sent over,
                // and a nonzero prevBufferLen could cause problems on `drain`
                this.prevBufferLen = 0;

                if (0 === this.writeBuffer.length) {
                    this.emit('drain');
                } else {
                    this.flush();
                }
            };

            /**
             * Flush write buffers.
             *
             * @api private
             */

            Socket.prototype.flush = function () {
                if ('closed' !== this.readyState && this.transport.writable &&
                        !this.upgrading && this.writeBuffer.length) {
                    debug('flushing %d packets in socket', this.writeBuffer.length);
                    this.transport.send(this.writeBuffer);
                    // keep track of current length of writeBuffer
                    // splice writeBuffer and callbackBuffer on `drain`
                    this.prevBufferLen = this.writeBuffer.length;
                    this.emit('flush');
                }
            };

            /**
             * Sends a message.
             *
             * @param {String} message.
             * @param {Function} callback function.
             * @param {Object} options.
             * @return {Socket} for chaining.
             * @api public
             */

            Socket.prototype.write =
                    Socket.prototype.send = function (msg, options, fn) {
                        this.sendPacket('message', msg, options, fn);
                        return this;
                    };

            /**
             * Sends a packet.
             *
             * @param {String} packet type.
             * @param {String} data.
             * @param {Object} options.
             * @param {Function} callback function.
             * @api private
             */

            Socket.prototype.sendPacket = function (type, data, options, fn) {
                if ('function' === typeof data) {
                    fn = data;
                    data = undefined;
                }

                if ('function' === typeof options) {
                    fn = options;
                    options = null;
                }

                if ('closing' === this.readyState || 'closed' === this.readyState) {
                    return;
                }

                options = options || {};
                options.compress = false !== options.compress;

                var packet = {
                    type: type,
                    data: data,
                    options: options
                };
                this.emit('packetCreate', packet);
                this.writeBuffer.push(packet);
                if (fn) this.once('flush', fn);
                this.flush();
            };

            /**
             * Closes the connection.
             *
             * @api private
             */

            Socket.prototype.close = function () {
                if ('opening' === this.readyState || 'open' === this.readyState) {
                    this.readyState = 'closing';

                    var self = this;

                    if (this.writeBuffer.length) {
                        this.once('drain', function () {
                            if (this.upgrading) {
                                waitForUpgrade();
                            } else {
                                close();
                            }
                        });
                    } else if (this.upgrading) {
                        waitForUpgrade();
                    } else {
                        close();
                    }
                }

                function close () {
                    self.onClose('forced close');
                    debug('socket closing - telling transport to close');
                    self.transport.close();
                }

                function cleanupAndClose () {
                    self.removeListener('upgrade', cleanupAndClose);
                    self.removeListener('upgradeError', cleanupAndClose);
                    close();
                }

                function waitForUpgrade () {
                    // wait for upgrade to finish since we can't send packets while pausing a transport
                    self.once('upgrade', cleanupAndClose);
                    self.once('upgradeError', cleanupAndClose);
                }

                return this;
            };

            /**
             * Called upon transport error
             *
             * @api private
             */

            Socket.prototype.onError = function (err) {
                debug('socket error %j', err);
                Socket.priorWebsocketSuccess = false;
                this.emit('error', err);
                this.onClose('transport error', err);
            };

            /**
             * Called upon transport close.
             *
             * @api private
             */

            Socket.prototype.onClose = function (reason, desc) {
                if ('opening' === this.readyState || 'open' === this.readyState || 'closing' === this.readyState) {
                    debug('socket close with reason: "%s"', reason);
                    var self = this;

                    // clear timers
                    clearTimeout(this.pingIntervalTimer);
                    clearTimeout(this.pingTimeoutTimer);

                    // stop event from firing again for transport
                    this.transport.removeAllListeners('close');

                    // ensure transport won't stay open
                    this.transport.close();

                    // ignore further transport communication
                    this.transport.removeAllListeners();

                    // set ready state
                    this.readyState = 'closed';

                    // clear session id
                    this.id = null;

                    // emit close event
                    this.emit('close', reason, desc);

                    // clean buffers after, so users can still
                    // grab the buffers on `close` event
                    self.writeBuffer = [];
                    self.prevBufferLen = 0;
                }
            };

            /**
             * Filters upgrades, returning only those matching client transports.
             *
             * @param {Array} server upgrades
             * @api private
             *
             */

            Socket.prototype.filterUpgrades = function (upgrades) {
                var filteredUpgrades = [];
                for (var i = 0, j = upgrades.length; i < j; i++) {
                    if (~index(this.transports, upgrades[i])) filteredUpgrades.push(upgrades[i]);
                }
                return filteredUpgrades;
            };

        }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
    },{"./transport":16,"./transports/index":17,"component-emitter":10,"debug":12,"engine.io-parser":23,"indexof":30,"parseqs":32,"parseuri":33}],16:[function(require,module,exports){
        /**
         * Module dependencies.
         */

        var parser = require('engine.io-parser');
        var Emitter = require('component-emitter');

        /**
         * Module exports.
         */

        module.exports = Transport;

        /**
         * Transport abstract constructor.
         *
         * @param {Object} options.
         * @api private
         */

        function Transport (opts) {
            this.path = opts.path;
            this.hostname = opts.hostname;
            this.port = opts.port;
            this.secure = opts.secure;
            this.query = opts.query;
            this.timestampParam = opts.timestampParam;
            this.timestampRequests = opts.timestampRequests;
            this.readyState = '';
            this.agent = opts.agent || false;
            this.socket = opts.socket;
            this.enablesXDR = opts.enablesXDR;

            // SSL options for Node.js client
            this.pfx = opts.pfx;
            this.key = opts.key;
            this.passphrase = opts.passphrase;
            this.cert = opts.cert;
            this.ca = opts.ca;
            this.ciphers = opts.ciphers;
            this.rejectUnauthorized = opts.rejectUnauthorized;
            this.forceNode = opts.forceNode;

            // other options for Node.js client
            this.extraHeaders = opts.extraHeaders;
            this.localAddress = opts.localAddress;
        }

        /**
         * Mix in `Emitter`.
         */

        Emitter(Transport.prototype);

        /**
         * Emits an error.
         *
         * @param {String} str
         * @return {Transport} for chaining
         * @api public
         */

        Transport.prototype.onError = function (msg, desc) {
            var err = new Error(msg);
            err.type = 'TransportError';
            err.description = desc;
            this.emit('error', err);
            return this;
        };

        /**
         * Opens the transport.
         *
         * @api public
         */

        Transport.prototype.open = function () {
            if ('closed' === this.readyState || '' === this.readyState) {
                this.readyState = 'opening';
                this.doOpen();
            }

            return this;
        };

        /**
         * Closes the transport.
         *
         * @api private
         */

        Transport.prototype.close = function () {
            if ('opening' === this.readyState || 'open' === this.readyState) {
                this.doClose();
                this.onClose();
            }

            return this;
        };

        /**
         * Sends multiple packets.
         *
         * @param {Array} packets
         * @api private
         */

        Transport.prototype.send = function (packets) {
            if ('open' === this.readyState) {
                this.write(packets);
            } else {
                throw new Error('Transport not open');
            }
        };

        /**
         * Called upon open
         *
         * @api private
         */

        Transport.prototype.onOpen = function () {
            this.readyState = 'open';
            this.writable = true;
            this.emit('open');
        };

        /**
         * Called with data.
         *
         * @param {String} data
         * @api private
         */

        Transport.prototype.onData = function (data) {
            var packet = parser.decodePacket(data, this.socket.binaryType);
            this.onPacket(packet);
        };

        /**
         * Called with a decoded packet.
         */

        Transport.prototype.onPacket = function (packet) {
            this.emit('packet', packet);
        };

        /**
         * Called upon close.
         *
         * @api private
         */

        Transport.prototype.onClose = function () {
            this.readyState = 'closed';
            this.emit('close');
        };

    },{"component-emitter":10,"engine.io-parser":23}],17:[function(require,module,exports){
        (function (global){
            /**
             * Module dependencies
             */

            var XMLHttpRequest = require('xmlhttprequest-ssl');
            var XHR = require('./polling-xhr');
            var JSONP = require('./polling-jsonp');
            var websocket = require('./websocket');

            /**
             * Export transports.
             */

            exports.polling = polling;
            exports.websocket = websocket;

            /**
             * Polling transport polymorphic constructor.
             * Decides on xhr vs jsonp based on feature detection.
             *
             * @api private
             */

            function polling (opts) {
                var xhr;
                var xd = false;
                var xs = false;
                var jsonp = false !== opts.jsonp;

                if (global.location) {
                    var isSSL = 'https:' === location.protocol;
                    var port = location.port;

                    // some user agents have empty `location.port`
                    if (!port) {
                        port = isSSL ? 443 : 80;
                    }

                    xd = opts.hostname !== location.hostname || port !== opts.port;
                    xs = opts.secure !== isSSL;
                }

                opts.xdomain = xd;
                opts.xscheme = xs;
                xhr = new XMLHttpRequest(opts);

                if ('open' in xhr && !opts.forceJSONP) {
                    return new XHR(opts);
                } else {
                    if (!jsonp) throw new Error('JSONP disabled');
                    return new JSONP(opts);
                }
            }

        }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
    },{"./polling-jsonp":18,"./polling-xhr":19,"./websocket":21,"xmlhttprequest-ssl":22}],18:[function(require,module,exports){
        (function (global){

            /**
             * Module requirements.
             */

            var Polling = require('./polling');
            var inherit = require('component-inherit');

            /**
             * Module exports.
             */

            module.exports = JSONPPolling;

            /**
             * Cached regular expressions.
             */

            var rNewline = /\n/g;
            var rEscapedNewline = /\\n/g;

            /**
             * Global JSONP callbacks.
             */

            var callbacks;

            /**
             * Noop.
             */

            function empty () { }

            /**
             * JSONP Polling constructor.
             *
             * @param {Object} opts.
             * @api public
             */

            function JSONPPolling (opts) {
                Polling.call(this, opts);

                this.query = this.query || {};

                // define global callbacks array if not present
                // we do this here (lazily) to avoid unneeded global pollution
                if (!callbacks) {
                    // we need to consider multiple engines in the same page
                    if (!global.___eio) global.___eio = [];
                    callbacks = global.___eio;
                }

                // callback identifier
                this.index = callbacks.length;

                // add callback to jsonp global
                var self = this;
                callbacks.push(function (msg) {
                    self.onData(msg);
                });

                // append to query string
                this.query.j = this.index;

                // prevent spurious errors from being emitted when the window is unloaded
                if (global.document && global.addEventListener) {
                    global.addEventListener('beforeunload', function () {
                        if (self.script) self.script.onerror = empty;
                    }, false);
                }
            }

            /**
             * Inherits from Polling.
             */

            inherit(JSONPPolling, Polling);

            /*
 * JSONP only supports binary as base64 encoded strings
 */

            JSONPPolling.prototype.supportsBinary = false;

            /**
             * Closes the socket.
             *
             * @api private
             */

            JSONPPolling.prototype.doClose = function () {
                if (this.script) {
                    this.script.parentNode.removeChild(this.script);
                    this.script = null;
                }

                if (this.form) {
                    this.form.parentNode.removeChild(this.form);
                    this.form = null;
                    this.iframe = null;
                }

                Polling.prototype.doClose.call(this);
            };

            /**
             * Starts a poll cycle.
             *
             * @api private
             */

            JSONPPolling.prototype.doPoll = function () {
                var self = this;
                var script = document.createElement('script');

                if (this.script) {
                    this.script.parentNode.removeChild(this.script);
                    this.script = null;
                }

                script.async = true;
                script.src = this.uri();
                script.onerror = function (e) {
                    self.onError('jsonp poll error', e);
                };

                var insertAt = document.getElementsByTagName('script')[0];
                if (insertAt) {
                    insertAt.parentNode.insertBefore(script, insertAt);
                } else {
                    (document.head || document.body).appendChild(script);
                }
                this.script = script;

                var isUAgecko = 'undefined' !== typeof navigator && /gecko/i.test(navigator.userAgent);

                if (isUAgecko) {
                    setTimeout(function () {
                        var iframe = document.createElement('iframe');
                        document.body.appendChild(iframe);
                        document.body.removeChild(iframe);
                    }, 100);
                }
            };

            /**
             * Writes with a hidden iframe.
             *
             * @param {String} data to send
             * @param {Function} called upon flush.
             * @api private
             */

            JSONPPolling.prototype.doWrite = function (data, fn) {
                var self = this;

                if (!this.form) {
                    var form = document.createElement('form');
                    var area = document.createElement('textarea');
                    var id = this.iframeId = 'eio_iframe_' + this.index;
                    var iframe;

                    form.className = 'socketio';
                    form.style.position = 'absolute';
                    form.style.top = '-1000px';
                    form.style.left = '-1000px';
                    form.target = id;
                    form.method = 'POST';
                    form.setAttribute('accept-charset', 'utf-8');
                    area.name = 'd';
                    form.appendChild(area);
                    document.body.appendChild(form);

                    this.form = form;
                    this.area = area;
                }

                this.form.action = this.uri();

                function complete () {
                    initIframe();
                    fn();
                }

                function initIframe () {
                    if (self.iframe) {
                        try {
                            self.form.removeChild(self.iframe);
                        } catch (e) {
                            self.onError('jsonp polling iframe removal error', e);
                        }
                    }

                    try {
                        // ie6 dynamic iframes with target="" support (thanks Chris Lambacher)
                        var html = '<iframe src="javascript:0" name="' + self.iframeId + '">';
                        iframe = document.createElement(html);
                    } catch (e) {
                        iframe = document.createElement('iframe');
                        iframe.name = self.iframeId;
                        iframe.src = 'javascript:0';
                    }

                    iframe.id = self.iframeId;

                    self.form.appendChild(iframe);
                    self.iframe = iframe;
                }

                initIframe();

                // escape \n to prevent it from being converted into \r\n by some UAs
                // double escaping is required for escaped new lines because unescaping of new lines can be done safely on server-side
                data = data.replace(rEscapedNewline, '\\\n');
                this.area.value = data.replace(rNewline, '\\n');

                try {
                    this.form.submit();
                } catch (e) {}

                if (this.iframe.attachEvent) {
                    this.iframe.onreadystatechange = function () {
                        if (self.iframe.readyState === 'complete') {
                            complete();
                        }
                    };
                } else {
                    this.iframe.onload = complete;
                }
            };

        }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
    },{"./polling":20,"component-inherit":11}],19:[function(require,module,exports){
        (function (global){
            /**
             * Module requirements.
             */

            var XMLHttpRequest = require('xmlhttprequest-ssl');
            var Polling = require('./polling');
            var Emitter = require('component-emitter');
            var inherit = require('component-inherit');
            var debug = require('debug')('engine.io-client:polling-xhr');

            /**
             * Module exports.
             */

            module.exports = XHR;
            module.exports.Request = Request;

            /**
             * Empty function
             */

            function empty () {}

            /**
             * XHR Polling constructor.
             *
             * @param {Object} opts
             * @api public
             */

            function XHR (opts) {
                Polling.call(this, opts);
                this.requestTimeout = opts.requestTimeout;
                this.extraHeaders = opts.extraHeaders;

                if (global.location) {
                    var isSSL = 'https:' === location.protocol;
                    var port = location.port;

                    // some user agents have empty `location.port`
                    if (!port) {
                        port = isSSL ? 443 : 80;
                    }

                    this.xd = opts.hostname !== global.location.hostname ||
                            port !== opts.port;
                    this.xs = opts.secure !== isSSL;
                }
            }

            /**
             * Inherits from Polling.
             */

            inherit(XHR, Polling);

            /**
             * XHR supports binary
             */

            XHR.prototype.supportsBinary = true;

            /**
             * Creates a request.
             *
             * @param {String} method
             * @api private
             */

            XHR.prototype.request = function (opts) {
                opts = opts || {};
                opts.uri = this.uri();
                opts.xd = this.xd;
                opts.xs = this.xs;
                opts.agent = this.agent || false;
                opts.supportsBinary = this.supportsBinary;
                opts.enablesXDR = this.enablesXDR;

                // SSL options for Node.js client
                opts.pfx = this.pfx;
                opts.key = this.key;
                opts.passphrase = this.passphrase;
                opts.cert = this.cert;
                opts.ca = this.ca;
                opts.ciphers = this.ciphers;
                opts.rejectUnauthorized = this.rejectUnauthorized;
                opts.requestTimeout = this.requestTimeout;

                // other options for Node.js client
                opts.extraHeaders = this.extraHeaders;

                return new Request(opts);
            };

            /**
             * Sends data.
             *
             * @param {String} data to send.
             * @param {Function} called upon flush.
             * @api private
             */

            XHR.prototype.doWrite = function (data, fn) {
                var isBinary = typeof data !== 'string' && data !== undefined;
                var req = this.request({ method: 'POST', data: data, isBinary: isBinary });
                var self = this;
                req.on('success', fn);
                req.on('error', function (err) {
                    self.onError('xhr post error', err);
                });
                this.sendXhr = req;
            };

            /**
             * Starts a poll cycle.
             *
             * @api private
             */

            XHR.prototype.doPoll = function () {
                debug('xhr poll');
                var req = this.request();
                var self = this;
                req.on('data', function (data) {
                    self.onData(data);
                });
                req.on('error', function (err) {
                    self.onError('xhr poll error', err);
                });
                this.pollXhr = req;
            };

            /**
             * Request constructor
             *
             * @param {Object} options
             * @api public
             */

            function Request (opts) {
                this.method = opts.method || 'GET';
                this.uri = opts.uri;
                this.xd = !!opts.xd;
                this.xs = !!opts.xs;
                this.async = false !== opts.async;
                this.data = undefined !== opts.data ? opts.data : null;
                this.agent = opts.agent;
                this.isBinary = opts.isBinary;
                this.supportsBinary = opts.supportsBinary;
                this.enablesXDR = opts.enablesXDR;
                this.requestTimeout = opts.requestTimeout;

                // SSL options for Node.js client
                this.pfx = opts.pfx;
                this.key = opts.key;
                this.passphrase = opts.passphrase;
                this.cert = opts.cert;
                this.ca = opts.ca;
                this.ciphers = opts.ciphers;
                this.rejectUnauthorized = opts.rejectUnauthorized;

                // other options for Node.js client
                this.extraHeaders = opts.extraHeaders;

                this.create();
            }

            /**
             * Mix in `Emitter`.
             */

            Emitter(Request.prototype);

            /**
             * Creates the XHR object and sends the request.
             *
             * @api private
             */

            Request.prototype.create = function () {
                var opts = { agent: this.agent, xdomain: this.xd, xscheme: this.xs, enablesXDR: this.enablesXDR };

                // SSL options for Node.js client
                opts.pfx = this.pfx;
                opts.key = this.key;
                opts.passphrase = this.passphrase;
                opts.cert = this.cert;
                opts.ca = this.ca;
                opts.ciphers = this.ciphers;
                opts.rejectUnauthorized = this.rejectUnauthorized;

                var xhr = this.xhr = new XMLHttpRequest(opts);
                var self = this;

                try {
                    debug('xhr open %s: %s', this.method, this.uri);
                    xhr.open(this.method, this.uri, this.async);
                    try {
                        if (this.extraHeaders) {
                            xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);
                            for (var i in this.extraHeaders) {
                                if (this.extraHeaders.hasOwnProperty(i)) {
                                    xhr.setRequestHeader(i, this.extraHeaders[i]);
                                }
                            }
                        }
                    } catch (e) {}

                    if ('POST' === this.method) {
                        try {
                            if (this.isBinary) {
                                xhr.setRequestHeader('Content-type', 'application/octet-stream');
                            } else {
                                xhr.setRequestHeader('Content-type', 'text/plain;charset=UTF-8');
                            }
                        } catch (e) {}
                    }

                    try {
                        xhr.setRequestHeader('Accept', '*/*');
                    } catch (e) {}

                    // ie6 check
                    if ('withCredentials' in xhr) {
                        xhr.withCredentials = true;
                    }

                    if (this.requestTimeout) {
                        xhr.timeout = this.requestTimeout;
                    }

                    if (this.hasXDR()) {
                        xhr.onload = function () {
                            self.onLoad();
                        };
                        xhr.onerror = function () {
                            self.onError(xhr.responseText);
                        };
                    } else {
                        xhr.onreadystatechange = function () {
                            if (xhr.readyState === 2) {
                                try {
                                    var contentType = xhr.getResponseHeader('Content-Type');
                                    if (self.supportsBinary && contentType === 'application/octet-stream') {
                                        xhr.responseType = 'arraybuffer';
                                    }
                                } catch (e) {}
                            }
                            if (4 !== xhr.readyState) return;
                            if (200 === xhr.status || 1223 === xhr.status) {
                                self.onLoad();
                            } else {
                                // make sure the `error` event handler that's user-set
                                // does not throw in the same tick and gets caught here
                                setTimeout(function () {
                                    self.onError(xhr.status);
                                }, 0);
                            }
                        };
                    }

                    debug('xhr data %s', this.data);
                    xhr.send(this.data);
                } catch (e) {
                    // Need to defer since .create() is called directly fhrom the constructor
                    // and thus the 'error' event can only be only bound *after* this exception
                    // occurs.  Therefore, also, we cannot throw here at all.
                    setTimeout(function () {
                        self.onError(e);
                    }, 0);
                    return;
                }

                if (global.document) {
                    this.index = Request.requestsCount++;
                    Request.requests[this.index] = this;
                }
            };

            /**
             * Called upon successful response.
             *
             * @api private
             */

            Request.prototype.onSuccess = function () {
                this.emit('success');
                this.cleanup();
            };

            /**
             * Called if we have data.
             *
             * @api private
             */

            Request.prototype.onData = function (data) {
                this.emit('data', data);
                this.onSuccess();
            };

            /**
             * Called upon error.
             *
             * @api private
             */

            Request.prototype.onError = function (err) {
                this.emit('error', err);
                this.cleanup(true);
            };

            /**
             * Cleans up house.
             *
             * @api private
             */

            Request.prototype.cleanup = function (fromError) {
                if ('undefined' === typeof this.xhr || null === this.xhr) {
                    return;
                }
                // xmlhttprequest
                if (this.hasXDR()) {
                    this.xhr.onload = this.xhr.onerror = empty;
                } else {
                    this.xhr.onreadystatechange = empty;
                }

                if (fromError) {
                    try {
                        this.xhr.abort();
                    } catch (e) {}
                }

                if (global.document) {
                    delete Request.requests[this.index];
                }

                this.xhr = null;
            };

            /**
             * Called upon load.
             *
             * @api private
             */

            Request.prototype.onLoad = function () {
                var data;
                try {
                    var contentType;
                    try {
                        contentType = this.xhr.getResponseHeader('Content-Type');
                    } catch (e) {}
                    if (contentType === 'application/octet-stream') {
                        data = this.xhr.response || this.xhr.responseText;
                    } else {
                        data = this.xhr.responseText;
                    }
                } catch (e) {
                    this.onError(e);
                }
                if (null != data) {
                    this.onData(data);
                }
            };

            /**
             * Check if it has XDomainRequest.
             *
             * @api private
             */

            Request.prototype.hasXDR = function () {
                return 'undefined' !== typeof global.XDomainRequest && !this.xs && this.enablesXDR;
            };

            /**
             * Aborts the request.
             *
             * @api public
             */

            Request.prototype.abort = function () {
                this.cleanup();
            };

            /**
             * Aborts pending requests when unloading the window. This is needed to prevent
             * memory leaks (e.g. when using IE) and to ensure that no spurious error is
             * emitted.
             */

            Request.requestsCount = 0;
            Request.requests = {};

            if (global.document) {
                if (global.attachEvent) {
                    global.attachEvent('onunload', unloadHandler);
                } else if (global.addEventListener) {
                    global.addEventListener('beforeunload', unloadHandler, false);
                }
            }

            function unloadHandler () {
                for (var i in Request.requests) {
                    if (Request.requests.hasOwnProperty(i)) {
                        Request.requests[i].abort();
                    }
                }
            }

        }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
    },{"./polling":20,"component-emitter":10,"component-inherit":11,"debug":12,"xmlhttprequest-ssl":22}],20:[function(require,module,exports){
        /**
         * Module dependencies.
         */

        var Transport = require('../transport');
        var parseqs = require('parseqs');
        var parser = require('engine.io-parser');
        var inherit = require('component-inherit');
        var yeast = require('yeast');
        var debug = require('debug')('engine.io-client:polling');

        /**
         * Module exports.
         */

        module.exports = Polling;

        /**
         * Is XHR2 supported?
         */

        var hasXHR2 = (function () {
            var XMLHttpRequest = require('xmlhttprequest-ssl');
            var xhr = new XMLHttpRequest({ xdomain: false });
            return null != xhr.responseType;
        })();

        /**
         * Polling interface.
         *
         * @param {Object} opts
         * @api private
         */

        function Polling (opts) {
            var forceBase64 = (opts && opts.forceBase64);
            if (!hasXHR2 || forceBase64) {
                this.supportsBinary = false;
            }
            Transport.call(this, opts);
        }

        /**
         * Inherits from Transport.
         */

        inherit(Polling, Transport);

        /**
         * Transport name.
         */

        Polling.prototype.name = 'polling';

        /**
         * Opens the socket (triggers polling). We write a PING message to determine
         * when the transport is open.
         *
         * @api private
         */

        Polling.prototype.doOpen = function () {
            this.poll();
        };

        /**
         * Pauses polling.
         *
         * @param {Function} callback upon buffers are flushed and transport is paused
         * @api private
         */

        Polling.prototype.pause = function (onPause) {
            var self = this;

            this.readyState = 'pausing';

            function pause () {
                debug('paused');
                self.readyState = 'paused';
                onPause();
            }

            if (this.polling || !this.writable) {
                var total = 0;

                if (this.polling) {
                    debug('we are currently polling - waiting to pause');
                    total++;
                    this.once('pollComplete', function () {
                        debug('pre-pause polling complete');
                        --total || pause();
                    });
                }

                if (!this.writable) {
                    debug('we are currently writing - waiting to pause');
                    total++;
                    this.once('drain', function () {
                        debug('pre-pause writing complete');
                        --total || pause();
                    });
                }
            } else {
                pause();
            }
        };

        /**
         * Starts polling cycle.
         *
         * @api public
         */

        Polling.prototype.poll = function () {
            debug('polling');
            this.polling = true;
            this.doPoll();
            this.emit('poll');
        };

        /**
         * Overloads onData to detect payloads.
         *
         * @api private
         */

        Polling.prototype.onData = function (data) {
            var self = this;
            debug('polling got data %s', data);
            var callback = function (packet, index, total) {
                // if its the first message we consider the transport open
                if ('opening' === self.readyState) {
                    self.onOpen();
                }

                // if its a close packet, we close the ongoing requests
                if ('close' === packet.type) {
                    self.onClose();
                    return false;
                }

                // otherwise bypass onData and handle the message
                self.onPacket(packet);
            };

            // decode payload
            parser.decodePayload(data, this.socket.binaryType, callback);

            // if an event did not trigger closing
            if ('closed' !== this.readyState) {
                // if we got data we're not polling
                this.polling = false;
                this.emit('pollComplete');

                if ('open' === this.readyState) {
                    this.poll();
                } else {
                    debug('ignoring poll - transport state "%s"', this.readyState);
                }
            }
        };

        /**
         * For polling, send a close packet.
         *
         * @api private
         */

        Polling.prototype.doClose = function () {
            var self = this;

            function close () {
                debug('writing close packet');
                self.write([{ type: 'close' }]);
            }

            if ('open' === this.readyState) {
                debug('transport open - closing');
                close();
            } else {
                // in case we're trying to close while
                // handshaking is in progress (GH-164)
                debug('transport not open - deferring close');
                this.once('open', close);
            }
        };

        /**
         * Writes a packets payload.
         *
         * @param {Array} data packets
         * @param {Function} drain callback
         * @api private
         */

        Polling.prototype.write = function (packets) {
            var self = this;
            this.writable = false;
            var callbackfn = function () {
                self.writable = true;
                self.emit('drain');
            };

            parser.encodePayload(packets, this.supportsBinary, function (data) {
                self.doWrite(data, callbackfn);
            });
        };

        /**
         * Generates uri for connection.
         *
         * @api private
         */

        Polling.prototype.uri = function () {
            var query = this.query || {};
            var schema = this.secure ? 'https' : 'http';
            var port = '';

            // cache busting is forced
            if (false !== this.timestampRequests) {
                query[this.timestampParam] = yeast();
            }

            if (!this.supportsBinary && !query.sid) {
                query.b64 = 1;
            }

            query = parseqs.encode(query);

            // avoid port if default for schema
            if (this.port && (('https' === schema && Number(this.port) !== 443) ||
                    ('http' === schema && Number(this.port) !== 80))) {
                port = ':' + this.port;
            }

            // prepend ? to query
            if (query.length) {
                query = '?' + query;
            }

            var ipv6 = this.hostname.indexOf(':') !== -1;
            return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;
        };

    },{"../transport":16,"component-inherit":11,"debug":12,"engine.io-parser":23,"parseqs":32,"xmlhttprequest-ssl":22,"yeast":143}],21:[function(require,module,exports){
        (function (global){
            /**
             * Module dependencies.
             */

            var Transport = require('../transport');
            var parser = require('engine.io-parser');
            var parseqs = require('parseqs');
            var inherit = require('component-inherit');
            var yeast = require('yeast');
            var debug = require('debug')('engine.io-client:websocket');
            var BrowserWebSocket = global.WebSocket || global.MozWebSocket;
            var NodeWebSocket;
            if (typeof window === 'undefined') {
                try {
                    NodeWebSocket = require('ws');
                } catch (e) { }
            }

            /**
             * Get either the `WebSocket` or `MozWebSocket` globals
             * in the browser or try to resolve WebSocket-compatible
             * interface exposed by `ws` for Node-like environment.
             */

            var WebSocket = BrowserWebSocket;
            if (!WebSocket && typeof window === 'undefined') {
                WebSocket = NodeWebSocket;
            }

            /**
             * Module exports.
             */

            module.exports = WS;

            /**
             * WebSocket transport constructor.
             *
             * @api {Object} connection options
             * @api public
             */

            function WS (opts) {
                var forceBase64 = (opts && opts.forceBase64);
                if (forceBase64) {
                    this.supportsBinary = false;
                }
                this.perMessageDeflate = opts.perMessageDeflate;
                this.usingBrowserWebSocket = BrowserWebSocket && !opts.forceNode;
                this.protocols = opts.protocols;
                if (!this.usingBrowserWebSocket) {
                    WebSocket = NodeWebSocket;
                }
                Transport.call(this, opts);
            }

            /**
             * Inherits from Transport.
             */

            inherit(WS, Transport);

            /**
             * Transport name.
             *
             * @api public
             */

            WS.prototype.name = 'websocket';

            /*
 * WebSockets support binary
 */

            WS.prototype.supportsBinary = true;

            /**
             * Opens socket.
             *
             * @api private
             */

            WS.prototype.doOpen = function () {
                if (!this.check()) {
                    // let probe timeout
                    return;
                }

                var uri = this.uri();
                var protocols = this.protocols;
                var opts = {
                    agent: this.agent,
                    perMessageDeflate: this.perMessageDeflate
                };

                // SSL options for Node.js client
                opts.pfx = this.pfx;
                opts.key = this.key;
                opts.passphrase = this.passphrase;
                opts.cert = this.cert;
                opts.ca = this.ca;
                opts.ciphers = this.ciphers;
                opts.rejectUnauthorized = this.rejectUnauthorized;
                if (this.extraHeaders) {
                    opts.headers = this.extraHeaders;
                }
                if (this.localAddress) {
                    opts.localAddress = this.localAddress;
                }

                try {
                    this.ws = this.usingBrowserWebSocket ? (protocols ? new WebSocket(uri, protocols) : new WebSocket(uri)) : new WebSocket(uri, protocols, opts);
                } catch (err) {
                    return this.emit('error', err);
                }

                if (this.ws.binaryType === undefined) {
                    this.supportsBinary = false;
                }

                if (this.ws.supports && this.ws.supports.binary) {
                    this.supportsBinary = true;
                    this.ws.binaryType = 'nodebuffer';
                } else {
                    this.ws.binaryType = 'arraybuffer';
                }

                this.addEventListeners();
            };

            /**
             * Adds event listeners to the socket
             *
             * @api private
             */

            WS.prototype.addEventListeners = function () {
                var self = this;

                this.ws.onopen = function () {
                    self.onOpen();
                };
                this.ws.onclose = function () {
                    self.onClose();
                };
                this.ws.onmessage = function (ev) {
                    self.onData(ev.data);
                };
                this.ws.onerror = function (e) {
                    self.onError('websocket error', e);
                };
            };

            /**
             * Writes data to socket.
             *
             * @param {Array} array of packets.
             * @api private
             */

            WS.prototype.write = function (packets) {
                var self = this;
                this.writable = false;

                // encodePacket efficient as it uses WS framing
                // no need for encodePayload
                var total = packets.length;
                for (var i = 0, l = total; i < l; i++) {
                    (function (packet) {
                        parser.encodePacket(packet, self.supportsBinary, function (data) {
                            if (!self.usingBrowserWebSocket) {
                                // always create a new object (GH-437)
                                var opts = {};
                                if (packet.options) {
                                    opts.compress = packet.options.compress;
                                }

                                if (self.perMessageDeflate) {
                                    var len = 'string' === typeof data ? global.Buffer.byteLength(data) : data.length;
                                    if (len < self.perMessageDeflate.threshold) {
                                        opts.compress = false;
                                    }
                                }
                            }

                            // Sometimes the websocket has already been closed but the browser didn't
                            // have a chance of informing us about it yet, in that case send will
                            // throw an error
                            try {
                                if (self.usingBrowserWebSocket) {
                                    // TypeError is thrown when passing the second argument on Safari
                                    self.ws.send(data);
                                } else {
                                    self.ws.send(data, opts);
                                }
                            } catch (e) {
                                debug('websocket closed before onclose event');
                            }

                            --total || done();
                        });
                    })(packets[i]);
                }

                function done () {
                    self.emit('flush');

                    // fake drain
                    // defer to next tick to allow Socket to clear writeBuffer
                    setTimeout(function () {
                        self.writable = true;
                        self.emit('drain');
                    }, 0);
                }
            };

            /**
             * Called upon close
             *
             * @api private
             */

            WS.prototype.onClose = function () {
                Transport.prototype.onClose.call(this);
            };

            /**
             * Closes socket.
             *
             * @api private
             */

            WS.prototype.doClose = function () {
                if (typeof this.ws !== 'undefined') {
                    this.ws.close();
                }
            };

            /**
             * Generates uri for connection.
             *
             * @api private
             */

            WS.prototype.uri = function () {
                var query = this.query || {};
                var schema = this.secure ? 'wss' : 'ws';
                var port = '';

                // avoid port if default for schema
                if (this.port && (('wss' === schema && Number(this.port) !== 443) ||
                        ('ws' === schema && Number(this.port) !== 80))) {
                    port = ':' + this.port;
                }

                // append timestamp to URI
                if (this.timestampRequests) {
                    query[this.timestampParam] = yeast();
                }

                // communicate binary support capabilities
                if (!this.supportsBinary) {
                    query.b64 = 1;
                }

                query = parseqs.encode(query);

                // prepend ? to query
                if (query.length) {
                    query = '?' + query;
                }

                var ipv6 = this.hostname.indexOf(':') !== -1;
                return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;
            };

            /**
             * Feature detection for WebSocket.
             *
             * @return {Boolean} whether this transport is available.
             * @api public
             */

            WS.prototype.check = function () {
                return !!WebSocket && !('__initialize' in WebSocket && this.name === WS.prototype.name);
            };

        }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
    },{"../transport":16,"component-inherit":11,"debug":12,"engine.io-parser":23,"parseqs":32,"ws":7,"yeast":143}],22:[function(require,module,exports){
        (function (global){
// browser shim for xmlhttprequest module

            var hasCORS = require('has-cors');

            module.exports = function (opts) {
                var xdomain = opts.xdomain;

                // scheme must be same when usign XDomainRequest
                // http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx
                var xscheme = opts.xscheme;

                // XDomainRequest has a flow of not sending cookie, therefore it should be disabled as a default.
                // https://github.com/Automattic/engine.io-client/pull/217
                var enablesXDR = opts.enablesXDR;

                // XMLHttpRequest can be disabled on IE
                try {
                    if ('undefined' !== typeof XMLHttpRequest && (!xdomain || hasCORS)) {
                        return new XMLHttpRequest();
                    }
                } catch (e) { }

                // Use XDomainRequest for IE8 if enablesXDR is true
                // because loading bar keeps flashing when using jsonp-polling
                // https://github.com/yujiosaka/socke.io-ie8-loading-example
                try {
                    if ('undefined' !== typeof XDomainRequest && !xscheme && enablesXDR) {
                        return new XDomainRequest();
                    }
                } catch (e) { }

                if (!xdomain) {
                    try {
                        return new global[['Active'].concat('Object').join('X')]('Microsoft.XMLHTTP');
                    } catch (e) { }
                }
            };

        }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
    },{"has-cors":28}],23:[function(require,module,exports){
        (function (global){
            /**
             * Module dependencies.
             */

            var keys = require('./keys');
            var hasBinary = require('has-binary2');
            var sliceBuffer = require('arraybuffer.slice');
            var after = require('after');
            var utf8 = require('./utf8');

            var base64encoder;
            if (global && global.ArrayBuffer) {
                base64encoder = require('base64-arraybuffer');
            }

            /**
             * Check if we are running an android browser. That requires us to use
             * ArrayBuffer with polling transports...
             *
             * http://ghinda.net/jpeg-blob-ajax-android/
             */

            var isAndroid = typeof navigator !== 'undefined' && /Android/i.test(navigator.userAgent);

            /**
             * Check if we are running in PhantomJS.
             * Uploading a Blob with PhantomJS does not work correctly, as reported here:
             * https://github.com/ariya/phantomjs/issues/11395
             * @type boolean
             */
            var isPhantomJS = typeof navigator !== 'undefined' && /PhantomJS/i.test(navigator.userAgent);

            /**
             * When true, avoids using Blobs to encode payloads.
             * @type boolean
             */
            var dontSendBlobs = isAndroid || isPhantomJS;

            /**
             * Current protocol version.
             */

            exports.protocol = 3;

            /**
             * Packet types.
             */

            var packets = exports.packets = {
                open:     0    // non-ws
                , close:    1    // non-ws
                , ping:     2
                , pong:     3
                , message:  4
                , upgrade:  5
                , noop:     6
            };

            var packetslist = keys(packets);

            /**
             * Premade error packet.
             */

            var err = { type: 'error', data: 'parser error' };

            /**
             * Create a blob api even for blob builder when vendor prefixes exist
             */

            var Blob = require('blob');

            /**
             * Encodes a packet.
             *
             *     <packet type id> [ <data> ]
             *
             * Example:
             *
             *     5hello world
             *     3
             *     4
             *
             * Binary is encoded in an identical principle
             *
             * @api private
             */

            exports.encodePacket = function (packet, supportsBinary, utf8encode, callback) {
                if (typeof supportsBinary === 'function') {
                    callback = supportsBinary;
                    supportsBinary = false;
                }

                if (typeof utf8encode === 'function') {
                    callback = utf8encode;
                    utf8encode = null;
                }

                var data = (packet.data === undefined)
                        ? undefined
                        : packet.data.buffer || packet.data;

                if (global.ArrayBuffer && data instanceof ArrayBuffer) {
                    return encodeArrayBuffer(packet, supportsBinary, callback);
                } else if (Blob && data instanceof global.Blob) {
                    return encodeBlob(packet, supportsBinary, callback);
                }

                // might be an object with { base64: true, data: dataAsBase64String }
                if (data && data.base64) {
                    return encodeBase64Object(packet, callback);
                }

                // Sending data as a utf-8 string
                var encoded = packets[packet.type];

                // data fragment is optional
                if (undefined !== packet.data) {
                    encoded += utf8encode ? utf8.encode(String(packet.data), { strict: false }) : String(packet.data);
                }

                return callback('' + encoded);

            };

            function encodeBase64Object(packet, callback) {
                // packet data is an object { base64: true, data: dataAsBase64String }
                var message = 'b' + exports.packets[packet.type] + packet.data.data;
                return callback(message);
            }

            /**
             * Encode packet helpers for binary types
             */

            function encodeArrayBuffer(packet, supportsBinary, callback) {
                if (!supportsBinary) {
                    return exports.encodeBase64Packet(packet, callback);
                }

                var data = packet.data;
                var contentArray = new Uint8Array(data);
                var resultBuffer = new Uint8Array(1 + data.byteLength);

                resultBuffer[0] = packets[packet.type];
                for (var i = 0; i < contentArray.length; i++) {
                    resultBuffer[i+1] = contentArray[i];
                }

                return callback(resultBuffer.buffer);
            }

            function encodeBlobAsArrayBuffer(packet, supportsBinary, callback) {
                if (!supportsBinary) {
                    return exports.encodeBase64Packet(packet, callback);
                }

                var fr = new FileReader();
                fr.onload = function() {
                    packet.data = fr.result;
                    exports.encodePacket(packet, supportsBinary, true, callback);
                };
                return fr.readAsArrayBuffer(packet.data);
            }

            function encodeBlob(packet, supportsBinary, callback) {
                if (!supportsBinary) {
                    return exports.encodeBase64Packet(packet, callback);
                }

                if (dontSendBlobs) {
                    return encodeBlobAsArrayBuffer(packet, supportsBinary, callback);
                }

                var length = new Uint8Array(1);
                length[0] = packets[packet.type];
                var blob = new Blob([length.buffer, packet.data]);

                return callback(blob);
            }

            /**
             * Encodes a packet with binary data in a base64 string
             *
             * @param {Object} packet, has `type` and `data`
             * @return {String} base64 encoded message
             */

            exports.encodeBase64Packet = function(packet, callback) {
                var message = 'b' + exports.packets[packet.type];
                if (Blob && packet.data instanceof global.Blob) {
                    var fr = new FileReader();
                    fr.onload = function() {
                        var b64 = fr.result.split(',')[1];
                        callback(message + b64);
                    };
                    return fr.readAsDataURL(packet.data);
                }

                var b64data;
                try {
                    b64data = String.fromCharCode.apply(null, new Uint8Array(packet.data));
                } catch (e) {
                    // iPhone Safari doesn't let you apply with typed arrays
                    var typed = new Uint8Array(packet.data);
                    var basic = new Array(typed.length);
                    for (var i = 0; i < typed.length; i++) {
                        basic[i] = typed[i];
                    }
                    b64data = String.fromCharCode.apply(null, basic);
                }
                message += global.btoa(b64data);
                return callback(message);
            };

            /**
             * Decodes a packet. Changes format to Blob if requested.
             *
             * @return {Object} with `type` and `data` (if any)
             * @api private
             */

            exports.decodePacket = function (data, binaryType, utf8decode) {
                if (data === undefined) {
                    return err;
                }
                // String data
                if (typeof data === 'string') {
                    if (data.charAt(0) === 'b') {
                        return exports.decodeBase64Packet(data.substr(1), binaryType);
                    }

                    if (utf8decode) {
                        data = tryDecode(data);
                        if (data === false) {
                            return err;
                        }
                    }
                    var type = data.charAt(0);

                    if (Number(type) != type || !packetslist[type]) {
                        return err;
                    }

                    if (data.length > 1) {
                        return { type: packetslist[type], data: data.substring(1) };
                    } else {
                        return { type: packetslist[type] };
                    }
                }

                var asArray = new Uint8Array(data);
                var type = asArray[0];
                var rest = sliceBuffer(data, 1);
                if (Blob && binaryType === 'blob') {
                    rest = new Blob([rest]);
                }
                return { type: packetslist[type], data: rest };
            };

            function tryDecode(data) {
                try {
                    data = utf8.decode(data, { strict: false });
                } catch (e) {
                    return false;
                }
                return data;
            }

            /**
             * Decodes a packet encoded in a base64 string
             *
             * @param {String} base64 encoded message
             * @return {Object} with `type` and `data` (if any)
             */

            exports.decodeBase64Packet = function(msg, binaryType) {
                var type = packetslist[msg.charAt(0)];
                if (!base64encoder) {
                    return { type: type, data: { base64: true, data: msg.substr(1) } };
                }

                var data = base64encoder.decode(msg.substr(1));

                if (binaryType === 'blob' && Blob) {
                    data = new Blob([data]);
                }

                return { type: type, data: data };
            };

            /**
             * Encodes multiple messages (payload).
             *
             *     <length>:data
             *
             * Example:
             *
             *     11:hello world2:hi
             *
             * If any contents are binary, they will be encoded as base64 strings. Base64
             * encoded strings are marked with a b before the length specifier
             *
             * @param {Array} packets
             * @api private
             */

            exports.encodePayload = function (packets, supportsBinary, callback) {
                if (typeof supportsBinary === 'function') {
                    callback = supportsBinary;
                    supportsBinary = null;
                }

                var isBinary = hasBinary(packets);

                if (supportsBinary && isBinary) {
                    if (Blob && !dontSendBlobs) {
                        return exports.encodePayloadAsBlob(packets, callback);
                    }

                    return exports.encodePayloadAsArrayBuffer(packets, callback);
                }

                if (!packets.length) {
                    return callback('0:');
                }

                function setLengthHeader(message) {
                    return message.length + ':' + message;
                }

                function encodeOne(packet, doneCallback) {
                    exports.encodePacket(packet, !isBinary ? false : supportsBinary, false, function(message) {
                        doneCallback(null, setLengthHeader(message));
                    });
                }

                map(packets, encodeOne, function(err, results) {
                    return callback(results.join(''));
                });
            };

            /**
             * Async array map using after
             */

            function map(ary, each, done) {
                var result = new Array(ary.length);
                var next = after(ary.length, done);

                var eachWithIndex = function(i, el, cb) {
                    each(el, function(error, msg) {
                        result[i] = msg;
                        cb(error, result);
                    });
                };

                for (var i = 0; i < ary.length; i++) {
                    eachWithIndex(i, ary[i], next);
                }
            }

            /*
 * Decodes data when a payload is maybe expected. Possible binary contents are
 * decoded from their base64 representation
 *
 * @param {String} data, callback method
 * @api public
 */

            exports.decodePayload = function (data, binaryType, callback) {
                if (typeof data !== 'string') {
                    return exports.decodePayloadAsBinary(data, binaryType, callback);
                }

                if (typeof binaryType === 'function') {
                    callback = binaryType;
                    binaryType = null;
                }

                var packet;
                if (data === '') {
                    // parser error - ignoring payload
                    return callback(err, 0, 1);
                }

                var length = '', n, msg;

                for (var i = 0, l = data.length; i < l; i++) {
                    var chr = data.charAt(i);

                    if (chr !== ':') {
                        length += chr;
                        continue;
                    }

                    if (length === '' || (length != (n = Number(length)))) {
                        // parser error - ignoring payload
                        return callback(err, 0, 1);
                    }

                    msg = data.substr(i + 1, n);

                    if (length != msg.length) {
                        // parser error - ignoring payload
                        return callback(err, 0, 1);
                    }

                    if (msg.length) {
                        packet = exports.decodePacket(msg, binaryType, false);

                        if (err.type === packet.type && err.data === packet.data) {
                            // parser error in individual packet - ignoring payload
                            return callback(err, 0, 1);
                        }

                        var ret = callback(packet, i + n, l);
                        if (false === ret) return;
                    }

                    // advance cursor
                    i += n;
                    length = '';
                }

                if (length !== '') {
                    // parser error - ignoring payload
                    return callback(err, 0, 1);
                }

            };

            /**
             * Encodes multiple messages (payload) as binary.
             *
             * <1 = binary, 0 = string><number from 0-9><number from 0-9>[...]<number
             * 255><data>
             *
             * Example:
             * 1 3 255 1 2 3, if the binary contents are interpreted as 8 bit integers
             *
             * @param {Array} packets
             * @return {ArrayBuffer} encoded payload
             * @api private
             */

            exports.encodePayloadAsArrayBuffer = function(packets, callback) {
                if (!packets.length) {
                    return callback(new ArrayBuffer(0));
                }

                function encodeOne(packet, doneCallback) {
                    exports.encodePacket(packet, true, true, function(data) {
                        return doneCallback(null, data);
                    });
                }

                map(packets, encodeOne, function(err, encodedPackets) {
                    var totalLength = encodedPackets.reduce(function(acc, p) {
                        var len;
                        if (typeof p === 'string'){
                            len = p.length;
                        } else {
                            len = p.byteLength;
                        }
                        return acc + len.toString().length + len + 2; // string/binary identifier + separator = 2
                    }, 0);

                    var resultArray = new Uint8Array(totalLength);

                    var bufferIndex = 0;
                    encodedPackets.forEach(function(p) {
                        var isString = typeof p === 'string';
                        var ab = p;
                        if (isString) {
                            var view = new Uint8Array(p.length);
                            for (var i = 0; i < p.length; i++) {
                                view[i] = p.charCodeAt(i);
                            }
                            ab = view.buffer;
                        }

                        if (isString) { // not true binary
                            resultArray[bufferIndex++] = 0;
                        } else { // true binary
                            resultArray[bufferIndex++] = 1;
                        }

                        var lenStr = ab.byteLength.toString();
                        for (var i = 0; i < lenStr.length; i++) {
                            resultArray[bufferIndex++] = parseInt(lenStr[i]);
                        }
                        resultArray[bufferIndex++] = 255;

                        var view = new Uint8Array(ab);
                        for (var i = 0; i < view.length; i++) {
                            resultArray[bufferIndex++] = view[i];
                        }
                    });

                    return callback(resultArray.buffer);
                });
            };

            /**
             * Encode as Blob
             */

            exports.encodePayloadAsBlob = function(packets, callback) {
                function encodeOne(packet, doneCallback) {
                    exports.encodePacket(packet, true, true, function(encoded) {
                        var binaryIdentifier = new Uint8Array(1);
                        binaryIdentifier[0] = 1;
                        if (typeof encoded === 'string') {
                            var view = new Uint8Array(encoded.length);
                            for (var i = 0; i < encoded.length; i++) {
                                view[i] = encoded.charCodeAt(i);
                            }
                            encoded = view.buffer;
                            binaryIdentifier[0] = 0;
                        }

                        var len = (encoded instanceof ArrayBuffer)
                                ? encoded.byteLength
                                : encoded.size;

                        var lenStr = len.toString();
                        var lengthAry = new Uint8Array(lenStr.length + 1);
                        for (var i = 0; i < lenStr.length; i++) {
                            lengthAry[i] = parseInt(lenStr[i]);
                        }
                        lengthAry[lenStr.length] = 255;

                        if (Blob) {
                            var blob = new Blob([binaryIdentifier.buffer, lengthAry.buffer, encoded]);
                            doneCallback(null, blob);
                        }
                    });
                }

                map(packets, encodeOne, function(err, results) {
                    return callback(new Blob(results));
                });
            };

            /*
 * Decodes data when a payload is maybe expected. Strings are decoded by
 * interpreting each byte as a key code for entries marked to start with 0. See
 * description of encodePayloadAsBinary
 *
 * @param {ArrayBuffer} data, callback method
 * @api public
 */

            exports.decodePayloadAsBinary = function (data, binaryType, callback) {
                if (typeof binaryType === 'function') {
                    callback = binaryType;
                    binaryType = null;
                }

                var bufferTail = data;
                var buffers = [];

                while (bufferTail.byteLength > 0) {
                    var tailArray = new Uint8Array(bufferTail);
                    var isString = tailArray[0] === 0;
                    var msgLength = '';

                    for (var i = 1; ; i++) {
                        if (tailArray[i] === 255) break;

                        // 310 = char length of Number.MAX_VALUE
                        if (msgLength.length > 310) {
                            return callback(err, 0, 1);
                        }

                        msgLength += tailArray[i];
                    }

                    bufferTail = sliceBuffer(bufferTail, 2 + msgLength.length);
                    msgLength = parseInt(msgLength);

                    var msg = sliceBuffer(bufferTail, 0, msgLength);
                    if (isString) {
                        try {
                            msg = String.fromCharCode.apply(null, new Uint8Array(msg));
                        } catch (e) {
                            // iPhone Safari doesn't let you apply to typed arrays
                            var typed = new Uint8Array(msg);
                            msg = '';
                            for (var i = 0; i < typed.length; i++) {
                                msg += String.fromCharCode(typed[i]);
                            }
                        }
                    }

                    buffers.push(msg);
                    bufferTail = sliceBuffer(bufferTail, msgLength);
                }

                var total = buffers.length;
                buffers.forEach(function(buffer, i) {
                    callback(exports.decodePacket(buffer, binaryType, true), i, total);
                });
            };

        }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
    },{"./keys":24,"./utf8":25,"after":1,"arraybuffer.slice":2,"base64-arraybuffer":4,"blob":6,"has-binary2":26}],24:[function(require,module,exports){

        /**
         * Gets the keys for an object.
         *
         * @return {Array} keys
         * @api private
         */

        module.exports = Object.keys || function keys (obj){
                    var arr = [];
                    var has = Object.prototype.hasOwnProperty;

                    for (var i in obj) {
                        if (has.call(obj, i)) {
                            arr.push(i);
                        }
                    }
                    return arr;
                };

    },{}],25:[function(require,module,exports){
        (function (global){
            /*! https://mths.be/utf8js v2.1.2 by @mathias */
            ;(function(root) {

                // Detect free variables `exports`
                var freeExports = typeof exports == 'object' && exports;

                // Detect free variable `module`
                var freeModule = typeof module == 'object' && module &&
                        module.exports == freeExports && module;

                // Detect free variable `global`, from Node.js or Browserified code,
                // and use it as `root`
                var freeGlobal = typeof global == 'object' && global;
                if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
                    root = freeGlobal;
                }

                /*--------------------------------------------------------------------------*/

                var stringFromCharCode = String.fromCharCode;

                // Taken from https://mths.be/punycode
                function ucs2decode(string) {
                    var output = [];
                    var counter = 0;
                    var length = string.length;
                    var value;
                    var extra;
                    while (counter < length) {
                        value = string.charCodeAt(counter++);
                        if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
                            // high surrogate, and there is a next character
                            extra = string.charCodeAt(counter++);
                            if ((extra & 0xFC00) == 0xDC00) { // low surrogate
                                output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
                            } else {
                                // unmatched surrogate; only append this code unit, in case the next
                                // code unit is the high surrogate of a surrogate pair
                                output.push(value);
                                counter--;
                            }
                        } else {
                            output.push(value);
                        }
                    }
                    return output;
                }

                // Taken from https://mths.be/punycode
                function ucs2encode(array) {
                    var length = array.length;
                    var index = -1;
                    var value;
                    var output = '';
                    while (++index < length) {
                        value = array[index];
                        if (value > 0xFFFF) {
                            value -= 0x10000;
                            output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
                            value = 0xDC00 | value & 0x3FF;
                        }
                        output += stringFromCharCode(value);
                    }
                    return output;
                }

                function checkScalarValue(codePoint, strict) {
                    if (codePoint >= 0xD800 && codePoint <= 0xDFFF) {
                        if (strict) {
                            throw Error(
                                    'Lone surrogate U+' + codePoint.toString(16).toUpperCase() +
                                    ' is not a scalar value'
                            );
                        }
                        return false;
                    }
                    return true;
                }
                /*--------------------------------------------------------------------------*/

                function createByte(codePoint, shift) {
                    return stringFromCharCode(((codePoint >> shift) & 0x3F) | 0x80);
                }

                function encodeCodePoint(codePoint, strict) {
                    if ((codePoint & 0xFFFFFF80) == 0) { // 1-byte sequence
                        return stringFromCharCode(codePoint);
                    }
                    var symbol = '';
                    if ((codePoint & 0xFFFFF800) == 0) { // 2-byte sequence
                        symbol = stringFromCharCode(((codePoint >> 6) & 0x1F) | 0xC0);
                    }
                    else if ((codePoint & 0xFFFF0000) == 0) { // 3-byte sequence
                        if (!checkScalarValue(codePoint, strict)) {
                            codePoint = 0xFFFD;
                        }
                        symbol = stringFromCharCode(((codePoint >> 12) & 0x0F) | 0xE0);
                        symbol += createByte(codePoint, 6);
                    }
                    else if ((codePoint & 0xFFE00000) == 0) { // 4-byte sequence
                        symbol = stringFromCharCode(((codePoint >> 18) & 0x07) | 0xF0);
                        symbol += createByte(codePoint, 12);
                        symbol += createByte(codePoint, 6);
                    }
                    symbol += stringFromCharCode((codePoint & 0x3F) | 0x80);
                    return symbol;
                }

                function utf8encode(string, opts) {
                    opts = opts || {};
                    var strict = false !== opts.strict;

                    var codePoints = ucs2decode(string);
                    var length = codePoints.length;
                    var index = -1;
                    var codePoint;
                    var byteString = '';
                    while (++index < length) {
                        codePoint = codePoints[index];
                        byteString += encodeCodePoint(codePoint, strict);
                    }
                    return byteString;
                }

                /*--------------------------------------------------------------------------*/

                function readContinuationByte() {
                    if (byteIndex >= byteCount) {
                        throw Error('Invalid byte index');
                    }

                    var continuationByte = byteArray[byteIndex] & 0xFF;
                    byteIndex++;

                    if ((continuationByte & 0xC0) == 0x80) {
                        return continuationByte & 0x3F;
                    }

                    // If we end up here, it’s not a continuation byte
                    throw Error('Invalid continuation byte');
                }

                function decodeSymbol(strict) {
                    var byte1;
                    var byte2;
                    var byte3;
                    var byte4;
                    var codePoint;

                    if (byteIndex > byteCount) {
                        throw Error('Invalid byte index');
                    }

                    if (byteIndex == byteCount) {
                        return false;
                    }

                    // Read first byte
                    byte1 = byteArray[byteIndex] & 0xFF;
                    byteIndex++;

                    // 1-byte sequence (no continuation bytes)
                    if ((byte1 & 0x80) == 0) {
                        return byte1;
                    }

                    // 2-byte sequence
                    if ((byte1 & 0xE0) == 0xC0) {
                        byte2 = readContinuationByte();
                        codePoint = ((byte1 & 0x1F) << 6) | byte2;
                        if (codePoint >= 0x80) {
                            return codePoint;
                        } else {
                            throw Error('Invalid continuation byte');
                        }
                    }

                    // 3-byte sequence (may include unpaired surrogates)
                    if ((byte1 & 0xF0) == 0xE0) {
                        byte2 = readContinuationByte();
                        byte3 = readContinuationByte();
                        codePoint = ((byte1 & 0x0F) << 12) | (byte2 << 6) | byte3;
                        if (codePoint >= 0x0800) {
                            return checkScalarValue(codePoint, strict) ? codePoint : 0xFFFD;
                        } else {
                            throw Error('Invalid continuation byte');
                        }
                    }

                    // 4-byte sequence
                    if ((byte1 & 0xF8) == 0xF0) {
                        byte2 = readContinuationByte();
                        byte3 = readContinuationByte();
                        byte4 = readContinuationByte();
                        codePoint = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0C) |
                                (byte3 << 0x06) | byte4;
                        if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {
                            return codePoint;
                        }
                    }

                    throw Error('Invalid UTF-8 detected');
                }

                var byteArray;
                var byteCount;
                var byteIndex;
                function utf8decode(byteString, opts) {
                    opts = opts || {};
                    var strict = false !== opts.strict;

                    byteArray = ucs2decode(byteString);
                    byteCount = byteArray.length;
                    byteIndex = 0;
                    var codePoints = [];
                    var tmp;
                    while ((tmp = decodeSymbol(strict)) !== false) {
                        codePoints.push(tmp);
                    }
                    return ucs2encode(codePoints);
                }

                /*--------------------------------------------------------------------------*/

                var utf8 = {
                    'version': '2.1.2',
                    'encode': utf8encode,
                    'decode': utf8decode
                };

                // Some AMD build optimizers, like r.js, check for specific condition patterns
                // like the following:
                if (
                        typeof define == 'function' &&
                        typeof define.amd == 'object' &&
                        define.amd
                ) {
                    define(function() {
                        return utf8;
                    });
                }	else if (freeExports && !freeExports.nodeType) {
                    if (freeModule) { // in Node.js or RingoJS v0.8.0+
                        freeModule.exports = utf8;
                    } else { // in Narwhal or RingoJS v0.7.0-
                        var object = {};
                        var hasOwnProperty = object.hasOwnProperty;
                        for (var key in utf8) {
                            hasOwnProperty.call(utf8, key) && (freeExports[key] = utf8[key]);
                        }
                    }
                } else { // in Rhino or a web browser
                    root.utf8 = utf8;
                }

            }(this));

        }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
    },{}],26:[function(require,module,exports){
        (function (Buffer){
            /* global Blob File */

            /*
 * Module requirements.
 */

            var isArray = require('isarray');

            var toString = Object.prototype.toString;
            var withNativeBlob = typeof Blob === 'function' ||
                    typeof Blob !== 'undefined' && toString.call(Blob) === '[object BlobConstructor]';
            var withNativeFile = typeof File === 'function' ||
                    typeof File !== 'undefined' && toString.call(File) === '[object FileConstructor]';

            /**
             * Module exports.
             */

            module.exports = hasBinary;

            /**
             * Checks for binary data.
             *
             * Supports Buffer, ArrayBuffer, Blob and File.
             *
             * @param {Object} anything
             * @api public
             */

            function hasBinary (obj) {
                if (!obj || typeof obj !== 'object') {
                    return false;
                }

                if (isArray(obj)) {
                    for (var i = 0, l = obj.length; i < l; i++) {
                        if (hasBinary(obj[i])) {
                            return true;
                        }
                    }
                    return false;
                }

                if ((typeof Buffer === 'function' && Buffer.isBuffer && Buffer.isBuffer(obj)) ||
                        (typeof ArrayBuffer === 'function' && obj instanceof ArrayBuffer) ||
                        (withNativeBlob && obj instanceof Blob) ||
                        (withNativeFile && obj instanceof File)
                ) {
                    return true;
                }

                // see: https://github.com/Automattic/has-binary/pull/4
                if (obj.toJSON && typeof obj.toJSON === 'function' && arguments.length === 1) {
                    return hasBinary(obj.toJSON(), true);
                }

                for (var key in obj) {
                    if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {
                        return true;
                    }
                }

                return false;
            }

        }).call(this,require("buffer").Buffer)
    },{"buffer":8,"isarray":27}],27:[function(require,module,exports){
        var toString = {}.toString;

        module.exports = Array.isArray || function (arr) {
                    return toString.call(arr) == '[object Array]';
                };

    },{}],28:[function(require,module,exports){

        /**
         * Module exports.
         *
         * Logic borrowed from Modernizr:
         *
         *   - https://github.com/Modernizr/Modernizr/blob/master/feature-detects/cors.js
         */

        try {
            module.exports = typeof XMLHttpRequest !== 'undefined' &&
                    'withCredentials' in new XMLHttpRequest();
        } catch (err) {
            // if XMLHttp support is disabled in IE then it will throw
            // when trying to create
            module.exports = false;
        }

    },{}],29:[function(require,module,exports){
        exports.read = function (buffer, offset, isLE, mLen, nBytes) {
            var e, m
            var eLen = (nBytes * 8) - mLen - 1
            var eMax = (1 << eLen) - 1
            var eBias = eMax >> 1
            var nBits = -7
            var i = isLE ? (nBytes - 1) : 0
            var d = isLE ? -1 : 1
            var s = buffer[offset + i]

            i += d

            e = s & ((1 << (-nBits)) - 1)
            s >>= (-nBits)
            nBits += eLen
            for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

            m = e & ((1 << (-nBits)) - 1)
            e >>= (-nBits)
            nBits += mLen
            for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

            if (e === 0) {
                e = 1 - eBias
            } else if (e === eMax) {
                return m ? NaN : ((s ? -1 : 1) * Infinity)
            } else {
                m = m + Math.pow(2, mLen)
                e = e - eBias
            }
            return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
        }

        exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
            var e, m, c
            var eLen = (nBytes * 8) - mLen - 1
            var eMax = (1 << eLen) - 1
            var eBias = eMax >> 1
            var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
            var i = isLE ? 0 : (nBytes - 1)
            var d = isLE ? 1 : -1
            var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

            value = Math.abs(value)

            if (isNaN(value) || value === Infinity) {
                m = isNaN(value) ? 1 : 0
                e = eMax
            } else {
                e = Math.floor(Math.log(value) / Math.LN2)
                if (value * (c = Math.pow(2, -e)) < 1) {
                    e--
                    c *= 2
                }
                if (e + eBias >= 1) {
                    value += rt / c
                } else {
                    value += rt * Math.pow(2, 1 - eBias)
                }
                if (value * c >= 2) {
                    e++
                    c /= 2
                }

                if (e + eBias >= eMax) {
                    m = 0
                    e = eMax
                } else if (e + eBias >= 1) {
                    m = ((value * c) - 1) * Math.pow(2, mLen)
                    e = e + eBias
                } else {
                    m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
                    e = 0
                }
            }

            for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

            e = (e << mLen) | m
            eLen += mLen
            for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

            buffer[offset + i - d] |= s * 128
        }

    },{}],30:[function(require,module,exports){

        var indexOf = [].indexOf;

        module.exports = function(arr, obj){
            if (indexOf) return arr.indexOf(obj);
            for (var i = 0; i < arr.length; ++i) {
                if (arr[i] === obj) return i;
            }
            return -1;
        };
    },{}],31:[function(require,module,exports){
        /**
         * Helpers.
         */

        var s = 1000;
        var m = s * 60;
        var h = m * 60;
        var d = h * 24;
        var y = d * 365.25;

        /**
         * Parse or format the given `val`.
         *
         * Options:
         *
         *  - `long` verbose formatting [false]
         *
         * @param {String|Number} val
         * @param {Object} [options]
         * @throws {Error} throw an error if val is not a non-empty string or a number
         * @return {String|Number}
         * @api public
         */

        module.exports = function(val, options) {
            options = options || {};
            var type = typeof val;
            if (type === 'string' && val.length > 0) {
                return parse(val);
            } else if (type === 'number' && isNaN(val) === false) {
                return options.long ? fmtLong(val) : fmtShort(val);
            }
            throw new Error(
                    'val is not a non-empty string or a valid number. val=' +
                    JSON.stringify(val)
            );
        };

        /**
         * Parse the given `str` and return milliseconds.
         *
         * @param {String} str
         * @return {Number}
         * @api private
         */

        function parse(str) {
            str = String(str);
            if (str.length > 100) {
                return;
            }
            var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
                    str
            );
            if (!match) {
                return;
            }
            var n = parseFloat(match[1]);
            var type = (match[2] || 'ms').toLowerCase();
            switch (type) {
                case 'years':
                case 'year':
                case 'yrs':
                case 'yr':
                case 'y':
                    return n * y;
                case 'days':
                case 'day':
                case 'd':
                    return n * d;
                case 'hours':
                case 'hour':
                case 'hrs':
                case 'hr':
                case 'h':
                    return n * h;
                case 'minutes':
                case 'minute':
                case 'mins':
                case 'min':
                case 'm':
                    return n * m;
                case 'seconds':
                case 'second':
                case 'secs':
                case 'sec':
                case 's':
                    return n * s;
                case 'milliseconds':
                case 'millisecond':
                case 'msecs':
                case 'msec':
                case 'ms':
                    return n;
                default:
                    return undefined;
            }
        }

        /**
         * Short format for `ms`.
         *
         * @param {Number} ms
         * @return {String}
         * @api private
         */

        function fmtShort(ms) {
            if (ms >= d) {
                return Math.round(ms / d) + 'd';
            }
            if (ms >= h) {
                return Math.round(ms / h) + 'h';
            }
            if (ms >= m) {
                return Math.round(ms / m) + 'm';
            }
            if (ms >= s) {
                return Math.round(ms / s) + 's';
            }
            return ms + 'ms';
        }

        /**
         * Long format for `ms`.
         *
         * @param {Number} ms
         * @return {String}
         * @api private
         */

        function fmtLong(ms) {
            return plural(ms, d, 'day') ||
                    plural(ms, h, 'hour') ||
                    plural(ms, m, 'minute') ||
                    plural(ms, s, 'second') ||
                    ms + ' ms';
        }

        /**
         * Pluralization helper.
         */

        function plural(ms, n, name) {
            if (ms < n) {
                return;
            }
            if (ms < n * 1.5) {
                return Math.floor(ms / n) + ' ' + name;
            }
            return Math.ceil(ms / n) + ' ' + name + 's';
        }

    },{}],32:[function(require,module,exports){
        /**
         * Compiles a querystring
         * Returns string representation of the object
         *
         * @param {Object}
         * @api private
         */

        exports.encode = function (obj) {
            var str = '';

            for (var i in obj) {
                if (obj.hasOwnProperty(i)) {
                    if (str.length) str += '&';
                    str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);
                }
            }

            return str;
        };

        /**
         * Parses a simple querystring into an object
         *
         * @param {String} qs
         * @api private
         */

        exports.decode = function(qs){
            var qry = {};
            var pairs = qs.split('&');
            for (var i = 0, l = pairs.length; i < l; i++) {
                var pair = pairs[i].split('=');
                qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
            }
            return qry;
        };

    },{}],33:[function(require,module,exports){
        /**
         * Parses an URI
         *
         * @author Steven Levithan <stevenlevithan.com> (MIT license)
         * @api private
         */

        var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;

        var parts = [
            'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'
        ];

        module.exports = function parseuri(str) {
            var src = str,
                    b = str.indexOf('['),
                    e = str.indexOf(']');

            if (b != -1 && e != -1) {
                str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);
            }

            var m = re.exec(str || ''),
                    uri = {},
                    i = 14;

            while (i--) {
                uri[parts[i]] = m[i] || '';
            }

            if (b != -1 && e != -1) {
                uri.source = src;
                uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');
                uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');
                uri.ipv6uri = true;
            }

            return uri;
        };

    },{}],34:[function(require,module,exports){
// shim for using process in browser
        var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

        var cachedSetTimeout;
        var cachedClearTimeout;

        function defaultSetTimout() {
            throw new Error('setTimeout has not been defined');
        }
        function defaultClearTimeout () {
            throw new Error('clearTimeout has not been defined');
        }
        (function () {
            try {
                if (typeof setTimeout === 'function') {
                    cachedSetTimeout = setTimeout;
                } else {
                    cachedSetTimeout = defaultSetTimout;
                }
            } catch (e) {
                cachedSetTimeout = defaultSetTimout;
            }
            try {
                if (typeof clearTimeout === 'function') {
                    cachedClearTimeout = clearTimeout;
                } else {
                    cachedClearTimeout = defaultClearTimeout;
                }
            } catch (e) {
                cachedClearTimeout = defaultClearTimeout;
            }
        } ())
        function runTimeout(fun) {
            if (cachedSetTimeout === setTimeout) {
                //normal enviroments in sane situations
                return setTimeout(fun, 0);
            }
            // if setTimeout wasn't available but was latter defined
            if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
                cachedSetTimeout = setTimeout;
                return setTimeout(fun, 0);
            }
            try {
                // when when somebody has screwed with setTimeout but no I.E. maddness
                return cachedSetTimeout(fun, 0);
            } catch(e){
                try {
                    // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
                    return cachedSetTimeout.call(null, fun, 0);
                } catch(e){
                    // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
                    return cachedSetTimeout.call(this, fun, 0);
                }
            }


        }
        function runClearTimeout(marker) {
            if (cachedClearTimeout === clearTimeout) {
                //normal enviroments in sane situations
                return clearTimeout(marker);
            }
            // if clearTimeout wasn't available but was latter defined
            if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
                cachedClearTimeout = clearTimeout;
                return clearTimeout(marker);
            }
            try {
                // when when somebody has screwed with setTimeout but no I.E. maddness
                return cachedClearTimeout(marker);
            } catch (e){
                try {
                    // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
                    return cachedClearTimeout.call(null, marker);
                } catch (e){
                    // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
                    // Some versions of I.E. have different rules for clearTimeout vs setTimeout
                    return cachedClearTimeout.call(this, marker);
                }
            }



        }
        var queue = [];
        var draining = false;
        var currentQueue;
        var queueIndex = -1;

        function cleanUpNextTick() {
            if (!draining || !currentQueue) {
                return;
            }
            draining = false;
            if (currentQueue.length) {
                queue = currentQueue.concat(queue);
            } else {
                queueIndex = -1;
            }
            if (queue.length) {
                drainQueue();
            }
        }

        function drainQueue() {
            if (draining) {
                return;
            }
            var timeout = runTimeout(cleanUpNextTick);
            draining = true;

            var len = queue.length;
            while(len) {
                currentQueue = queue;
                queue = [];
                while (++queueIndex < len) {
                    if (currentQueue) {
                        currentQueue[queueIndex].run();
                    }
                }
                queueIndex = -1;
                len = queue.length;
            }
            currentQueue = null;
            draining = false;
            runClearTimeout(timeout);
        }

        process.nextTick = function (fun) {
            var args = new Array(arguments.length - 1);
            if (arguments.length > 1) {
                for (var i = 1; i < arguments.length; i++) {
                    args[i - 1] = arguments[i];
                }
            }
            queue.push(new Item(fun, args));
            if (queue.length === 1 && !draining) {
                runTimeout(drainQueue);
            }
        };

// v8 likes predictible objects
        function Item(fun, array) {
            this.fun = fun;
            this.array = array;
        }
        Item.prototype.run = function () {
            this.fun.apply(null, this.array);
        };
        process.title = 'browser';
        process.browser = true;
        process.env = {};
        process.argv = [];
        process.version = ''; // empty string to avoid regexp issues
        process.versions = {};

        function noop() {}

        process.on = noop;
        process.addListener = noop;
        process.once = noop;
        process.off = noop;
        process.removeListener = noop;
        process.removeAllListeners = noop;
        process.emit = noop;
        process.prependListener = noop;
        process.prependOnceListener = noop;

        process.listeners = function (name) { return [] }

        process.binding = function (name) {
            throw new Error('process.binding is not supported');
        };

        process.cwd = function () { return '/' };
        process.chdir = function (dir) {
            throw new Error('process.chdir is not supported');
        };
        process.umask = function() { return 0; };

    },{}],35:[function(require,module,exports){
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        /* Observable */
        var Observable_1 = require("./internal/Observable");
        exports.Observable = Observable_1.Observable;
        var ConnectableObservable_1 = require("./internal/observable/ConnectableObservable");
        exports.ConnectableObservable = ConnectableObservable_1.ConnectableObservable;
        var groupBy_1 = require("./internal/operators/groupBy");
        exports.GroupedObservable = groupBy_1.GroupedObservable;
        var observable_1 = require("./internal/symbol/observable");
        exports.observable = observable_1.observable;
        /* Subjects */
        var Subject_1 = require("./internal/Subject");
        exports.Subject = Subject_1.Subject;
        var BehaviorSubject_1 = require("./internal/BehaviorSubject");
        exports.BehaviorSubject = BehaviorSubject_1.BehaviorSubject;
        var ReplaySubject_1 = require("./internal/ReplaySubject");
        exports.ReplaySubject = ReplaySubject_1.ReplaySubject;
        var AsyncSubject_1 = require("./internal/AsyncSubject");
        exports.AsyncSubject = AsyncSubject_1.AsyncSubject;
        /* Schedulers */
        var asap_1 = require("./internal/scheduler/asap");
        exports.asapScheduler = asap_1.asap;
        var async_1 = require("./internal/scheduler/async");
        exports.asyncScheduler = async_1.async;
        var queue_1 = require("./internal/scheduler/queue");
        exports.queueScheduler = queue_1.queue;
        var animationFrame_1 = require("./internal/scheduler/animationFrame");
        exports.animationFrameScheduler = animationFrame_1.animationFrame;
        var VirtualTimeScheduler_1 = require("./internal/scheduler/VirtualTimeScheduler");
        exports.VirtualTimeScheduler = VirtualTimeScheduler_1.VirtualTimeScheduler;
        exports.VirtualAction = VirtualTimeScheduler_1.VirtualAction;
        var Scheduler_1 = require("./internal/Scheduler");
        exports.Scheduler = Scheduler_1.Scheduler;
        /* Subscription */
        var Subscription_1 = require("./internal/Subscription");
        exports.Subscription = Subscription_1.Subscription;
        var Subscriber_1 = require("./internal/Subscriber");
        exports.Subscriber = Subscriber_1.Subscriber;
        /* Notification */
        var Notification_1 = require("./internal/Notification");
        exports.Notification = Notification_1.Notification;
        /* Utils */
        var pipe_1 = require("./internal/util/pipe");
        exports.pipe = pipe_1.pipe;
        var noop_1 = require("./internal/util/noop");
        exports.noop = noop_1.noop;
        var identity_1 = require("./internal/util/identity");
        exports.identity = identity_1.identity;
        var isObservable_1 = require("./internal/util/isObservable");
        exports.isObservable = isObservable_1.isObservable;
        /* Error types */
        var ArgumentOutOfRangeError_1 = require("./internal/util/ArgumentOutOfRangeError");
        exports.ArgumentOutOfRangeError = ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;
        var EmptyError_1 = require("./internal/util/EmptyError");
        exports.EmptyError = EmptyError_1.EmptyError;
        var ObjectUnsubscribedError_1 = require("./internal/util/ObjectUnsubscribedError");
        exports.ObjectUnsubscribedError = ObjectUnsubscribedError_1.ObjectUnsubscribedError;
        var UnsubscriptionError_1 = require("./internal/util/UnsubscriptionError");
        exports.UnsubscriptionError = UnsubscriptionError_1.UnsubscriptionError;
        var TimeoutError_1 = require("./internal/util/TimeoutError");
        exports.TimeoutError = TimeoutError_1.TimeoutError;
        /* Static observable creation exports */
        var bindCallback_1 = require("./internal/observable/bindCallback");
        exports.bindCallback = bindCallback_1.bindCallback;
        var bindNodeCallback_1 = require("./internal/observable/bindNodeCallback");
        exports.bindNodeCallback = bindNodeCallback_1.bindNodeCallback;
        var combineLatest_1 = require("./internal/observable/combineLatest");
        exports.combineLatest = combineLatest_1.combineLatest;
        var concat_1 = require("./internal/observable/concat");
        exports.concat = concat_1.concat;
        var defer_1 = require("./internal/observable/defer");
        exports.defer = defer_1.defer;
        var empty_1 = require("./internal/observable/empty");
        exports.empty = empty_1.empty;
        var forkJoin_1 = require("./internal/observable/forkJoin");
        exports.forkJoin = forkJoin_1.forkJoin;
        var from_1 = require("./internal/observable/from");
        exports.from = from_1.from;
        var fromEvent_1 = require("./internal/observable/fromEvent");
        exports.fromEvent = fromEvent_1.fromEvent;
        var fromEventPattern_1 = require("./internal/observable/fromEventPattern");
        exports.fromEventPattern = fromEventPattern_1.fromEventPattern;
        var generate_1 = require("./internal/observable/generate");
        exports.generate = generate_1.generate;
        var iif_1 = require("./internal/observable/iif");
        exports.iif = iif_1.iif;
        var interval_1 = require("./internal/observable/interval");
        exports.interval = interval_1.interval;
        var merge_1 = require("./internal/observable/merge");
        exports.merge = merge_1.merge;
        var never_1 = require("./internal/observable/never");
        exports.never = never_1.never;
        var of_1 = require("./internal/observable/of");
        exports.of = of_1.of;
        var onErrorResumeNext_1 = require("./internal/observable/onErrorResumeNext");
        exports.onErrorResumeNext = onErrorResumeNext_1.onErrorResumeNext;
        var pairs_1 = require("./internal/observable/pairs");
        exports.pairs = pairs_1.pairs;
        var race_1 = require("./internal/observable/race");
        exports.race = race_1.race;
        var range_1 = require("./internal/observable/range");
        exports.range = range_1.range;
        var throwError_1 = require("./internal/observable/throwError");
        exports.throwError = throwError_1.throwError;
        var timer_1 = require("./internal/observable/timer");
        exports.timer = timer_1.timer;
        var using_1 = require("./internal/observable/using");
        exports.using = using_1.using;
        var zip_1 = require("./internal/observable/zip");
        exports.zip = zip_1.zip;
        /* Constants */
        var empty_2 = require("./internal/observable/empty");
        exports.EMPTY = empty_2.EMPTY;
        var never_2 = require("./internal/observable/never");
        exports.NEVER = never_2.NEVER;
        /* Config */
        var config_1 = require("./internal/config");
        exports.config = config_1.config;

    },{"./internal/AsyncSubject":36,"./internal/BehaviorSubject":37,"./internal/Notification":39,"./internal/Observable":40,"./internal/ReplaySubject":43,"./internal/Scheduler":44,"./internal/Subject":45,"./internal/Subscriber":47,"./internal/Subscription":48,"./internal/config":49,"./internal/observable/ConnectableObservable":50,"./internal/observable/bindCallback":51,"./internal/observable/bindNodeCallback":52,"./internal/observable/combineLatest":53,"./internal/observable/concat":54,"./internal/observable/defer":55,"./internal/observable/empty":56,"./internal/observable/forkJoin":57,"./internal/observable/from":58,"./internal/observable/fromEvent":60,"./internal/observable/fromEventPattern":61,"./internal/observable/generate":65,"./internal/observable/iif":66,"./internal/observable/interval":67,"./internal/observable/merge":68,"./internal/observable/never":69,"./internal/observable/of":70,"./internal/observable/onErrorResumeNext":71,"./internal/observable/pairs":72,"./internal/observable/race":73,"./internal/observable/range":74,"./internal/observable/throwError":76,"./internal/observable/timer":77,"./internal/observable/using":78,"./internal/observable/zip":79,"./internal/operators/groupBy":81,"./internal/scheduler/VirtualTimeScheduler":96,"./internal/scheduler/animationFrame":97,"./internal/scheduler/asap":98,"./internal/scheduler/async":99,"./internal/scheduler/queue":100,"./internal/symbol/observable":102,"./internal/util/ArgumentOutOfRangeError":104,"./internal/util/EmptyError":105,"./internal/util/ObjectUnsubscribedError":107,"./internal/util/TimeoutError":108,"./internal/util/UnsubscriptionError":109,"./internal/util/identity":112,"./internal/util/isObservable":120,"./internal/util/noop":123,"./internal/util/pipe":124}],36:[function(require,module,exports){
        "use strict";
        var __extends = (this && this.__extends) || (function () {
                    var extendStatics = Object.setPrototypeOf ||
                            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
                    return function (d, b) {
                        extendStatics(d, b);
                        function __() { this.constructor = d; }
                        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                    };
                })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var Subject_1 = require("./Subject");
        var Subscription_1 = require("./Subscription");
        /**
         * @class AsyncSubject<T>
         */
        var AsyncSubject = /** @class */ (function (_super) {
            __extends(AsyncSubject, _super);
            function AsyncSubject() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.value = null;
                _this.hasNext = false;
                _this.hasCompleted = false;
                return _this;
            }
            /** @deprecated This is an internal implementation detail, do not use. */
            AsyncSubject.prototype._subscribe = function (subscriber) {
                if (this.hasError) {
                    subscriber.error(this.thrownError);
                    return Subscription_1.Subscription.EMPTY;
                }
                else if (this.hasCompleted && this.hasNext) {
                    subscriber.next(this.value);
                    subscriber.complete();
                    return Subscription_1.Subscription.EMPTY;
                }
                return _super.prototype._subscribe.call(this, subscriber);
            };
            AsyncSubject.prototype.next = function (value) {
                if (!this.hasCompleted) {
                    this.value = value;
                    this.hasNext = true;
                }
            };
            AsyncSubject.prototype.error = function (error) {
                if (!this.hasCompleted) {
                    _super.prototype.error.call(this, error);
                }
            };
            AsyncSubject.prototype.complete = function () {
                this.hasCompleted = true;
                if (this.hasNext) {
                    _super.prototype.next.call(this, this.value);
                }
                _super.prototype.complete.call(this);
            };
            return AsyncSubject;
        }(Subject_1.Subject));
        exports.AsyncSubject = AsyncSubject;

    },{"./Subject":45,"./Subscription":48}],37:[function(require,module,exports){
        "use strict";
        var __extends = (this && this.__extends) || (function () {
                    var extendStatics = Object.setPrototypeOf ||
                            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
                    return function (d, b) {
                        extendStatics(d, b);
                        function __() { this.constructor = d; }
                        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                    };
                })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var Subject_1 = require("./Subject");
        var ObjectUnsubscribedError_1 = require("./util/ObjectUnsubscribedError");
        /**
         * @class BehaviorSubject<T>
         */
        var BehaviorSubject = /** @class */ (function (_super) {
            __extends(BehaviorSubject, _super);
            function BehaviorSubject(_value) {
                var _this = _super.call(this) || this;
                _this._value = _value;
                return _this;
            }
            Object.defineProperty(BehaviorSubject.prototype, "value", {
                get: function () {
                    return this.getValue();
                },
                enumerable: true,
                configurable: true
            });
            /** @deprecated This is an internal implementation detail, do not use. */
            BehaviorSubject.prototype._subscribe = function (subscriber) {
                var subscription = _super.prototype._subscribe.call(this, subscriber);
                if (subscription && !subscription.closed) {
                    subscriber.next(this._value);
                }
                return subscription;
            };
            BehaviorSubject.prototype.getValue = function () {
                if (this.hasError) {
                    throw this.thrownError;
                }
                else if (this.closed) {
                    throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
                }
                else {
                    return this._value;
                }
            };
            BehaviorSubject.prototype.next = function (value) {
                _super.prototype.next.call(this, this._value = value);
            };
            return BehaviorSubject;
        }(Subject_1.Subject));
        exports.BehaviorSubject = BehaviorSubject;

    },{"./Subject":45,"./util/ObjectUnsubscribedError":107}],38:[function(require,module,exports){
        "use strict";
        var __extends = (this && this.__extends) || (function () {
                    var extendStatics = Object.setPrototypeOf ||
                            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
                    return function (d, b) {
                        extendStatics(d, b);
                        function __() { this.constructor = d; }
                        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                    };
                })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var Subscriber_1 = require("./Subscriber");
        /**
         * We need this JSDoc comment for affecting ESDoc.
         * @ignore
         * @extends {Ignored}
         */
        var InnerSubscriber = /** @class */ (function (_super) {
            __extends(InnerSubscriber, _super);
            function InnerSubscriber(parent, outerValue, outerIndex) {
                var _this = _super.call(this) || this;
                _this.parent = parent;
                _this.outerValue = outerValue;
                _this.outerIndex = outerIndex;
                _this.index = 0;
                return _this;
            }
            InnerSubscriber.prototype._next = function (value) {
                this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);
            };
            InnerSubscriber.prototype._error = function (error) {
                this.parent.notifyError(error, this);
                this.unsubscribe();
            };
            InnerSubscriber.prototype._complete = function () {
                this.parent.notifyComplete(this);
                this.unsubscribe();
            };
            return InnerSubscriber;
        }(Subscriber_1.Subscriber));
        exports.InnerSubscriber = InnerSubscriber;

    },{"./Subscriber":47}],39:[function(require,module,exports){
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var empty_1 = require("./observable/empty");
        var of_1 = require("./observable/of");
        var throwError_1 = require("./observable/throwError");
        /**
         * Represents a push-based event or value that an {@link Observable} can emit.
         * This class is particularly useful for operators that manage notifications,
         * like {@link materialize}, {@link dematerialize}, {@link observeOn}, and
         * others. Besides wrapping the actual delivered value, it also annotates it
         * with metadata of, for instance, what type of push message it is (`next`,
         * `error`, or `complete`).
         *
         * @see {@link materialize}
         * @see {@link dematerialize}
         * @see {@link observeOn}
         *
         * @class Notification<T>
         */
        var Notification = /** @class */ (function () {
            function Notification(kind, value, error) {
                this.kind = kind;
                this.value = value;
                this.error = error;
                this.hasValue = kind === 'N';
            }
            /**
             * Delivers to the given `observer` the value wrapped by this Notification.
             * @param {Observer} observer
             * @return
             */
            Notification.prototype.observe = function (observer) {
                switch (this.kind) {
                    case 'N':
                        return observer.next && observer.next(this.value);
                    case 'E':
                        return observer.error && observer.error(this.error);
                    case 'C':
                        return observer.complete && observer.complete();
                }
            };
            /**
             * Given some {@link Observer} callbacks, deliver the value represented by the
             * current Notification to the correctly corresponding callback.
             * @param {function(value: T): void} next An Observer `next` callback.
             * @param {function(err: any): void} [error] An Observer `error` callback.
             * @param {function(): void} [complete] An Observer `complete` callback.
             * @return {any}
             */
            Notification.prototype.do = function (next, error, complete) {
                var kind = this.kind;
                switch (kind) {
                    case 'N':
                        return next && next(this.value);
                    case 'E':
                        return error && error(this.error);
                    case 'C':
                        return complete && complete();
                }
            };
            /**
             * Takes an Observer or its individual callback functions, and calls `observe`
             * or `do` methods accordingly.
             * @param {Observer|function(value: T): void} nextOrObserver An Observer or
             * the `next` callback.
             * @param {function(err: any): void} [error] An Observer `error` callback.
             * @param {function(): void} [complete] An Observer `complete` callback.
             * @return {any}
             */
            Notification.prototype.accept = function (nextOrObserver, error, complete) {
                if (nextOrObserver && typeof nextOrObserver.next === 'function') {
                    return this.observe(nextOrObserver);
                }
                else {
                    return this.do(nextOrObserver, error, complete);
                }
            };
            /**
             * Returns a simple Observable that just delivers the notification represented
             * by this Notification instance.
             * @return {any}
             */
            Notification.prototype.toObservable = function () {
                var kind = this.kind;
                switch (kind) {
                    case 'N':
                        return of_1.of(this.value);
                    case 'E':
                        return throwError_1.throwError(this.error);
                    case 'C':
                        return empty_1.empty();
                }
                throw new Error('unexpected notification kind value');
            };
            /**
             * A shortcut to create a Notification instance of the type `next` from a
             * given value.
             * @param {T} value The `next` value.
             * @return {Notification<T>} The "next" Notification representing the
             * argument.
             * @nocollapse
             */
            Notification.createNext = function (value) {
                if (typeof value !== 'undefined') {
                    return new Notification('N', value);
                }
                return Notification.undefinedValueNotification;
            };
            /**
             * A shortcut to create a Notification instance of the type `error` from a
             * given error.
             * @param {any} [err] The `error` error.
             * @return {Notification<T>} The "error" Notification representing the
             * argument.
             * @nocollapse
             */
            Notification.createError = function (err) {
                return new Notification('E', undefined, err);
            };
            /**
             * A shortcut to create a Notification instance of the type `complete`.
             * @return {Notification<any>} The valueless "complete" Notification.
             * @nocollapse
             */
            Notification.createComplete = function () {
                return Notification.completeNotification;
            };
            Notification.completeNotification = new Notification('C');
            Notification.undefinedValueNotification = new Notification('N', undefined);
            return Notification;
        }());
        exports.Notification = Notification;

    },{"./observable/empty":56,"./observable/of":70,"./observable/throwError":76}],40:[function(require,module,exports){
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var toSubscriber_1 = require("./util/toSubscriber");
        var observable_1 = require("../internal/symbol/observable");
        var pipe_1 = require("./util/pipe");
        var config_1 = require("./config");
        /**
         * A representation of any set of values over any amount of time. This is the most basic building block
         * of RxJS.
         *
         * @class Observable<T>
         */
        var Observable = /** @class */ (function () {
            /**
             * @constructor
             * @param {Function} subscribe the function that is called when the Observable is
             * initially subscribed to. This function is given a Subscriber, to which new values
             * can be `next`ed, or an `error` method can be called to raise an error, or
             * `complete` can be called to notify of a successful completion.
             */
            function Observable(subscribe) {
                /** Internal implementation detail, do not use directly. */
                this._isScalar = false;
                if (subscribe) {
                    this._subscribe = subscribe;
                }
            }
            /**
             * Creates a new Observable, with this Observable as the source, and the passed
             * operator defined as the new observable's operator.
             * @method lift
             * @param {Operator} operator the operator defining the operation to take on the observable
             * @return {Observable} a new observable with the Operator applied
             */
            Observable.prototype.lift = function (operator) {
                var observable = new Observable();
                observable.source = this;
                observable.operator = operator;
                return observable;
            };
            /**
             * Invokes an execution of an Observable and registers Observer handlers for notifications it will emit.
             *
             * <span class="informal">Use it when you have all these Observables, but still nothing is happening.</span>
             *
             * `subscribe` is not a regular operator, but a method that calls Observable's internal `subscribe` function. It
             * might be for example a function that you passed to a {@link create} static factory, but most of the time it is
             * a library implementation, which defines what and when will be emitted by an Observable. This means that calling
             * `subscribe` is actually the moment when Observable starts its work, not when it is created, as it is often
             * thought.
             *
             * Apart from starting the execution of an Observable, this method allows you to listen for values
             * that an Observable emits, as well as for when it completes or errors. You can achieve this in two
             * following ways.
             *
             * The first way is creating an object that implements {@link Observer} interface. It should have methods
             * defined by that interface, but note that it should be just a regular JavaScript object, which you can create
             * yourself in any way you want (ES6 class, classic function constructor, object literal etc.). In particular do
             * not attempt to use any RxJS implementation details to create Observers - you don't need them. Remember also
             * that your object does not have to implement all methods. If you find yourself creating a method that doesn't
             * do anything, you can simply omit it. Note however, that if `error` method is not provided, all errors will
             * be left uncaught.
             *
             * The second way is to give up on Observer object altogether and simply provide callback functions in place of its methods.
             * This means you can provide three functions as arguments to `subscribe`, where first function is equivalent
             * of a `next` method, second of an `error` method and third of a `complete` method. Just as in case of Observer,
             * if you do not need to listen for something, you can omit a function, preferably by passing `undefined` or `null`,
             * since `subscribe` recognizes these functions by where they were placed in function call. When it comes
             * to `error` function, just as before, if not provided, errors emitted by an Observable will be thrown.
             *
             * Whatever style of calling `subscribe` you use, in both cases it returns a Subscription object.
             * This object allows you to call `unsubscribe` on it, which in turn will stop work that an Observable does and will clean
             * up all resources that an Observable used. Note that cancelling a subscription will not call `complete` callback
             * provided to `subscribe` function, which is reserved for a regular completion signal that comes from an Observable.
             *
             * Remember that callbacks provided to `subscribe` are not guaranteed to be called asynchronously.
             * It is an Observable itself that decides when these functions will be called. For example {@link of}
             * by default emits all its values synchronously. Always check documentation for how given Observable
             * will behave when subscribed and if its default behavior can be modified with a {@link Scheduler}.
             *
             * @example <caption>Subscribe with an Observer</caption>
             * const sumObserver = {
     *   sum: 0,
     *   next(value) {
     *     console.log('Adding: ' + value);
     *     this.sum = this.sum + value;
     *   },
     *   error() { // We actually could just remove this method,
     *   },        // since we do not really care about errors right now.
     *   complete() {
     *     console.log('Sum equals: ' + this.sum);
     *   }
     * };
             *
             * Rx.Observable.of(1, 2, 3) // Synchronously emits 1, 2, 3 and then completes.
             * .subscribe(sumObserver);
             *
             * // Logs:
             * // "Adding: 1"
             * // "Adding: 2"
             * // "Adding: 3"
             * // "Sum equals: 6"
             *
             *
             * @example <caption>Subscribe with functions</caption>
             * let sum = 0;
             *
             * Rx.Observable.of(1, 2, 3)
             * .subscribe(
             *   function(value) {
     *     console.log('Adding: ' + value);
     *     sum = sum + value;
     *   },
             *   undefined,
             *   function() {
     *     console.log('Sum equals: ' + sum);
     *   }
             * );
             *
             * // Logs:
             * // "Adding: 1"
             * // "Adding: 2"
             * // "Adding: 3"
             * // "Sum equals: 6"
             *
             *
             * @example <caption>Cancel a subscription</caption>
             * const subscription = Rx.Observable.interval(1000).subscribe(
             *   num => console.log(num),
             *   undefined,
             *   () => console.log('completed!') // Will not be called, even
             * );                                // when cancelling subscription
             *
             *
             * setTimeout(() => {
     *   subscription.unsubscribe();
     *   console.log('unsubscribed!');
     * }, 2500);
             *
             * // Logs:
             * // 0 after 1s
             * // 1 after 2s
             * // "unsubscribed!" after 2.5s
             *
             *
             * @param {Observer|Function} observerOrNext (optional) Either an observer with methods to be called,
             *  or the first of three possible handlers, which is the handler for each value emitted from the subscribed
             *  Observable.
             * @param {Function} error (optional) A handler for a terminal event resulting from an error. If no error handler is provided,
             *  the error will be thrown as unhandled.
             * @param {Function} complete (optional) A handler for a terminal event resulting from successful completion.
             * @return {ISubscription} a subscription reference to the registered handlers
             * @method subscribe
             */
            Observable.prototype.subscribe = function (observerOrNext, error, complete) {
                var operator = this.operator;
                var sink = toSubscriber_1.toSubscriber(observerOrNext, error, complete);
                if (operator) {
                    operator.call(sink, this.source);
                }
                else {
                    sink.add(this.source || !sink.syncErrorThrowable ? this._subscribe(sink) : this._trySubscribe(sink));
                }
                if (config_1.config.useDeprecatedSynchronousErrorHandling) {
                    if (sink.syncErrorThrowable) {
                        sink.syncErrorThrowable = false;
                        if (sink.syncErrorThrown) {
                            throw sink.syncErrorValue;
                        }
                    }
                }
                return sink;
            };
            /** @deprecated This is an internal implementation detail, do not use. */
            Observable.prototype._trySubscribe = function (sink) {
                try {
                    return this._subscribe(sink);
                }
                catch (err) {
                    if (config_1.config.useDeprecatedSynchronousErrorHandling) {
                        sink.syncErrorThrown = true;
                        sink.syncErrorValue = err;
                    }
                    sink.error(err);
                }
            };
            /**
             * @method forEach
             * @param {Function} next a handler for each value emitted by the observable
             * @param {PromiseConstructor} [promiseCtor] a constructor function used to instantiate the Promise
             * @return {Promise} a promise that either resolves on observable completion or
             *  rejects with the handled error
             */
            Observable.prototype.forEach = function (next, promiseCtor) {
                var _this = this;
                promiseCtor = getPromiseCtor(promiseCtor);
                return new promiseCtor(function (resolve, reject) {
                    // Must be declared in a separate statement to avoid a RefernceError when
                    // accessing subscription below in the closure due to Temporal Dead Zone.
                    var subscription;
                    subscription = _this.subscribe(function (value) {
                        try {
                            next(value);
                        }
                        catch (err) {
                            reject(err);
                            if (subscription) {
                                subscription.unsubscribe();
                            }
                        }
                    }, reject, resolve);
                });
            };
            /** @deprecated This is an internal implementation detail, do not use. */
            Observable.prototype._subscribe = function (subscriber) {
                var source = this.source;
                return source && source.subscribe(subscriber);
            };
            /**
             * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable
             * @method Symbol.observable
             * @return {Observable} this instance of the observable
             */
            Observable.prototype[observable_1.observable] = function () {
                return this;
            };
            /* tslint:enable:max-line-length */
            /**
             * Used to stitch together functional operators into a chain.
             * @method pipe
             * @return {Observable} the Observable result of all of the operators having
             * been called in the order they were passed in.
             *
             * @example
             *
             * import { map, filter, scan } from 'rxjs/operators';
             *
             * Rx.Observable.interval(1000)
             *   .pipe(
             *     filter(x => x % 2 === 0),
             *     map(x => x + x),
             *     scan((acc, x) => acc + x)
             *   )
             *   .subscribe(x => console.log(x))
             */
            Observable.prototype.pipe = function () {
                var operations = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    operations[_i] = arguments[_i];
                }
                if (operations.length === 0) {
                    return this;
                }
                return pipe_1.pipeFromArray(operations)(this);
            };
            /* tslint:enable:max-line-length */
            Observable.prototype.toPromise = function (promiseCtor) {
                var _this = this;
                promiseCtor = getPromiseCtor(promiseCtor);
                return new promiseCtor(function (resolve, reject) {
                    var value;
                    _this.subscribe(function (x) { return value = x; }, function (err) { return reject(err); }, function () { return resolve(value); });
                });
            };
            // HACK: Since TypeScript inherits static properties too, we have to
            // fight against TypeScript here so Subject can have a different static create signature
            /**
             * Creates a new cold Observable by calling the Observable constructor
             * @static true
             * @owner Observable
             * @method create
             * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor
             * @return {Observable} a new cold observable
             * @nocollapse
             */
            Observable.create = function (subscribe) {
                return new Observable(subscribe);
            };
            return Observable;
        }());
        exports.Observable = Observable;
        /**
         * Decides between a passed promise constructor from consuming code,
         * A default configured promise constructor, and the native promise
         * constructor and returns it. If nothing can be found, it will throw
         * an error.
         * @param promiseCtor The optional promise constructor to passed by consuming code
         */
        function getPromiseCtor(promiseCtor) {
            if (!promiseCtor) {
                promiseCtor = config_1.config.Promise || Promise;
            }
            if (!promiseCtor) {
                throw new Error('no Promise impl found');
            }
            return promiseCtor;
        }

    },{"../internal/symbol/observable":102,"./config":49,"./util/pipe":124,"./util/toSubscriber":131}],41:[function(require,module,exports){
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var config_1 = require("./config");
        var hostReportError_1 = require("./util/hostReportError");
        exports.empty = {
            closed: true,
            next: function (value) { },
            error: function (err) {
                if (config_1.config.useDeprecatedSynchronousErrorHandling) {
                    throw err;
                }
                else {
                    hostReportError_1.hostReportError(err);
                }
            },
            complete: function () { }
        };

    },{"./config":49,"./util/hostReportError":111}],42:[function(require,module,exports){
        "use strict";
        var __extends = (this && this.__extends) || (function () {
                    var extendStatics = Object.setPrototypeOf ||
                            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
                    return function (d, b) {
                        extendStatics(d, b);
                        function __() { this.constructor = d; }
                        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                    };
                })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var Subscriber_1 = require("./Subscriber");
        /**
         * We need this JSDoc comment for affecting ESDoc.
         * @ignore
         * @extends {Ignored}
         */
        var OuterSubscriber = /** @class */ (function (_super) {
            __extends(OuterSubscriber, _super);
            function OuterSubscriber() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            OuterSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
                this.destination.next(innerValue);
            };
            OuterSubscriber.prototype.notifyError = function (error, innerSub) {
                this.destination.error(error);
            };
            OuterSubscriber.prototype.notifyComplete = function (innerSub) {
                this.destination.complete();
            };
            return OuterSubscriber;
        }(Subscriber_1.Subscriber));
        exports.OuterSubscriber = OuterSubscriber;

    },{"./Subscriber":47}],43:[function(require,module,exports){
        "use strict";
        var __extends = (this && this.__extends) || (function () {
                    var extendStatics = Object.setPrototypeOf ||
                            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
                    return function (d, b) {
                        extendStatics(d, b);
                        function __() { this.constructor = d; }
                        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                    };
                })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var Subject_1 = require("./Subject");
        var queue_1 = require("./scheduler/queue");
        var Subscription_1 = require("./Subscription");
        var observeOn_1 = require("./operators/observeOn");
        var ObjectUnsubscribedError_1 = require("./util/ObjectUnsubscribedError");
        var SubjectSubscription_1 = require("./SubjectSubscription");
        /**
         * @class ReplaySubject<T>
         */
        var ReplaySubject = /** @class */ (function (_super) {
            __extends(ReplaySubject, _super);
            function ReplaySubject(bufferSize, windowTime, scheduler) {
                if (bufferSize === void 0) { bufferSize = Number.POSITIVE_INFINITY; }
                if (windowTime === void 0) { windowTime = Number.POSITIVE_INFINITY; }
                var _this = _super.call(this) || this;
                _this.scheduler = scheduler;
                _this._events = [];
                _this._infiniteTimeWindow = false;
                _this._bufferSize = bufferSize < 1 ? 1 : bufferSize;
                _this._windowTime = windowTime < 1 ? 1 : windowTime;
                if (windowTime === Number.POSITIVE_INFINITY) {
                    _this._infiniteTimeWindow = true;
                    _this.next = _this.nextInfiniteTimeWindow;
                }
                else {
                    _this.next = _this.nextTimeWindow;
                }
                return _this;
            }
            ReplaySubject.prototype.nextInfiniteTimeWindow = function (value) {
                var _events = this._events;
                _events.push(value);
                // Since this method is invoked in every next() call than the buffer
                // can overgrow the max size only by one item
                if (_events.length > this._bufferSize) {
                    _events.shift();
                }
                _super.prototype.next.call(this, value);
            };
            ReplaySubject.prototype.nextTimeWindow = function (value) {
                this._events.push(new ReplayEvent(this._getNow(), value));
                this._trimBufferThenGetEvents();
                _super.prototype.next.call(this, value);
            };
            /** @deprecated This is an internal implementation detail, do not use. */
            ReplaySubject.prototype._subscribe = function (subscriber) {
                // When `_infiniteTimeWindow === true` then the buffer is already trimmed
                var _infiniteTimeWindow = this._infiniteTimeWindow;
                var _events = _infiniteTimeWindow ? this._events : this._trimBufferThenGetEvents();
                var scheduler = this.scheduler;
                var len = _events.length;
                var subscription;
                if (this.closed) {
                    throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
                }
                else if (this.isStopped || this.hasError) {
                    subscription = Subscription_1.Subscription.EMPTY;
                }
                else {
                    this.observers.push(subscriber);
                    subscription = new SubjectSubscription_1.SubjectSubscription(this, subscriber);
                }
                if (scheduler) {
                    subscriber.add(subscriber = new observeOn_1.ObserveOnSubscriber(subscriber, scheduler));
                }
                if (_infiniteTimeWindow) {
                    for (var i = 0; i < len && !subscriber.closed; i++) {
                        subscriber.next(_events[i]);
                    }
                }
                else {
                    for (var i = 0; i < len && !subscriber.closed; i++) {
                        subscriber.next(_events[i].value);
                    }
                }
                if (this.hasError) {
                    subscriber.error(this.thrownError);
                }
                else if (this.isStopped) {
                    subscriber.complete();
                }
                return subscription;
            };
            ReplaySubject.prototype._getNow = function () {
                return (this.scheduler || queue_1.queue).now();
            };
            ReplaySubject.prototype._trimBufferThenGetEvents = function () {
                var now = this._getNow();
                var _bufferSize = this._bufferSize;
                var _windowTime = this._windowTime;
                var _events = this._events;
                var eventsCount = _events.length;
                var spliceCount = 0;
                // Trim events that fall out of the time window.
                // Start at the front of the list. Break early once
                // we encounter an event that falls within the window.
                while (spliceCount < eventsCount) {
                    if ((now - _events[spliceCount].time) < _windowTime) {
                        break;
                    }
                    spliceCount++;
                }
                if (eventsCount > _bufferSize) {
                    spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);
                }
                if (spliceCount > 0) {
                    _events.splice(0, spliceCount);
                }
                return _events;
            };
            return ReplaySubject;
        }(Subject_1.Subject));
        exports.ReplaySubject = ReplaySubject;
        var ReplayEvent = /** @class */ (function () {
            function ReplayEvent(time, value) {
                this.time = time;
                this.value = value;
            }
            return ReplayEvent;
        }());

    },{"./Subject":45,"./SubjectSubscription":46,"./Subscription":48,"./operators/observeOn":85,"./scheduler/queue":100,"./util/ObjectUnsubscribedError":107}],44:[function(require,module,exports){
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        /**
         * An execution context and a data structure to order tasks and schedule their
         * execution. Provides a notion of (potentially virtual) time, through the
         * `now()` getter method.
         *
         * Each unit of work in a Scheduler is called an {@link Action}.
         *
         * ```ts
         * class Scheduler {
 *   now(): number;
 *   schedule(work, delay?, state?): Subscription;
 * }
         * ```
         *
         * @class Scheduler
         * @deprecated Scheduler is an internal implementation detail of RxJS, and
         * should not be used directly. Rather, create your own class and implement
         * {@link SchedulerLike}
         */
        var Scheduler = /** @class */ (function () {
            function Scheduler(SchedulerAction, now) {
                if (now === void 0) { now = Scheduler.now; }
                this.SchedulerAction = SchedulerAction;
                this.now = now;
            }
            /**
             * Schedules a function, `work`, for execution. May happen at some point in
             * the future, according to the `delay` parameter, if specified. May be passed
             * some context object, `state`, which will be passed to the `work` function.
             *
             * The given arguments will be processed an stored as an Action object in a
             * queue of actions.
             *
             * @param {function(state: ?T): ?Subscription} work A function representing a
             * task, or some unit of work to be executed by the Scheduler.
             * @param {number} [delay] Time to wait before executing the work, where the
             * time unit is implicit and defined by the Scheduler itself.
             * @param {T} [state] Some contextual data that the `work` function uses when
             * called by the Scheduler.
             * @return {Subscription} A subscription in order to be able to unsubscribe
             * the scheduled work.
             */
            Scheduler.prototype.schedule = function (work, delay, state) {
                if (delay === void 0) { delay = 0; }
                return new this.SchedulerAction(this, work).schedule(state, delay);
            };
            /** @nocollapse */
            Scheduler.now = Date.now ? Date.now : function () { return +new Date(); };
            return Scheduler;
        }());
        exports.Scheduler = Scheduler;

    },{}],45:[function(require,module,exports){
        "use strict";
        var __extends = (this && this.__extends) || (function () {
                    var extendStatics = Object.setPrototypeOf ||
                            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
                    return function (d, b) {
                        extendStatics(d, b);
                        function __() { this.constructor = d; }
                        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                    };
                })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var Observable_1 = require("./Observable");
        var Subscriber_1 = require("./Subscriber");
        var Subscription_1 = require("./Subscription");
        var ObjectUnsubscribedError_1 = require("./util/ObjectUnsubscribedError");
        var SubjectSubscription_1 = require("./SubjectSubscription");
        var rxSubscriber_1 = require("../internal/symbol/rxSubscriber");
        /**
         * @class SubjectSubscriber<T>
         */
        var SubjectSubscriber = /** @class */ (function (_super) {
            __extends(SubjectSubscriber, _super);
            function SubjectSubscriber(destination) {
                var _this = _super.call(this, destination) || this;
                _this.destination = destination;
                return _this;
            }
            return SubjectSubscriber;
        }(Subscriber_1.Subscriber));
        exports.SubjectSubscriber = SubjectSubscriber;
        /**
         * @class Subject<T>
         */
        var Subject = /** @class */ (function (_super) {
            __extends(Subject, _super);
            function Subject() {
                var _this = _super.call(this) || this;
                _this.observers = [];
                _this.closed = false;
                _this.isStopped = false;
                _this.hasError = false;
                _this.thrownError = null;
                return _this;
            }
            Subject.prototype[rxSubscriber_1.rxSubscriber] = function () {
                return new SubjectSubscriber(this);
            };
            Subject.prototype.lift = function (operator) {
                var subject = new AnonymousSubject(this, this);
                subject.operator = operator;
                return subject;
            };
            Subject.prototype.next = function (value) {
                if (this.closed) {
                    throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
                }
                if (!this.isStopped) {
                    var observers = this.observers;
                    var len = observers.length;
                    var copy = observers.slice();
                    for (var i = 0; i < len; i++) {
                        copy[i].next(value);
                    }
                }
            };
            Subject.prototype.error = function (err) {
                if (this.closed) {
                    throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
                }
                this.hasError = true;
                this.thrownError = err;
                this.isStopped = true;
                var observers = this.observers;
                var len = observers.length;
                var copy = observers.slice();
                for (var i = 0; i < len; i++) {
                    copy[i].error(err);
                }
                this.observers.length = 0;
            };
            Subject.prototype.complete = function () {
                if (this.closed) {
                    throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
                }
                this.isStopped = true;
                var observers = this.observers;
                var len = observers.length;
                var copy = observers.slice();
                for (var i = 0; i < len; i++) {
                    copy[i].complete();
                }
                this.observers.length = 0;
            };
            Subject.prototype.unsubscribe = function () {
                this.isStopped = true;
                this.closed = true;
                this.observers = null;
            };
            /** @deprecated This is an internal implementation detail, do not use. */
            Subject.prototype._trySubscribe = function (subscriber) {
                if (this.closed) {
                    throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
                }
                else {
                    return _super.prototype._trySubscribe.call(this, subscriber);
                }
            };
            /** @deprecated This is an internal implementation detail, do not use. */
            Subject.prototype._subscribe = function (subscriber) {
                if (this.closed) {
                    throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
                }
                else if (this.hasError) {
                    subscriber.error(this.thrownError);
                    return Subscription_1.Subscription.EMPTY;
                }
                else if (this.isStopped) {
                    subscriber.complete();
                    return Subscription_1.Subscription.EMPTY;
                }
                else {
                    this.observers.push(subscriber);
                    return new SubjectSubscription_1.SubjectSubscription(this, subscriber);
                }
            };
            Subject.prototype.asObservable = function () {
                var observable = new Observable_1.Observable();
                observable.source = this;
                return observable;
            };
            /**@nocollapse */
            Subject.create = function (destination, source) {
                return new AnonymousSubject(destination, source);
            };
            return Subject;
        }(Observable_1.Observable));
        exports.Subject = Subject;
        /**
         * @class AnonymousSubject<T>
         */
        var AnonymousSubject = /** @class */ (function (_super) {
            __extends(AnonymousSubject, _super);
            function AnonymousSubject(destination, source) {
                var _this = _super.call(this) || this;
                _this.destination = destination;
                _this.source = source;
                return _this;
            }
            AnonymousSubject.prototype.next = function (value) {
                var destination = this.destination;
                if (destination && destination.next) {
                    destination.next(value);
                }
            };
            AnonymousSubject.prototype.error = function (err) {
                var destination = this.destination;
                if (destination && destination.error) {
                    this.destination.error(err);
                }
            };
            AnonymousSubject.prototype.complete = function () {
                var destination = this.destination;
                if (destination && destination.complete) {
                    this.destination.complete();
                }
            };
            /** @deprecated This is an internal implementation detail, do not use. */
            AnonymousSubject.prototype._subscribe = function (subscriber) {
                var source = this.source;
                if (source) {
                    return this.source.subscribe(subscriber);
                }
                else {
                    return Subscription_1.Subscription.EMPTY;
                }
            };
            return AnonymousSubject;
        }(Subject));
        exports.AnonymousSubject = AnonymousSubject;

    },{"../internal/symbol/rxSubscriber":103,"./Observable":40,"./SubjectSubscription":46,"./Subscriber":47,"./Subscription":48,"./util/ObjectUnsubscribedError":107}],46:[function(require,module,exports){
        "use strict";
        var __extends = (this && this.__extends) || (function () {
                    var extendStatics = Object.setPrototypeOf ||
                            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
                    return function (d, b) {
                        extendStatics(d, b);
                        function __() { this.constructor = d; }
                        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                    };
                })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var Subscription_1 = require("./Subscription");
        /**
         * We need this JSDoc comment for affecting ESDoc.
         * @ignore
         * @extends {Ignored}
         */
        var SubjectSubscription = /** @class */ (function (_super) {
            __extends(SubjectSubscription, _super);
            function SubjectSubscription(subject, subscriber) {
                var _this = _super.call(this) || this;
                _this.subject = subject;
                _this.subscriber = subscriber;
                _this.closed = false;
                return _this;
            }
            SubjectSubscription.prototype.unsubscribe = function () {
                if (this.closed) {
                    return;
                }
                this.closed = true;
                var subject = this.subject;
                var observers = subject.observers;
                this.subject = null;
                if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {
                    return;
                }
                var subscriberIndex = observers.indexOf(this.subscriber);
                if (subscriberIndex !== -1) {
                    observers.splice(subscriberIndex, 1);
                }
            };
            return SubjectSubscription;
        }(Subscription_1.Subscription));
        exports.SubjectSubscription = SubjectSubscription;

    },{"./Subscription":48}],47:[function(require,module,exports){
        "use strict";
        var __extends = (this && this.__extends) || (function () {
                    var extendStatics = Object.setPrototypeOf ||
                            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
                    return function (d, b) {
                        extendStatics(d, b);
                        function __() { this.constructor = d; }
                        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                    };
                })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var isFunction_1 = require("./util/isFunction");
        var Observer_1 = require("./Observer");
        var Subscription_1 = require("./Subscription");
        var rxSubscriber_1 = require("../internal/symbol/rxSubscriber");
        var config_1 = require("./config");
        var hostReportError_1 = require("./util/hostReportError");
        /**
         * Implements the {@link Observer} interface and extends the
         * {@link Subscription} class. While the {@link Observer} is the public API for
         * consuming the values of an {@link Observable}, all Observers get converted to
         * a Subscriber, in order to provide Subscription-like capabilities such as
         * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for
         * implementing operators, but it is rarely used as a public API.
         *
         * @class Subscriber<T>
         */
        var Subscriber = /** @class */ (function (_super) {
            __extends(Subscriber, _super);
            /**
             * @param {Observer|function(value: T): void} [destinationOrNext] A partially
             * defined Observer or a `next` callback function.
             * @param {function(e: ?any): void} [error] The `error` callback of an
             * Observer.
             * @param {function(): void} [complete] The `complete` callback of an
             * Observer.
             */
            function Subscriber(destinationOrNext, error, complete) {
                var _this = _super.call(this) || this;
                /** @internal */ _this.syncErrorValue = null;
                /** @internal */ _this.syncErrorThrown = false;
                /** @internal */ _this.syncErrorThrowable = false;
                _this.isStopped = false;
                switch (arguments.length) {
                    case 0:
                        _this.destination = Observer_1.empty;
                        break;
                    case 1:
                        if (!destinationOrNext) {
                            _this.destination = Observer_1.empty;
                            break;
                        }
                        if (typeof destinationOrNext === 'object') {
                            // HACK(benlesh): For situations where Node has multiple copies of rxjs in
                            // node_modules, we cannot rely on `instanceof` checks
                            if (isTrustedSubscriber(destinationOrNext)) {
                                var trustedSubscriber = destinationOrNext[rxSubscriber_1.rxSubscriber]();
                                _this.syncErrorThrowable = trustedSubscriber.syncErrorThrowable;
                                _this.destination = trustedSubscriber;
                                trustedSubscriber.add(_this);
                            }
                            else {
                                _this.syncErrorThrowable = true;
                                _this.destination = new SafeSubscriber(_this, destinationOrNext);
                            }
                            break;
                        }
                    default:
                        _this.syncErrorThrowable = true;
                        _this.destination = new SafeSubscriber(_this, destinationOrNext, error, complete);
                        break;
                }
                return _this;
            }
            Subscriber.prototype[rxSubscriber_1.rxSubscriber] = function () { return this; };
            /**
             * A static factory for a Subscriber, given a (potentially partial) definition
             * of an Observer.
             * @param {function(x: ?T): void} [next] The `next` callback of an Observer.
             * @param {function(e: ?any): void} [error] The `error` callback of an
             * Observer.
             * @param {function(): void} [complete] The `complete` callback of an
             * Observer.
             * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)
             * Observer represented by the given arguments.
             * @nocollapse
             */
            Subscriber.create = function (next, error, complete) {
                var subscriber = new Subscriber(next, error, complete);
                subscriber.syncErrorThrowable = false;
                return subscriber;
            };
            /**
             * The {@link Observer} callback to receive notifications of type `next` from
             * the Observable, with a value. The Observable may call this method 0 or more
             * times.
             * @param {T} [value] The `next` value.
             * @return {void}
             */
            Subscriber.prototype.next = function (value) {
                if (!this.isStopped) {
                    this._next(value);
                }
            };
            /**
             * The {@link Observer} callback to receive notifications of type `error` from
             * the Observable, with an attached {@link Error}. Notifies the Observer that
             * the Observable has experienced an error condition.
             * @param {any} [err] The `error` exception.
             * @return {void}
             */
            Subscriber.prototype.error = function (err) {
                if (!this.isStopped) {
                    this.isStopped = true;
                    this._error(err);
                }
            };
            /**
             * The {@link Observer} callback to receive a valueless notification of type
             * `complete` from the Observable. Notifies the Observer that the Observable
             * has finished sending push-based notifications.
             * @return {void}
             */
            Subscriber.prototype.complete = function () {
                if (!this.isStopped) {
                    this.isStopped = true;
                    this._complete();
                }
            };
            Subscriber.prototype.unsubscribe = function () {
                if (this.closed) {
                    return;
                }
                this.isStopped = true;
                _super.prototype.unsubscribe.call(this);
            };
            Subscriber.prototype._next = function (value) {
                this.destination.next(value);
            };
            Subscriber.prototype._error = function (err) {
                this.destination.error(err);
                this.unsubscribe();
            };
            Subscriber.prototype._complete = function () {
                this.destination.complete();
                this.unsubscribe();
            };
            /** @deprecated This is an internal implementation detail, do not use. */
            Subscriber.prototype._unsubscribeAndRecycle = function () {
                var _a = this, _parent = _a._parent, _parents = _a._parents;
                this._parent = null;
                this._parents = null;
                this.unsubscribe();
                this.closed = false;
                this.isStopped = false;
                this._parent = _parent;
                this._parents = _parents;
                return this;
            };
            return Subscriber;
        }(Subscription_1.Subscription));
        exports.Subscriber = Subscriber;
        /**
         * We need this JSDoc comment for affecting ESDoc.
         * @ignore
         * @extends {Ignored}
         */
        var SafeSubscriber = /** @class */ (function (_super) {
            __extends(SafeSubscriber, _super);
            function SafeSubscriber(_parentSubscriber, observerOrNext, error, complete) {
                var _this = _super.call(this) || this;
                _this._parentSubscriber = _parentSubscriber;
                var next;
                var context = _this;
                if (isFunction_1.isFunction(observerOrNext)) {
                    next = observerOrNext;
                }
                else if (observerOrNext) {
                    next = observerOrNext.next;
                    error = observerOrNext.error;
                    complete = observerOrNext.complete;
                    if (observerOrNext !== Observer_1.empty) {
                        context = Object.create(observerOrNext);
                        if (isFunction_1.isFunction(context.unsubscribe)) {
                            _this.add(context.unsubscribe.bind(context));
                        }
                        context.unsubscribe = _this.unsubscribe.bind(_this);
                    }
                }
                _this._context = context;
                _this._next = next;
                _this._error = error;
                _this._complete = complete;
                return _this;
            }
            SafeSubscriber.prototype.next = function (value) {
                if (!this.isStopped && this._next) {
                    var _parentSubscriber = this._parentSubscriber;
                    if (!config_1.config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
                        this.__tryOrUnsub(this._next, value);
                    }
                    else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {
                        this.unsubscribe();
                    }
                }
            };
            SafeSubscriber.prototype.error = function (err) {
                if (!this.isStopped) {
                    var _parentSubscriber = this._parentSubscriber;
                    var useDeprecatedSynchronousErrorHandling = config_1.config.useDeprecatedSynchronousErrorHandling;
                    if (this._error) {
                        if (!useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
                            this.__tryOrUnsub(this._error, err);
                            this.unsubscribe();
                        }
                        else {
                            this.__tryOrSetError(_parentSubscriber, this._error, err);
                            this.unsubscribe();
                        }
                    }
                    else if (!_parentSubscriber.syncErrorThrowable) {
                        this.unsubscribe();
                        if (useDeprecatedSynchronousErrorHandling) {
                            throw err;
                        }
                        hostReportError_1.hostReportError(err);
                    }
                    else {
                        if (useDeprecatedSynchronousErrorHandling) {
                            _parentSubscriber.syncErrorValue = err;
                            _parentSubscriber.syncErrorThrown = true;
                        }
                        else {
                            hostReportError_1.hostReportError(err);
                        }
                        this.unsubscribe();
                    }
                }
            };
            SafeSubscriber.prototype.complete = function () {
                var _this = this;
                if (!this.isStopped) {
                    var _parentSubscriber = this._parentSubscriber;
                    if (this._complete) {
                        var wrappedComplete = function () { return _this._complete.call(_this._context); };
                        if (!config_1.config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
                            this.__tryOrUnsub(wrappedComplete);
                            this.unsubscribe();
                        }
                        else {
                            this.__tryOrSetError(_parentSubscriber, wrappedComplete);
                            this.unsubscribe();
                        }
                    }
                    else {
                        this.unsubscribe();
                    }
                }
            };
            SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {
                try {
                    fn.call(this._context, value);
                }
                catch (err) {
                    this.unsubscribe();
                    if (config_1.config.useDeprecatedSynchronousErrorHandling) {
                        throw err;
                    }
                    else {
                        hostReportError_1.hostReportError(err);
                    }
                }
            };
            SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {
                if (!config_1.config.useDeprecatedSynchronousErrorHandling) {
                    throw new Error('bad call');
                }
                try {
                    fn.call(this._context, value);
                }
                catch (err) {
                    if (config_1.config.useDeprecatedSynchronousErrorHandling) {
                        parent.syncErrorValue = err;
                        parent.syncErrorThrown = true;
                        return true;
                    }
                    else {
                        hostReportError_1.hostReportError(err);
                        return true;
                    }
                }
                return false;
            };
            /** @deprecated This is an internal implementation detail, do not use. */
            SafeSubscriber.prototype._unsubscribe = function () {
                var _parentSubscriber = this._parentSubscriber;
                this._context = null;
                this._parentSubscriber = null;
                _parentSubscriber.unsubscribe();
            };
            return SafeSubscriber;
        }(Subscriber));
        function isTrustedSubscriber(obj) {
            return obj instanceof Subscriber || ('syncErrorThrowable' in obj && obj[rxSubscriber_1.rxSubscriber]);
        }

    },{"../internal/symbol/rxSubscriber":103,"./Observer":41,"./Subscription":48,"./config":49,"./util/hostReportError":111,"./util/isFunction":115}],48:[function(require,module,exports){
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var isArray_1 = require("./util/isArray");
        var isObject_1 = require("./util/isObject");
        var isFunction_1 = require("./util/isFunction");
        var tryCatch_1 = require("./util/tryCatch");
        var errorObject_1 = require("./util/errorObject");
        var UnsubscriptionError_1 = require("./util/UnsubscriptionError");
        /**
         * Represents a disposable resource, such as the execution of an Observable. A
         * Subscription has one important method, `unsubscribe`, that takes no argument
         * and just disposes the resource held by the subscription.
         *
         * Additionally, subscriptions may be grouped together through the `add()`
         * method, which will attach a child Subscription to the current Subscription.
         * When a Subscription is unsubscribed, all its children (and its grandchildren)
         * will be unsubscribed as well.
         *
         * @class Subscription
         */
        var Subscription = /** @class */ (function () {
            /**
             * @param {function(): void} [unsubscribe] A function describing how to
             * perform the disposal of resources when the `unsubscribe` method is called.
             */
            function Subscription(unsubscribe) {
                /**
                 * A flag to indicate whether this Subscription has already been unsubscribed.
                 * @type {boolean}
                 */
                this.closed = false;
                /** @internal */
                this._parent = null;
                /** @internal */
                this._parents = null;
                /** @internal */
                this._subscriptions = null;
                if (unsubscribe) {
                    this._unsubscribe = unsubscribe;
                }
            }
            /**
             * Disposes the resources held by the subscription. May, for instance, cancel
             * an ongoing Observable execution or cancel any other type of work that
             * started when the Subscription was created.
             * @return {void}
             */
            Subscription.prototype.unsubscribe = function () {
                var hasErrors = false;
                var errors;
                if (this.closed) {
                    return;
                }
                var _a = this, _parent = _a._parent, _parents = _a._parents, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;
                this.closed = true;
                this._parent = null;
                this._parents = null;
                // null out _subscriptions first so any child subscriptions that attempt
                // to remove themselves from this subscription will noop
                this._subscriptions = null;
                var index = -1;
                var len = _parents ? _parents.length : 0;
                // if this._parent is null, then so is this._parents, and we
                // don't have to remove ourselves from any parent subscriptions.
                while (_parent) {
                    _parent.remove(this);
                    // if this._parents is null or index >= len,
                    // then _parent is set to null, and the loop exits
                    _parent = ++index < len && _parents[index] || null;
                }
                if (isFunction_1.isFunction(_unsubscribe)) {
                    var trial = tryCatch_1.tryCatch(_unsubscribe).call(this);
                    if (trial === errorObject_1.errorObject) {
                        hasErrors = true;
                        errors = errors || (errorObject_1.errorObject.e instanceof UnsubscriptionError_1.UnsubscriptionError ?
                                        flattenUnsubscriptionErrors(errorObject_1.errorObject.e.errors) : [errorObject_1.errorObject.e]);
                    }
                }
                if (isArray_1.isArray(_subscriptions)) {
                    index = -1;
                    len = _subscriptions.length;
                    while (++index < len) {
                        var sub = _subscriptions[index];
                        if (isObject_1.isObject(sub)) {
                            var trial = tryCatch_1.tryCatch(sub.unsubscribe).call(sub);
                            if (trial === errorObject_1.errorObject) {
                                hasErrors = true;
                                errors = errors || [];
                                var err = errorObject_1.errorObject.e;
                                if (err instanceof UnsubscriptionError_1.UnsubscriptionError) {
                                    errors = errors.concat(flattenUnsubscriptionErrors(err.errors));
                                }
                                else {
                                    errors.push(err);
                                }
                            }
                        }
                    }
                }
                if (hasErrors) {
                    throw new UnsubscriptionError_1.UnsubscriptionError(errors);
                }
            };
            /**
             * Adds a tear down to be called during the unsubscribe() of this
             * Subscription.
             *
             * If the tear down being added is a subscription that is already
             * unsubscribed, is the same reference `add` is being called on, or is
             * `Subscription.EMPTY`, it will not be added.
             *
             * If this subscription is already in an `closed` state, the passed
             * tear down logic will be executed immediately.
             *
             * @param {TeardownLogic} teardown The additional logic to execute on
             * teardown.
             * @return {Subscription} Returns the Subscription used or created to be
             * added to the inner subscriptions list. This Subscription can be used with
             * `remove()` to remove the passed teardown logic from the inner subscriptions
             * list.
             */
            Subscription.prototype.add = function (teardown) {
                if (!teardown || (teardown === Subscription.EMPTY)) {
                    return Subscription.EMPTY;
                }
                if (teardown === this) {
                    return this;
                }
                var subscription = teardown;
                switch (typeof teardown) {
                    case 'function':
                        subscription = new Subscription(teardown);
                    case 'object':
                        if (subscription.closed || typeof subscription.unsubscribe !== 'function') {
                            return subscription;
                        }
                        else if (this.closed) {
                            subscription.unsubscribe();
                            return subscription;
                        }
                        else if (typeof subscription._addParent !== 'function' /* quack quack */) {
                            var tmp = subscription;
                            subscription = new Subscription();
                            subscription._subscriptions = [tmp];
                        }
                        break;
                    default:
                        throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');
                }
                var subscriptions = this._subscriptions || (this._subscriptions = []);
                subscriptions.push(subscription);
                subscription._addParent(this);
                return subscription;
            };
            /**
             * Removes a Subscription from the internal list of subscriptions that will
             * unsubscribe during the unsubscribe process of this Subscription.
             * @param {Subscription} subscription The subscription to remove.
             * @return {void}
             */
            Subscription.prototype.remove = function (subscription) {
                var subscriptions = this._subscriptions;
                if (subscriptions) {
                    var subscriptionIndex = subscriptions.indexOf(subscription);
                    if (subscriptionIndex !== -1) {
                        subscriptions.splice(subscriptionIndex, 1);
                    }
                }
            };
            /** @internal */
            Subscription.prototype._addParent = function (parent) {
                var _a = this, _parent = _a._parent, _parents = _a._parents;
                if (!_parent || _parent === parent) {
                    // If we don't have a parent, or the new parent is the same as the
                    // current parent, then set this._parent to the new parent.
                    this._parent = parent;
                }
                else if (!_parents) {
                    // If there's already one parent, but not multiple, allocate an Array to
                    // store the rest of the parent Subscriptions.
                    this._parents = [parent];
                }
                else if (_parents.indexOf(parent) === -1) {
                    // Only add the new parent to the _parents list if it's not already there.
                    _parents.push(parent);
                }
            };
            /** @nocollapse */
            Subscription.EMPTY = (function (empty) {
                empty.closed = true;
                return empty;
            }(new Subscription()));
            return Subscription;
        }());
        exports.Subscription = Subscription;
        function flattenUnsubscriptionErrors(errors) {
            return errors.reduce(function (errs, err) { return errs.concat((err instanceof UnsubscriptionError_1.UnsubscriptionError) ? err.errors : err); }, []);
        }

    },{"./util/UnsubscriptionError":109,"./util/errorObject":110,"./util/isArray":113,"./util/isFunction":115,"./util/isObject":119,"./util/tryCatch":132}],49:[function(require,module,exports){
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var _enable_super_gross_mode_that_will_cause_bad_things = false;
        /**
         * The global configuration object for RxJS, used to configure things
         * like what Promise contructor should used to create Promises
         */
        exports.config = {
            /**
             * The promise constructor used by default for methods such as
             * {@link toPromise} and {@link forEach}
             */
            Promise: undefined,
            /**
             * If true, turns on synchronous error rethrowing, which is a deprecated behavior
             * in v6 and higher. This behavior enables bad patterns like wrapping a subscribe
             * call in a try/catch block. It also enables producer interference, a nasty bug
             * where a multicast can be broken for all observers by a downstream consumer with
             * an unhandled error. DO NOT USE THIS FLAG UNLESS IT'S NEEDED TO BY TIME
             * FOR MIGRATION REASONS.
             */
            set useDeprecatedSynchronousErrorHandling(value) {
                if (value) {
                    var error = new Error();
                    console.warn('DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n' + error.stack);
                }
                else if (_enable_super_gross_mode_that_will_cause_bad_things) {
                    console.log('RxJS: Back to a better error behavior. Thank you. <3');
                }
                _enable_super_gross_mode_that_will_cause_bad_things = value;
            },
            get useDeprecatedSynchronousErrorHandling() {
                return _enable_super_gross_mode_that_will_cause_bad_things;
            },
        };

    },{}],50:[function(require,module,exports){
        "use strict";
        var __extends = (this && this.__extends) || (function () {
                    var extendStatics = Object.setPrototypeOf ||
                            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
                    return function (d, b) {
                        extendStatics(d, b);
                        function __() { this.constructor = d; }
                        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                    };
                })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var Subject_1 = require("../Subject");
        var Observable_1 = require("../Observable");
        var Subscriber_1 = require("../Subscriber");
        var Subscription_1 = require("../Subscription");
        var refCount_1 = require("../operators/refCount");
        /**
         * @class ConnectableObservable<T>
         */
        var ConnectableObservable = /** @class */ (function (_super) {
            __extends(ConnectableObservable, _super);
            function ConnectableObservable(source, subjectFactory) {
                var _this = _super.call(this) || this;
                _this.source = source;
                _this.subjectFactory = subjectFactory;
                _this._refCount = 0;
                /** @internal */
                _this._isComplete = false;
                return _this;
            }
            /** @deprecated This is an internal implementation detail, do not use. */
            ConnectableObservable.prototype._subscribe = function (subscriber) {
                return this.getSubject().subscribe(subscriber);
            };
            ConnectableObservable.prototype.getSubject = function () {
                var subject = this._subject;
                if (!subject || subject.isStopped) {
                    this._subject = this.subjectFactory();
                }
                return this._subject;
            };
            ConnectableObservable.prototype.connect = function () {
                var connection = this._connection;
                if (!connection) {
                    this._isComplete = false;
                    connection = this._connection = new Subscription_1.Subscription();
                    connection.add(this.source
                            .subscribe(new ConnectableSubscriber(this.getSubject(), this)));
                    if (connection.closed) {
                        this._connection = null;
                        connection = Subscription_1.Subscription.EMPTY;
                    }
                    else {
                        this._connection = connection;
                    }
                }
                return connection;
            };
            ConnectableObservable.prototype.refCount = function () {
                return refCount_1.refCount()(this);
            };
            return ConnectableObservable;
        }(Observable_1.Observable));
        exports.ConnectableObservable = ConnectableObservable;
        var connectableProto = ConnectableObservable.prototype;
        exports.connectableObservableDescriptor = {
            operator: { value: null },
            _refCount: { value: 0, writable: true },
            _subject: { value: null, writable: true },
            _connection: { value: null, writable: true },
            _subscribe: { value: connectableProto._subscribe },
            _isComplete: { value: connectableProto._isComplete, writable: true },
            getSubject: { value: connectableProto.getSubject },
            connect: { value: connectableProto.connect },
            refCount: { value: connectableProto.refCount }
        };
        var ConnectableSubscriber = /** @class */ (function (_super) {
            __extends(ConnectableSubscriber, _super);
            function ConnectableSubscriber(destination, connectable) {
                var _this = _super.call(this, destination) || this;
                _this.connectable = connectable;
                return _this;
            }
            ConnectableSubscriber.prototype._error = function (err) {
                this._unsubscribe();
                _super.prototype._error.call(this, err);
            };
            ConnectableSubscriber.prototype._complete = function () {
                this.connectable._isComplete = true;
                this._unsubscribe();
                _super.prototype._complete.call(this);
            };
            ConnectableSubscriber.prototype._unsubscribe = function () {
                var connectable = this.connectable;
                if (connectable) {
                    this.connectable = null;
                    var connection = connectable._connection;
                    connectable._refCount = 0;
                    connectable._subject = null;
                    connectable._connection = null;
                    if (connection) {
                        connection.unsubscribe();
                    }
                }
            };
            return ConnectableSubscriber;
        }(Subject_1.SubjectSubscriber));
        var RefCountOperator = /** @class */ (function () {
            function RefCountOperator(connectable) {
                this.connectable = connectable;
            }
            RefCountOperator.prototype.call = function (subscriber, source) {
                var connectable = this.connectable;
                connectable._refCount++;
                var refCounter = new RefCountSubscriber(subscriber, connectable);
                var subscription = source.subscribe(refCounter);
                if (!refCounter.closed) {
                    refCounter.connection = connectable.connect();
                }
                return subscription;
            };
            return RefCountOperator;
        }());
        var RefCountSubscriber = /** @class */ (function (_super) {
            __extends(RefCountSubscriber, _super);
            function RefCountSubscriber(destination, connectable) {
                var _this = _super.call(this, destination) || this;
                _this.connectable = connectable;
                return _this;
            }
            RefCountSubscriber.prototype._unsubscribe = function () {
                var connectable = this.connectable;
                if (!connectable) {
                    this.connection = null;
                    return;
                }
                this.connectable = null;
                var refCount = connectable._refCount;
                if (refCount <= 0) {
                    this.connection = null;
                    return;
                }
                connectable._refCount = refCount - 1;
                if (refCount > 1) {
                    this.connection = null;
                    return;
                }
                ///
                // Compare the local RefCountSubscriber's connection Subscription to the
                // connection Subscription on the shared ConnectableObservable. In cases
                // where the ConnectableObservable source synchronously emits values, and
                // the RefCountSubscriber's downstream Observers synchronously unsubscribe,
                // execution continues to here before the RefCountOperator has a chance to
                // supply the RefCountSubscriber with the shared connection Subscription.
                // For example:
                // ```
                // Observable.range(0, 10)
                //   .publish()
                //   .refCount()
                //   .take(5)
                //   .subscribe();
                // ```
                // In order to account for this case, RefCountSubscriber should only dispose
                // the ConnectableObservable's shared connection Subscription if the
                // connection Subscription exists, *and* either:
                //   a. RefCountSubscriber doesn't have a reference to the shared connection
                //      Subscription yet, or,
                //   b. RefCountSubscriber's connection Subscription reference is identical
                //      to the shared connection Subscription
                ///
                var connection = this.connection;
                var sharedConnection = connectable._connection;
                this.connection = null;
                if (sharedConnection && (!connection || sharedConnection === connection)) {
                    sharedConnection.unsubscribe();
                }
            };
            return RefCountSubscriber;
        }(Subscriber_1.Subscriber));

    },{"../Observable":40,"../Subject":45,"../Subscriber":47,"../Subscription":48,"../operators/refCount":86}],51:[function(require,module,exports){
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var Observable_1 = require("../Observable");
        var AsyncSubject_1 = require("../AsyncSubject");
        var map_1 = require("../operators/map");
        var isArray_1 = require("../util/isArray");
        var isScheduler_1 = require("../util/isScheduler");
// tslint:enable:max-line-length
        /**
         * Converts a callback API to a function that returns an Observable.
         *
         * <span class="informal">Give it a function `f` of type `f(x, callback)` and
         * it will return a function `g` that when called as `g(x)` will output an
         * Observable.</span>
         *
         * `bindCallback` is not an operator because its input and output are not
         * Observables. The input is a function `func` with some parameters, the
         * last parameter must be a callback function that `func` calls when it is
         * done.
         *
         * The output of `bindCallback` is a function that takes the same parameters
         * as `func`, except the last one (the callback). When the output function
         * is called with arguments it will return an Observable. If function `func`
         * calls its callback with one argument the Observable will emit that value.
         * If on the other hand the callback is called with multiple values the resulting
         * Observable will emit an array with said values as arguments.
         *
         * It is very important to remember that input function `func` is not called
         * when the output function is, but rather when the Observable returned by the output
         * function is subscribed. This means if `func` makes an AJAX request, that request
         * will be made every time someone subscribes to the resulting Observable, but not before.
         *
         * The last optional parameter - {@link Scheduler} - can be used to control when the call
         * to `func` happens after someone subscribes to Observable, as well as when results
         * passed to callback will be emitted. By default, the subscription to  an Observable calls `func`
         * synchronously, but using `Scheduler.async` as the last parameter will defer the call to `func`,
         * just like wrapping the call in `setTimeout` with a timeout of `0` would. If you use the async Scheduler
         * and call `subscribe` on the output Observable all function calls that are currently executing
         * will end before `func` is invoked.
         *
         * By default results passed to the callback are emitted immediately after `func` invokes the callback.
         * In particular, if the callback is called synchronously the subscription of the resulting Observable
         * will call the `next` function synchronously as well.  If you want to defer that call,
         * you may use `Scheduler.async` just as before.  This means that by using `Scheduler.async` you can
         * ensure that `func` always calls its callback asynchronously, thus avoiding terrifying Zalgo.
         *
         * Note that the Observable created by the output function will always emit a single value
         * and then complete immediately. If `func` calls the callback multiple times, values from subsequent
         * calls will not appear in the stream. If you need to listen for multiple calls,
         *  you probably want to use {@link fromEvent} or {@link fromEventPattern} instead.
         *
         * If `func` depends on some context (`this` property) and is not already bound the context of `func`
         * will be the context that the output function has at call time. In particular, if `func`
         * is called as a method of some objec and if `func` is not already bound, in order to preserve the context
         * it is recommended that the context of the output function is set to that object as well.
         *
         * If the input function calls its callback in the "node style" (i.e. first argument to callback is
         * optional error parameter signaling whether the call failed or not), {@link bindNodeCallback}
         * provides convenient error handling and probably is a better choice.
         * `bindCallback` will treat such functions the same as any other and error parameters
         * (whether passed or not) will always be interpreted as regular callback argument.
         *
         *
         * @example <caption>Convert jQuery's getJSON to an Observable API</caption>
         * // Suppose we have jQuery.getJSON('/my/url', callback)
         * var getJSONAsObservable = bindCallback(jQuery.getJSON);
         * var result = getJSONAsObservable('/my/url');
         * result.subscribe(x => console.log(x), e => console.error(e));
         *
         *
         * @example <caption>Receive an array of arguments passed to a callback</caption>
         * someFunction((a, b, c) => {
 *   console.log(a); // 5
 *   console.log(b); // 'some string'
 *   console.log(c); // {someProperty: 'someValue'}
 * });
         *
         * const boundSomeFunction = bindCallback(someFunction);
         * boundSomeFunction().subscribe(values => {
 *   console.log(values) // [5, 'some string', {someProperty: 'someValue'}]
 * });
         *
         *
         * @example <caption>Compare behaviour with and without async Scheduler</caption>
         * function iCallMyCallbackSynchronously(cb) {
 *   cb();
 * }
         *
         * const boundSyncFn = bindCallback(iCallMyCallbackSynchronously);
         * const boundAsyncFn = bindCallback(iCallMyCallbackSynchronously, null, Rx.Scheduler.async);
         *
         * boundSyncFn().subscribe(() => console.log('I was sync!'));
         * boundAsyncFn().subscribe(() => console.log('I was async!'));
         * console.log('This happened...');
         *
         * // Logs:
         * // I was sync!
         * // This happened...
         * // I was async!
         *
         *
         * @example <caption>Use bindCallback on an object method</caption>
         * const boundMethod = bindCallback(someObject.methodWithCallback);
         * boundMethod.call(someObject) // make sure methodWithCallback has access to someObject
         * .subscribe(subscriber);
         *
         *
         * @see {@link bindNodeCallback}
         * @see {@link from}
         * @see {@link fromPromise}
         *
         * @param {function} func A function with a callback as the last parameter.
         * @param {Scheduler} [scheduler] The scheduler on which to schedule the
         * callbacks.
         * @return {function(...params: *): Observable} A function which returns the
         * Observable that delivers the same values the callback would deliver.
         * @name bindCallback
         */
        function bindCallback(callbackFunc, resultSelector, scheduler) {
            if (resultSelector) {
                if (isScheduler_1.isScheduler(resultSelector)) {
                    scheduler = resultSelector;
                }
                else {
                    // DEPRECATED PATH
                    return function () {
                        var args = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            args[_i] = arguments[_i];
                        }
                        return bindCallback(callbackFunc, scheduler).apply(void 0, args).pipe(map_1.map(function (args) { return isArray_1.isArray(args) ? resultSelector.apply(void 0, args) : resultSelector(args); }));
                    };
                }
            }
            return function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                var context = this;
                var subject;
                var params = {
                    context: context,
                    subject: subject,
                    callbackFunc: callbackFunc,
                    scheduler: scheduler,
                };
                return new Observable_1.Observable(function (subscriber) {
                    if (!scheduler) {
                        if (!subject) {
                            subject = new AsyncSubject_1.AsyncSubject();
                            var handler = function () {
                                var innerArgs = [];
                                for (var _i = 0; _i < arguments.length; _i++) {
                                    innerArgs[_i] = arguments[_i];
                                }
                                subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs);
                                subject.complete();
                            };
                            try {
                                callbackFunc.apply(context, args.concat([handler]));
                            }
                            catch (err) {
                                subject.error(err);
                            }
                        }
                        return subject.subscribe(subscriber);
                    }
                    else {
                        var state = {
                            args: args, subscriber: subscriber, params: params,
                        };
                        return scheduler.schedule(dispatch, 0, state);
                    }
                });
            };
        }
        exports.bindCallback = bindCallback;
        function dispatch(state) {
            var _this = this;
            var self = this;
            var args = state.args, subscriber = state.subscriber, params = state.params;
            var callbackFunc = params.callbackFunc, context = params.context, scheduler = params.scheduler;
            var subject = params.subject;
            if (!subject) {
                subject = params.subject = new AsyncSubject_1.AsyncSubject();
                var handler = function () {
                    var innerArgs = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        innerArgs[_i] = arguments[_i];
                    }
                    var value = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;
                    _this.add(scheduler.schedule(dispatchNext, 0, { value: value, subject: subject }));
                };
                try {
                    callbackFunc.apply(context, args.concat([handler]));
                }
                catch (err) {
                    subject.error(err);
                }
            }
            this.add(subject.subscribe(subscriber));
        }
        function dispatchNext(state) {
            var value = state.value, subject = state.subject;
            subject.next(value);
            subject.complete();
        }
        function dispatchError(state) {
            var err = state.err, subject = state.subject;
            subject.error(err);
        }

    },{"../AsyncSubject":36,"../Observable":40,"../operators/map":82,"../util/isArray":113,"../util/isScheduler":122}],52:[function(require,module,exports){
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var Observable_1 = require("../Observable");
        var AsyncSubject_1 = require("../AsyncSubject");
        var map_1 = require("../operators/map");
        var isScheduler_1 = require("../util/isScheduler");
        var isArray_1 = require("../util/isArray");
        /**
         * Converts a Node.js-style callback API to a function that returns an
         * Observable.
         *
         * <span class="informal">It's just like {@link bindCallback}, but the
         * callback is expected to be of type `callback(error, result)`.</span>
         *
         * `bindNodeCallback` is not an operator because its input and output are not
         * Observables. The input is a function `func` with some parameters, but the
         * last parameter must be a callback function that `func` calls when it is
         * done. The callback function is expected to follow Node.js conventions,
         * where the first argument to the callback is an error object, signaling
         * whether call was successful. If that object is passed to callback, it means
         * something went wrong.
         *
         * The output of `bindNodeCallback` is a function that takes the same
         * parameters as `func`, except the last one (the callback). When the output
         * function is called with arguments, it will return an Observable.
         * If `func` calls its callback with error parameter present, Observable will
         * error with that value as well. If error parameter is not passed, Observable will emit
         * second parameter. If there are more parameters (third and so on),
         * Observable will emit an array with all arguments, except first error argument.
         *
         * Note that `func` will not be called at the same time output function is,
         * but rather whenever resulting Observable is subscribed. By default call to
         * `func` will happen synchronously after subscription, but that can be changed
         * with proper {@link Scheduler} provided as optional third parameter. Scheduler
         * can also control when values from callback will be emitted by Observable.
         * To find out more, check out documentation for {@link bindCallback}, where
         * Scheduler works exactly the same.
         *
         * As in {@link bindCallback}, context (`this` property) of input function will be set to context
         * of returned function, when it is called.
         *
         * After Observable emits value, it will complete immediately. This means
         * even if `func` calls callback again, values from second and consecutive
         * calls will never appear on the stream. If you need to handle functions
         * that call callbacks multiple times, check out {@link fromEvent} or
         * {@link fromEventPattern} instead.
         *
         * Note that `bindNodeCallback` can be used in non-Node.js environments as well.
         * "Node.js-style" callbacks are just a convention, so if you write for
         * browsers or any other environment and API you use implements that callback style,
         * `bindNodeCallback` can be safely used on that API functions as well.
         *
         * Remember that Error object passed to callback does not have to be an instance
         * of JavaScript built-in `Error` object. In fact, it does not even have to an object.
         * Error parameter of callback function is interpreted as "present", when value
         * of that parameter is truthy. It could be, for example, non-zero number, non-empty
         * string or boolean `true`. In all of these cases resulting Observable would error
         * with that value. This means usually regular style callbacks will fail very often when
         * `bindNodeCallback` is used. If your Observable errors much more often then you
         * would expect, check if callback really is called in Node.js-style and, if not,
         * switch to {@link bindCallback} instead.
         *
         * Note that even if error parameter is technically present in callback, but its value
         * is falsy, it still won't appear in array emitted by Observable.
         *
         *
         * @example <caption>Read a file from the filesystem and get the data as an Observable</caption>
         * import * as fs from 'fs';
         * var readFileAsObservable = bindNodeCallback(fs.readFile);
         * var result = readFileAsObservable('./roadNames.txt', 'utf8');
         * result.subscribe(x => console.log(x), e => console.error(e));
         *
         *
         * @example <caption>Use on function calling callback with multiple arguments</caption>
         * someFunction((err, a, b) => {
 *   console.log(err); // null
 *   console.log(a); // 5
 *   console.log(b); // "some string"
 * });
         * var boundSomeFunction = bindNodeCallback(someFunction);
         * boundSomeFunction()
         * .subscribe(value => {
 *   console.log(value); // [5, "some string"]
 * });
         *
         * @example <caption>Use on function calling callback in regular style</caption>
         * someFunction(a => {
 *   console.log(a); // 5
 * });
         * var boundSomeFunction = bindNodeCallback(someFunction);
         * boundSomeFunction()
         * .subscribe(
         *   value => {}             // never gets called
         *   err => console.log(err) // 5
         * );
         *
         *
         * @see {@link bindCallback}
         * @see {@link from}
         * @see {@link fromPromise}
         *
         * @param {function} func Function with a Node.js-style callback as the last parameter.
         * @param {Scheduler} [scheduler] The scheduler on which to schedule the
         * callbacks.
         * @return {function(...params: *): Observable} A function which returns the
         * Observable that delivers the same values the Node.js callback would
         * deliver.
         * @name bindNodeCallback
         */
        function bindNodeCallback(callbackFunc, resultSelector, scheduler) {
            if (resultSelector) {
                if (isScheduler_1.isScheduler(resultSelector)) {
                    scheduler = resultSelector;
                }
                else {
                    // DEPRECATED PATH
                    return function () {
                        var args = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            args[_i] = arguments[_i];
                        }
                        return bindNodeCallback(callbackFunc, scheduler).apply(void 0, args).pipe(map_1.map(function (args) { return isArray_1.isArray(args) ? resultSelector.apply(void 0, args) : resultSelector(args); }));
                    };
                }
            }
            return function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                var params = {
                    subject: undefined,
                    args: args,
                    callbackFunc: callbackFunc,
                    scheduler: scheduler,
                    context: this,
                };
                return new Observable_1.Observable(function (subscriber) {
                    var context = params.context;
                    var subject = params.subject;
                    if (!scheduler) {
                        if (!subject) {
                            subject = params.subject = new AsyncSubject_1.AsyncSubject();
                            var handler = function () {
                                var innerArgs = [];
                                for (var _i = 0; _i < arguments.length; _i++) {
                                    innerArgs[_i] = arguments[_i];
                                }
                                var err = innerArgs.shift();
                                if (err) {
                                    subject.error(err);
                                    return;
                                }
                                subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs);
                                subject.complete();
                            };
                            try {
                                callbackFunc.apply(context, args.concat([handler]));
                            }
                            catch (err) {
                                subject.error(err);
                            }
                        }
                        return subject.subscribe(subscriber);
                    }
                    else {
                        return scheduler.schedule(dispatch, 0, { params: params, subscriber: subscriber, context: context });
                    }
                });
            };
        }
        exports.bindNodeCallback = bindNodeCallback;
        function dispatch(state) {
            var _this = this;
            var params = state.params, subscriber = state.subscriber, context = state.context;
            var callbackFunc = params.callbackFunc, args = params.args, scheduler = params.scheduler;
            var subject = params.subject;
            if (!subject) {
                subject = params.subject = new AsyncSubject_1.AsyncSubject();
                var handler = function () {
                    var innerArgs = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        innerArgs[_i] = arguments[_i];
                    }
                    var err = innerArgs.shift();
                    if (err) {
                        _this.add(scheduler.schedule(dispatchError, 0, { err: err, subject: subject }));
                    }
                    else {
                        var value = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;
                        _this.add(scheduler.schedule(dispatchNext, 0, { value: value, subject: subject }));
                    }
                };
                try {
                    callbackFunc.apply(context, args.concat([handler]));
                }
                catch (err) {
                    this.add(scheduler.schedule(dispatchError, 0, { err: err, subject: subject }));
                }
            }
            this.add(subject.subscribe(subscriber));
        }
        function dispatchNext(arg) {
            var value = arg.value, subject = arg.subject;
            subject.next(value);
            subject.complete();
        }
        function dispatchError(arg) {
            var err = arg.err, subject = arg.subject;
            subject.error(err);
        }

    },{"../AsyncSubject":36,"../Observable":40,"../operators/map":82,"../util/isArray":113,"../util/isScheduler":122}],53:[function(require,module,exports){
        "use strict";
        var __extends = (this && this.__extends) || (function () {
                    var extendStatics = Object.setPrototypeOf ||
                            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
                    return function (d, b) {
                        extendStatics(d, b);
                        function __() { this.constructor = d; }
                        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                    };
                })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var isScheduler_1 = require("../util/isScheduler");
        var isArray_1 = require("../util/isArray");
        var OuterSubscriber_1 = require("../OuterSubscriber");
        var subscribeToResult_1 = require("../util/subscribeToResult");
        var fromArray_1 = require("./fromArray");
        var NONE = {};
        /* tslint:enable:max-line-length */
        /**
         * Combines multiple Observables to create an Observable whose values are
         * calculated from the latest values of each of its input Observables.
         *
         * <span class="informal">Whenever any input Observable emits a value, it
         * computes a formula using the latest values from all the inputs, then emits
         * the output of that formula.</span>
         *
         * <img src="./img/combineLatest.png" width="100%">
         *
         * `combineLatest` combines the values from all the Observables passed as
         * arguments. This is done by subscribing to each Observable in order and,
         * whenever any Observable emits, collecting an array of the most recent
         * values from each Observable. So if you pass `n` Observables to operator,
         * returned Observable will always emit an array of `n` values, in order
         * corresponding to order of passed Observables (value from the first Observable
         * on the first place and so on).
         *
         * Static version of `combineLatest` accepts either an array of Observables
         * or each Observable can be put directly as an argument. Note that array of
         * Observables is good choice, if you don't know beforehand how many Observables
         * you will combine. Passing empty array will result in Observable that
         * completes immediately.
         *
         * To ensure output array has always the same length, `combineLatest` will
         * actually wait for all input Observables to emit at least once,
         * before it starts emitting results. This means if some Observable emits
         * values before other Observables started emitting, all that values but last
         * will be lost. On the other hand, is some Observable does not emit value but
         * completes, resulting Observable will complete at the same moment without
         * emitting anything, since it will be now impossible to include value from
         * completed Observable in resulting array. Also, if some input Observable does
         * not emit any value and never completes, `combineLatest` will also never emit
         * and never complete, since, again, it will wait for all streams to emit some
         * value.
         *
         * If at least one Observable was passed to `combineLatest` and all passed Observables
         * emitted something, resulting Observable will complete when all combined
         * streams complete. So even if some Observable completes, result of
         * `combineLatest` will still emit values when other Observables do. In case
         * of completed Observable, its value from now on will always be the last
         * emitted value. On the other hand, if any Observable errors, `combineLatest`
         * will error immediately as well, and all other Observables will be unsubscribed.
         *
         * `combineLatest` accepts as optional parameter `project` function, which takes
         * as arguments all values that would normally be emitted by resulting Observable.
         * `project` can return any kind of value, which will be then emitted by Observable
         * instead of default array. Note that `project` does not take as argument that array
         * of values, but values themselves. That means default `project` can be imagined
         * as function that takes all its arguments and puts them into an array.
         *
         *
         * @example <caption>Combine two timer Observables</caption>
         * const firstTimer = Rx.Observable.timer(0, 1000); // emit 0, 1, 2... after every second, starting from now
         * const secondTimer = Rx.Observable.timer(500, 1000); // emit 0, 1, 2... after every second, starting 0,5s from now
         * const combinedTimers = Rx.Observable.combineLatest(firstTimer, secondTimer);
         * combinedTimers.subscribe(value => console.log(value));
         * // Logs
         * // [0, 0] after 0.5s
         * // [1, 0] after 1s
         * // [1, 1] after 1.5s
         * // [2, 1] after 2s
         *
         *
         * @example <caption>Combine an array of Observables</caption>
         * const observables = [1, 5, 10].map(
         *   n => Rx.Observable.of(n).delay(n * 1000).startWith(0) // emit 0 and then emit n after n seconds
         * );
         * const combined = Rx.Observable.combineLatest(observables);
         * combined.subscribe(value => console.log(value));
         * // Logs
         * // [0, 0, 0] immediately
         * // [1, 0, 0] after 1s
         * // [1, 5, 0] after 5s
         * // [1, 5, 10] after 10s
         *
         *
         * @example <caption>Use project function to dynamically calculate the Body-Mass Index</caption>
         * var weight = Rx.Observable.of(70, 72, 76, 79, 75);
         * var height = Rx.Observable.of(1.76, 1.77, 1.78);
         * var bmi = Rx.Observable.combineLatest(weight, height, (w, h) => w / (h * h));
         * bmi.subscribe(x => console.log('BMI is ' + x));
         *
         * // With output to console:
         * // BMI is 24.212293388429753
         * // BMI is 23.93948099205209
         * // BMI is 23.671253629592222
         *
         *
         * @see {@link combineAll}
         * @see {@link merge}
         * @see {@link withLatestFrom}
         *
         * @param {ObservableInput} observable1 An input Observable to combine with other Observables.
         * @param {ObservableInput} observable2 An input Observable to combine with other Observables.
         * More than one input Observables may be given as arguments
         * or an array of Observables may be given as the first argument.
         * @param {function} [project] An optional function to project the values from
         * the combined latest values into a new value on the output Observable.
         * @param {Scheduler} [scheduler=null] The IScheduler to use for subscribing to
         * each input Observable.
         * @return {Observable} An Observable of projected values from the most recent
         * values from each input Observable, or an array of the most recent values from
         * each input Observable.
         */
        function combineLatest() {
            var observables = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                observables[_i] = arguments[_i];
            }
            var resultSelector = null;
            var scheduler = null;
            if (isScheduler_1.isScheduler(observables[observables.length - 1])) {
                scheduler = observables.pop();
            }
            if (typeof observables[observables.length - 1] === 'function') {
                resultSelector = observables.pop();
            }
            // if the first and only other argument besides the resultSelector is an array
            // assume it's been called with `combineLatest([obs1, obs2, obs3], resultSelector)`
            if (observables.length === 1 && isArray_1.isArray(observables[0])) {
                observables = observables[0];
            }
            return fromArray_1.fromArray(observables, scheduler).lift(new CombineLatestOperator(resultSelector));
        }
        exports.combineLatest = combineLatest;
        var CombineLatestOperator = /** @class */ (function () {
            function CombineLatestOperator(resultSelector) {
                this.resultSelector = resultSelector;
            }
            CombineLatestOperator.prototype.call = function (subscriber, source) {
                return source.subscribe(new CombineLatestSubscriber(subscriber, this.resultSelector));
            };
            return CombineLatestOperator;
        }());
        exports.CombineLatestOperator = CombineLatestOperator;
        /**
         * We need this JSDoc comment for affecting ESDoc.
         * @ignore
         * @extends {Ignored}
         */
        var CombineLatestSubscriber = /** @class */ (function (_super) {
            __extends(CombineLatestSubscriber, _super);
            function CombineLatestSubscriber(destination, resultSelector) {
                var _this = _super.call(this, destination) || this;
                _this.resultSelector = resultSelector;
                _this.active = 0;
                _this.values = [];
                _this.observables = [];
                return _this;
            }
            CombineLatestSubscriber.prototype._next = function (observable) {
                this.values.push(NONE);
                this.observables.push(observable);
            };
            CombineLatestSubscriber.prototype._complete = function () {
                var observables = this.observables;
                var len = observables.length;
                if (len === 0) {
                    this.destination.complete();
                }
                else {
                    this.active = len;
                    this.toRespond = len;
                    for (var i = 0; i < len; i++) {
                        var observable = observables[i];
                        this.add(subscribeToResult_1.subscribeToResult(this, observable, observable, i));
                    }
                }
            };
            CombineLatestSubscriber.prototype.notifyComplete = function (unused) {
                if ((this.active -= 1) === 0) {
                    this.destination.complete();
                }
            };
            CombineLatestSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
                var values = this.values;
                var oldVal = values[outerIndex];
                var toRespond = !this.toRespond
                        ? 0
                        : oldVal === NONE ? --this.toRespond : this.toRespond;
                values[outerIndex] = innerValue;
                if (toRespond === 0) {
                    if (this.resultSelector) {
                        this._tryResultSelector(values);
                    }
                    else {
                        this.destination.next(values.slice());
                    }
                }
            };
            CombineLatestSubscriber.prototype._tryResultSelector = function (values) {
                var result;
                try {
                    result = this.resultSelector.apply(this, values);
                }
                catch (err) {
                    this.destination.error(err);
                    return;
                }
                this.destination.next(result);
            };
            return CombineLatestSubscriber;
        }(OuterSubscriber_1.OuterSubscriber));
        exports.CombineLatestSubscriber = CombineLatestSubscriber;

    },{"../OuterSubscriber":42,"../util/isArray":113,"../util/isScheduler":122,"../util/subscribeToResult":130,"./fromArray":59}],54:[function(require,module,exports){
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var isScheduler_1 = require("../util/isScheduler");
        var of_1 = require("./of");
        var from_1 = require("./from");
        var concatAll_1 = require("../operators/concatAll");
        /* tslint:enable:max-line-length */
        /**
         * Creates an output Observable which sequentially emits all values from given
         * Observable and then moves on to the next.
         *
         * <span class="informal">Concatenates multiple Observables together by
         * sequentially emitting their values, one Observable after the other.</span>
         *
         * <img src="./img/concat.png" width="100%">
         *
         * `concat` joins multiple Observables together, by subscribing to them one at a time and
         * merging their results into the output Observable. You can pass either an array of
         * Observables, or put them directly as arguments. Passing an empty array will result
         * in Observable that completes immediately.
         *
         * `concat` will subscribe to first input Observable and emit all its values, without
         * changing or affecting them in any way. When that Observable completes, it will
         * subscribe to then next Observable passed and, again, emit its values. This will be
         * repeated, until the operator runs out of Observables. When last input Observable completes,
         * `concat` will complete as well. At any given moment only one Observable passed to operator
         * emits values. If you would like to emit values from passed Observables concurrently, check out
         * {@link merge} instead, especially with optional `concurrent` parameter. As a matter of fact,
         * `concat` is an equivalent of `merge` operator with `concurrent` parameter set to `1`.
         *
         * Note that if some input Observable never completes, `concat` will also never complete
         * and Observables following the one that did not complete will never be subscribed. On the other
         * hand, if some Observable simply completes immediately after it is subscribed, it will be
         * invisible for `concat`, which will just move on to the next Observable.
         *
         * If any Observable in chain errors, instead of passing control to the next Observable,
         * `concat` will error immediately as well. Observables that would be subscribed after
         * the one that emitted error, never will.
         *
         * If you pass to `concat` the same Observable many times, its stream of values
         * will be "replayed" on every subscription, which means you can repeat given Observable
         * as many times as you like. If passing the same Observable to `concat` 1000 times becomes tedious,
         * you can always use {@link repeat}.
         *
         * @example <caption>Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10</caption>
         * var timer = Rx.Observable.interval(1000).take(4);
         * var sequence = Rx.Observable.range(1, 10);
         * var result = Rx.Observable.concat(timer, sequence);
         * result.subscribe(x => console.log(x));
         *
         * // results in:
         * // 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3 -immediate-> 1 ... 10
         *
         *
         * @example <caption>Concatenate an array of 3 Observables</caption>
         * var timer1 = Rx.Observable.interval(1000).take(10);
         * var timer2 = Rx.Observable.interval(2000).take(6);
         * var timer3 = Rx.Observable.interval(500).take(10);
         * var result = Rx.Observable.concat([timer1, timer2, timer3]); // note that array is passed
         * result.subscribe(x => console.log(x));
         *
         * // results in the following:
         * // (Prints to console sequentially)
         * // -1000ms-> 0 -1000ms-> 1 -1000ms-> ... 9
         * // -2000ms-> 0 -2000ms-> 1 -2000ms-> ... 5
         * // -500ms-> 0 -500ms-> 1 -500ms-> ... 9
         *
         *
         * @example <caption>Concatenate the same Observable to repeat it</caption>
         * const timer = Rx.Observable.interval(1000).take(2);
         *
         * Rx.Observable.concat(timer, timer) // concating the same Observable!
         * .subscribe(
         *   value => console.log(value),
         *   err => {},
         *   () => console.log('...and it is done!')
         * );
         *
         * // Logs:
         * // 0 after 1s
         * // 1 after 2s
         * // 0 after 3s
         * // 1 after 4s
         * // "...and it is done!" also after 4s
         *
         * @see {@link concatAll}
         * @see {@link concatMap}
         * @see {@link concatMapTo}
         *
         * @param {ObservableInput} input1 An input Observable to concatenate with others.
         * @param {ObservableInput} input2 An input Observable to concatenate with others.
         * More than one input Observables may be given as argument.
         * @param {Scheduler} [scheduler=null] An optional IScheduler to schedule each
         * Observable subscription on.
         * @return {Observable} All values of each passed Observable merged into a
         * single Observable, in order, in serial fashion.
         * @static true
         * @name concat
         * @owner Observable
         */
        function concat() {
            var observables = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                observables[_i] = arguments[_i];
            }
            if (observables.length === 1 || (observables.length === 2 && isScheduler_1.isScheduler(observables[1]))) {
                return from_1.from(observables[0]);
            }
            return concatAll_1.concatAll()(of_1.of.apply(void 0, observables));
        }
        exports.concat = concat;

    },{"../operators/concatAll":80,"../util/isScheduler":122,"./from":58,"./of":70}],55:[function(require,module,exports){
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var Observable_1 = require("../Observable");
        var from_1 = require("./from"); // lol
        var empty_1 = require("./empty");
        /**
         * Creates an Observable that, on subscribe, calls an Observable factory to
         * make an Observable for each new Observer.
         *
         * <span class="informal">Creates the Observable lazily, that is, only when it
         * is subscribed.
         * </span>
         *
         * <img src="./img/defer.png" width="100%">
         *
         * `defer` allows you to create the Observable only when the Observer
         * subscribes, and create a fresh Observable for each Observer. It waits until
         * an Observer subscribes to it, and then it generates an Observable,
         * typically with an Observable factory function. It does this afresh for each
         * subscriber, so although each subscriber may think it is subscribing to the
         * same Observable, in fact each subscriber gets its own individual
         * Observable.
         *
         * @example <caption>Subscribe to either an Observable of clicks or an Observable of interval, at random</caption>
         * var clicksOrInterval = Rx.Observable.defer(function () {
 *   if (Math.random() > 0.5) {
 *     return Rx.Observable.fromEvent(document, 'click');
 *   } else {
 *     return Rx.Observable.interval(1000);
 *   }
 * });
         * clicksOrInterval.subscribe(x => console.log(x));
         *
         * // Results in the following behavior:
         * // If the result of Math.random() is greater than 0.5 it will listen
         * // for clicks anywhere on the "document"; when document is clicked it
         * // will log a MouseEvent object to the console. If the result is less
         * // than 0.5 it will emit ascending numbers, one every second(1000ms).
         *
         * @see {@link create}
         *
         * @param {function(): SubscribableOrPromise} observableFactory The Observable
         * factory function to invoke for each Observer that subscribes to the output
         * Observable. May also return a Promise, which will be converted on the fly
         * to an Observable.
         * @return {Observable} An Observable whose Observers' subscriptions trigger
         * an invocation of the given Observable factory function.
         * @static true
         * @name defer
         * @owner Observable
         */
        function defer(observableFactory) {
            return new Observable_1.Observable(function (subscriber) {
                var input;
                try {
                    input = observableFactory();
                }
                catch (err) {
                    subscriber.error(err);
                    return undefined;
                }
                var source = input ? from_1.from(input) : empty_1.empty();
                return source.subscribe(subscriber);
            });
        }
        exports.defer = defer;

    },{"../Observable":40,"./empty":56,"./from":58}],56:[function(require,module,exports){
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var Observable_1 = require("../Observable");
        /**
         * The same Observable instance returned by any call to {@link empty} without a
         * {@link Scheduler}. It is preferrable to use this over `empty()`.
         */
        exports.EMPTY = new Observable_1.Observable(function (subscriber) { return subscriber.complete(); });
        /**
         * Creates an Observable that emits no items to the Observer and immediately
         * emits a complete notification.
         *
         * <span class="informal">Just emits 'complete', and nothing else.
         * </span>
         *
         * <img src="./img/empty.png" width="100%">
         *
         * This static operator is useful for creating a simple Observable that only
         * emits the complete notification. It can be used for composing with other
         * Observables, such as in a {@link mergeMap}.
         *
         * @example <caption>Emit the number 7, then complete.</caption>
         * var result = Rx.Observable.empty().startWith(7);
         * result.subscribe(x => console.log(x));
         *
         * @example <caption>Map and flatten only odd numbers to the sequence 'a', 'b', 'c'</caption>
         * var interval = Rx.Observable.interval(1000);
         * var result = interval.mergeMap(x =>
         *   x % 2 === 1 ? Rx.Observable.of('a', 'b', 'c') : Rx.Observable.empty()
         * );
         * result.subscribe(x => console.log(x));
         *
         * // Results in the following to the console:
         * // x is equal to the count on the interval eg(0,1,2,3,...)
         * // x will occur every 1000ms
         * // if x % 2 is equal to 1 print abc
         * // if x % 2 is not equal to 1 nothing will be output
         *
         * @see {@link create}
         * @see {@link never}
         * @see {@link of}
         * @see {@link throw}
         *
         * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling
         * the emission of the complete notification.
         * @return {Observable} An "empty" Observable: emits only the complete
         * notification.
         * @static true
         * @name empty
         * @owner Observable
         * @deprecated Deprecated in favor of using EMPTY constant.
         */
        function empty(scheduler) {
            return scheduler ? emptyScheduled(scheduler) : exports.EMPTY;
        }
        exports.empty = empty;
        function emptyScheduled(scheduler) {
            return new Observable_1.Observable(function (subscriber) { return scheduler.schedule(function () { return subscriber.complete(); }); });
        }
        exports.emptyScheduled = emptyScheduled;

    },{"../Observable":40}],57:[function(require,module,exports){
        "use strict";
        var __extends = (this && this.__extends) || (function () {
                    var extendStatics = Object.setPrototypeOf ||
                            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
                    return function (d, b) {
                        extendStatics(d, b);
                        function __() { this.constructor = d; }
                        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                    };
                })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var Observable_1 = require("../Observable");
        var isArray_1 = require("../util/isArray");
        var empty_1 = require("./empty");
        var subscribeToResult_1 = require("../util/subscribeToResult");
        var OuterSubscriber_1 = require("../OuterSubscriber");
        var map_1 = require("../operators/map");
        /* tslint:enable:max-line-length */
        /**
         * Joins last values emitted by passed Observables.
         *
         * <span class="informal">Wait for Observables to complete and then combine last values they emitted.</span>
         *
         * <img src="./img/forkJoin.png" width="100%">
         *
         * `forkJoin` is an operator that takes any number of Observables which can be passed either as an array
         * or directly as arguments. If no input Observables are provided, resulting stream will complete
         * immediately.
         *
         * `forkJoin` will wait for all passed Observables to complete and then it will emit an array with last
         * values from corresponding Observables. So if you pass `n` Observables to the operator, resulting
         * array will have `n` values, where first value is the last thing emitted by the first Observable,
         * second value is the last thing emitted by the second Observable and so on. That means `forkJoin` will
         * not emit more than once and it will complete after that. If you need to emit combined values not only
         * at the end of lifecycle of passed Observables, but also throughout it, try out {@link combineLatest}
         * or {@link zip} instead.
         *
         * In order for resulting array to have the same length as the number of input Observables, whenever any of
         * that Observables completes without emitting any value, `forkJoin` will complete at that moment as well
         * and it will not emit anything either, even if it already has some last values from other Observables.
         * Conversely, if there is an Observable that never completes, `forkJoin` will never complete as well,
         * unless at any point some other Observable completes without emitting value, which brings us back to
         * the previous case. Overall, in order for `forkJoin` to emit a value, all Observables passed as arguments
         * have to emit something at least once and complete.
         *
         * If any input Observable errors at some point, `forkJoin` will error as well and all other Observables
         * will be immediately unsubscribed.
         *
         * Optionally `forkJoin` accepts project function, that will be called with values which normally
         * would land in emitted array. Whatever is returned by project function, will appear in output
         * Observable instead. This means that default project can be thought of as a function that takes
         * all its arguments and puts them into an array. Note that project function will be called only
         * when output Observable is supposed to emit a result.
         *
         * @example <caption>Use forkJoin with operator emitting immediately</caption>
         * import { forkJoin, of } from 'rxjs';
         *
         * const observable = forkJoin(
         *   of(1, 2, 3, 4),
         *   of(5, 6, 7, 8)
         * );
         * observable.subscribe(
         *   value => console.log(value),
         *   err => {},
         *   () => console.log('This is how it ends!')
         * );
         *
         * // Logs:
         * // [4, 8]
         * // "This is how it ends!"
         *
         *
         * @example <caption>Use forkJoin with operator emitting after some time</caption>
         * import { forkJoin, interval } from 'rxjs';
         * import { take } from 'rxjs/operators';
         *
         * const observable = forkJoin(
         *   interval(1000).pipe(take(3)), // emit 0, 1, 2 every second and complete
         *   interval(500).pipe(take(4)) // emit 0, 1, 2, 3 every half a second and complete
         * );
         * observable.subscribe(
         *   value => console.log(value),
         *   err => {},
         *   () => console.log('This is how it ends!')
         * );
         *
         * // Logs:
         * // [2, 3] after 3 seconds
         * // "This is how it ends!" immediately after
         *
         *
         * @example <caption>Use forkJoin with project function</caption>
         * import { jorkJoin, interval } from 'rxjs';
         * import { take } from 'rxjs/operators';
         *
         * const observable = forkJoin(
         *   interval(1000).pipe(take(3)), // emit 0, 1, 2 every second and complete
         *   interval(500).pipe(take(4)), // emit 0, 1, 2, 3 every half a second and complete
         *   (n, m) => n + m
         * );
         * observable.subscribe(
         *   value => console.log(value),
         *   err => {},
         *   () => console.log('This is how it ends!')
         * );
         *
         * // Logs:
         * // 5 after 3 seconds
         * // "This is how it ends!" immediately after
         *
         * @see {@link combineLatest}
         * @see {@link zip}
         *
         * @param {...ObservableInput} sources Any number of Observables provided either as an array or as an arguments
         * passed directly to the operator.
         * @param {function} [project] Function that takes values emitted by input Observables and returns value
         * that will appear in resulting Observable instead of default array.
         * @return {Observable} Observable emitting either an array of last values emitted by passed Observables
         * or value from project function.
         */
        function forkJoin() {
            var sources = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                sources[_i] = arguments[_i];
            }
            var resultSelector;
            if (typeof sources[sources.length - 1] === 'function') {
                // DEPRECATED PATH
                resultSelector = sources.pop();
            }
            // if the first and only other argument is an array
            // assume it's been called with `forkJoin([obs1, obs2, obs3])`
            if (sources.length === 1 && isArray_1.isArray(sources[0])) {
                sources = sources[0];
            }
            if (sources.length === 0) {
                return empty_1.EMPTY;
            }
            if (resultSelector) {
                // DEPRECATED PATH
                return forkJoin(sources).pipe(map_1.map(function (args) { return resultSelector.apply(void 0, args); }));
            }
            return new Observable_1.Observable(function (subscriber) {
                return new ForkJoinSubscriber(subscriber, sources);
            });
        }
        exports.forkJoin = forkJoin;
        /**
         * We need this JSDoc comment for affecting ESDoc.
         * @ignore
         * @extends {Ignored}
         */
        var ForkJoinSubscriber = /** @class */ (function (_super) {
            __extends(ForkJoinSubscriber, _super);
            function ForkJoinSubscriber(destination, sources) {
                var _this = _super.call(this, destination) || this;
                _this.sources = sources;
                _this.completed = 0;
                _this.haveValues = 0;
                var len = sources.length;
                _this.values = new Array(len);
                for (var i = 0; i < len; i++) {
                    var source = sources[i];
                    var innerSubscription = subscribeToResult_1.subscribeToResult(_this, source, null, i);
                    if (innerSubscription) {
                        _this.add(innerSubscription);
                    }
                }
                return _this;
            }
            ForkJoinSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
                this.values[outerIndex] = innerValue;
                if (!innerSub._hasValue) {
                    innerSub._hasValue = true;
                    this.haveValues++;
                }
            };
            ForkJoinSubscriber.prototype.notifyComplete = function (innerSub) {
                var _a = this, destination = _a.destination, haveValues = _a.haveValues, values = _a.values;
                var len = values.length;
                if (!innerSub._hasValue) {
                    destination.complete();
                    return;
                }
                this.completed++;
                if (this.completed !== len) {
                    return;
                }
                if (haveValues === len) {
                    destination.next(values);
                }
                destination.complete();
            };
            return ForkJoinSubscriber;
        }(OuterSubscriber_1.OuterSubscriber));

    },{"../Observable":40,"../OuterSubscriber":42,"../operators/map":82,"../util/isArray":113,"../util/subscribeToResult":130,"./empty":56}],58:[function(require,module,exports){
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var Observable_1 = require("../Observable");
        var isPromise_1 = require("../util/isPromise");
        var isArrayLike_1 = require("../util/isArrayLike");
        var isInteropObservable_1 = require("../util/isInteropObservable");
        var isIterable_1 = require("../util/isIterable");
        var fromArray_1 = require("./fromArray");
        var fromPromise_1 = require("./fromPromise");
        var fromIterable_1 = require("./fromIterable");
        var fromObservable_1 = require("./fromObservable");
        var subscribeTo_1 = require("../util/subscribeTo");
        function from(input, scheduler) {
            if (!scheduler) {
                if (input instanceof Observable_1.Observable) {
                    return input;
                }
                return new Observable_1.Observable(subscribeTo_1.subscribeTo(input));
            }
            if (input != null) {
                if (isInteropObservable_1.isInteropObservable(input)) {
                    return fromObservable_1.fromObservable(input, scheduler);
                }
                else if (isPromise_1.isPromise(input)) {
                    return fromPromise_1.fromPromise(input, scheduler);
                }
                else if (isArrayLike_1.isArrayLike(input)) {
                    return fromArray_1.fromArray(input, scheduler);
                }
                else if (isIterable_1.isIterable(input) || typeof input === 'string') {
                    return fromIterable_1.fromIterable(input, scheduler);
                }
            }
            throw new TypeError((input !== null && typeof input || input) + ' is not observable');
        }
        exports.from = from;

    },{"../Observable":40,"../util/isArrayLike":114,"../util/isInteropObservable":116,"../util/isIterable":117,"../util/isPromise":121,"../util/subscribeTo":125,"./fromArray":59,"./fromIterable":62,"./fromObservable":63,"./fromPromise":64}],59:[function(require,module,exports){
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var Observable_1 = require("../Observable");
        var Subscription_1 = require("../Subscription");
        var subscribeToArray_1 = require("../util/subscribeToArray");
        function fromArray(input, scheduler) {
            if (!scheduler) {
                return new Observable_1.Observable(subscribeToArray_1.subscribeToArray(input));
            }
            else {
                return new Observable_1.Observable(function (subscriber) {
                    var sub = new Subscription_1.Subscription();
                    var i = 0;
                    sub.add(scheduler.schedule(function () {
                        if (i === input.length) {
                            subscriber.complete();
                            return;
                        }
                        subscriber.next(input[i++]);
                        if (!subscriber.closed) {
                            sub.add(this.schedule());
                        }
                    }));
                    return sub;
                });
            }
        }
        exports.fromArray = fromArray;

    },{"../Observable":40,"../Subscription":48,"../util/subscribeToArray":126}],60:[function(require,module,exports){
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var Observable_1 = require("../Observable");
        var isArray_1 = require("../util/isArray");
        var isFunction_1 = require("../util/isFunction");
        var map_1 = require("../operators/map");
        var toString = Object.prototype.toString;
        /* tslint:enable:max-line-length */
        /**
         * Creates an Observable that emits events of a specific type coming from the
         * given event target.
         *
         * <span class="informal">Creates an Observable from DOM events, or Node.js
         * EventEmitter events or others.</span>
         *
         * <img src="./img/fromEvent.png" width="100%">
         *
         * `fromEvent` accepts as a first argument event target, which is an object with methods
         * for registering event handler functions. As a second argument it takes string that indicates
         * type of event we want to listen for. `fromEvent` supports selected types of event targets,
         * which are described in detail below. If your event target does not match any of the ones listed,
         * you should use {@link fromEventPattern}, which can be used on arbitrary APIs.
         * When it comes to APIs supported by `fromEvent`, their methods for adding and removing event
         * handler functions have different names, but they all accept a string describing event type
         * and function itself, which will be called whenever said event happens.
         *
         * Every time resulting Observable is subscribed, event handler function will be registered
         * to event target on given event type. When that event fires, value
         * passed as a first argument to registered function will be emitted by output Observable.
         * When Observable is unsubscribed, function will be unregistered from event target.
         *
         * Note that if event target calls registered function with more than one argument, second
         * and following arguments will not appear in resulting stream. In order to get access to them,
         * you can pass to `fromEvent` optional project function, which will be called with all arguments
         * passed to event handler. Output Observable will then emit value returned by project function,
         * instead of the usual value.
         *
         * Remember that event targets listed below are checked via duck typing. It means that
         * no matter what kind of object you have and no matter what environment you work in,
         * you can safely use `fromEvent` on that object if it exposes described methods (provided
         * of course they behave as was described above). So for example if Node.js library exposes
         * event target which has the same method names as DOM EventTarget, `fromEvent` is still
         * a good choice.
         *
         * If the API you use is more callback then event handler oriented (subscribed
         * callback function fires only once and thus there is no need to manually
         * unregister it), you should use {@link bindCallback} or {@link bindNodeCallback}
         * instead.
         *
         * `fromEvent` supports following types of event targets:
         *
         * **DOM EventTarget**
         *
         * This is an object with `addEventListener` and `removeEventListener` methods.
         *
         * In the browser, `addEventListener` accepts - apart from event type string and event
         * handler function arguments - optional third parameter, which is either an object or boolean,
         * both used for additional configuration how and when passed function will be called. When
         * `fromEvent` is used with event target of that type, you can provide this values
         * as third parameter as well.
         *
         * **Node.js EventEmitter**
         *
         * An object with `addListener` and `removeListener` methods.
         *
         * **JQuery-style event target**
         *
         * An object with `on` and `off` methods
         *
         * **DOM NodeList**
         *
         * List of DOM Nodes, returned for example by `document.querySelectorAll` or `Node.childNodes`.
         *
         * Although this collection is not event target in itself, `fromEvent` will iterate over all Nodes
         * it contains and install event handler function in every of them. When returned Observable
         * is unsubscribed, function will be removed from all Nodes.
         *
         * **DOM HtmlCollection**
         *
         * Just as in case of NodeList it is a collection of DOM nodes. Here as well event handler function is
         * installed and removed in each of elements.
         *
         *
         * @example <caption>Emits clicks happening on the DOM document</caption>
         * var clicks = fromEvent(document, 'click');
         * clicks.subscribe(x => console.log(x));
         *
         * // Results in:
         * // MouseEvent object logged to console every time a click
         * // occurs on the document.
         *
         *
         * @example <caption>Use addEventListener with capture option</caption>
         * var clicksInDocument = fromEvent(document, 'click', true); // note optional configuration parameter
         *                                                                          // which will be passed to addEventListener
         * var clicksInDiv = fromEvent(someDivInDocument, 'click');
         *
         * clicksInDocument.subscribe(() => console.log('document'));
         * clicksInDiv.subscribe(() => console.log('div'));
         *
         * // By default events bubble UP in DOM tree, so normally
         * // when we would click on div in document
         * // "div" would be logged first and then "document".
         * // Since we specified optional `capture` option, document
         * // will catch event when it goes DOWN DOM tree, so console
         * // will log "document" and then "div".
         *
         * @see {@link bindCallback}
         * @see {@link bindNodeCallback}
         * @see {@link fromEventPattern}
         *
         * @param {FromEventTarget<T>} target The DOM EventTarget, Node.js
         * EventEmitter, JQuery-like event target, NodeList or HTMLCollection to attach the event handler to.
         * @param {string} eventName The event name of interest, being emitted by the
         * `target`.
         * @param {EventListenerOptions} [options] Options to pass through to addEventListener
         * @return {Observable<T>}
         * @name fromEvent
         */
        function fromEvent(target, eventName, options, resultSelector) {
            if (isFunction_1.isFunction(options)) {
                // DEPRECATED PATH
                resultSelector = options;
                options = undefined;
            }
            if (resultSelector) {
                // DEPRECATED PATH
                return fromEvent(target, eventName, options).pipe(map_1.map(function (args) { return isArray_1.isArray(args) ? resultSelector.apply(void 0, args) : resultSelector(args); }));
            }
            return new Observable_1.Observable(function (subscriber) {
                function handler(e) {
                    if (arguments.length > 1) {
                        subscriber.next(Array.prototype.slice.call(arguments));
                    }
                    else {
                        subscriber.next(e);
                    }
                }
                setupSubscription(target, eventName, handler, subscriber, options);
            });
        }
        exports.fromEvent = fromEvent;
        function setupSubscription(sourceObj, eventName, handler, subscriber, options) {
            var unsubscribe;
            if (isEventTarget(sourceObj)) {
                var source_1 = sourceObj;
                sourceObj.addEventListener(eventName, handler, options);
                unsubscribe = function () { return source_1.removeEventListener(eventName, handler, options); };
            }
            else if (isJQueryStyleEventEmitter(sourceObj)) {
                var source_2 = sourceObj;
                sourceObj.on(eventName, handler);
                unsubscribe = function () { return source_2.off(eventName, handler); };
            }
            else if (isNodeStyleEventEmitter(sourceObj)) {
                var source_3 = sourceObj;
                sourceObj.addListener(eventName, handler);
                unsubscribe = function () { return source_3.removeListener(eventName, handler); };
            }
            else if (sourceObj && sourceObj.length) {
                for (var i = 0, len = sourceObj.length; i < len; i++) {
                    setupSubscription(sourceObj[i], eventName, handler, subscriber, options);
                }
            }
            else {
                throw new TypeError('Invalid event target');
            }
            subscriber.add(unsubscribe);
        }
        function isNodeStyleEventEmitter(sourceObj) {
            return sourceObj && typeof sourceObj.addListener === 'function' && typeof sourceObj.removeListener === 'function';
        }
        function isJQueryStyleEventEmitter(sourceObj) {
            return sourceObj && typeof sourceObj.on === 'function' && typeof sourceObj.off === 'function';
        }
        function isEventTarget(sourceObj) {
            return sourceObj && typeof sourceObj.addEventListener === 'function' && typeof sourceObj.removeEventListener === 'function';
        }

    },{"../Observable":40,"../operators/map":82,"../util/isArray":113,"../util/isFunction":115}],61:[function(require,module,exports){
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var Observable_1 = require("../Observable");
        var isArray_1 = require("../util/isArray");
        var isFunction_1 = require("../util/isFunction");
        var map_1 = require("../operators/map");
        /* tslint:enable:max-line-length */
        /**
         * Creates an Observable from an API based on addHandler/removeHandler
         * functions.
         *
         * <span class="informal">Converts any addHandler/removeHandler API to an
         * Observable.</span>
         *
         * <img src="./img/fromEventPattern.png" width="100%">
         *
         * Creates an Observable by using the `addHandler` and `removeHandler`
         * functions to add and remove the handlers. The `addHandler` is
         * called when the output Observable is subscribed, and `removeHandler` is
         * called when the Subscription is unsubscribed.
         *
         * @example <caption>Emits clicks happening on the DOM document</caption>
         * function addClickHandler(handler) {
 *   document.addEventListener('click', handler);
 * }
         *
         * function removeClickHandler(handler) {
 *   document.removeEventListener('click', handler);
 * }
         *
         * var clicks = fromEventPattern(
         *   addClickHandler,
         *   removeClickHandler
         * );
         * clicks.subscribe(x => console.log(x));
         *
         * @see {@link from}
         * @see {@link fromEvent}
         *
         * @param {function(handler: Function): any} addHandler A function that takes
         * a `handler` function as argument and attaches it somehow to the actual
         * source of events.
         * @param {function(handler: Function, signal?: any): void} [removeHandler] An optional function that
         * takes a `handler` function as argument and removes it in case it was
         * previously attached using `addHandler`. if addHandler returns signal to teardown when remove,
         * removeHandler function will forward it.
         * @return {Observable<T>}
         * @name fromEventPattern
         */
        function fromEventPattern(addHandler, removeHandler, resultSelector) {
            if (resultSelector) {
                // DEPRECATED PATH
                return fromEventPattern(addHandler, removeHandler).pipe(map_1.map(function (args) { return isArray_1.isArray(args) ? resultSelector.apply(void 0, args) : resultSelector(args); }));
            }
            return new Observable_1.Observable(function (subscriber) {
                var handler = function () {
                    var e = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        e[_i] = arguments[_i];
                    }
                    return subscriber.next(e.length === 1 ? e[0] : e);
                };
                var retValue;
                try {
                    retValue = addHandler(handler);
                }
                catch (err) {
                    subscriber.error(err);
                    return undefined;
                }
                if (!isFunction_1.isFunction(removeHandler)) {
                    return undefined;
                }
                return function () { return removeHandler(handler, retValue); };
            });
        }
        exports.fromEventPattern = fromEventPattern;

    },{"../Observable":40,"../operators/map":82,"../util/isArray":113,"../util/isFunction":115}],62:[function(require,module,exports){
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var Observable_1 = require("../Observable");
        var Subscription_1 = require("../Subscription");
        var iterator_1 = require("../symbol/iterator");
        var subscribeToIterable_1 = require("../util/subscribeToIterable");
        function fromIterable(input, scheduler) {
            if (!input) {
                throw new Error('Iterable cannot be null');
            }
            if (!scheduler) {
                return new Observable_1.Observable(subscribeToIterable_1.subscribeToIterable(input));
            }
            else {
                return new Observable_1.Observable(function (subscriber) {
                    var sub = new Subscription_1.Subscription();
                    var iterator;
                    sub.add(function () {
                        // Finalize generators
                        if (iterator && typeof iterator.return === 'function') {
                            iterator.return();
                        }
                    });
                    sub.add(scheduler.schedule(function () {
                        iterator = input[iterator_1.iterator]();
                        sub.add(scheduler.schedule(function () {
                            if (subscriber.closed) {
                                return;
                            }
                            var value;
                            var done;
                            try {
                                var result = iterator.next();
                                value = result.value;
                                done = result.done;
                            }
                            catch (err) {
                                subscriber.error(err);
                                return;
                            }
                            if (done) {
                                subscriber.complete();
                            }
                            else {
                                subscriber.next(value);
                                this.schedule();
                            }
                        }));
                    }));
                    return sub;
                });
            }
        }
        exports.fromIterable = fromIterable;

    },{"../Observable":40,"../Subscription":48,"../symbol/iterator":101,"../util/subscribeToIterable":127}],63:[function(require,module,exports){
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var Observable_1 = require("../Observable");
        var Subscription_1 = require("../Subscription");
        var observable_1 = require("../symbol/observable");
        var subscribeToObservable_1 = require("../util/subscribeToObservable");
        function fromObservable(input, scheduler) {
            if (!scheduler) {
                return new Observable_1.Observable(subscribeToObservable_1.subscribeToObservable(input));
            }
            else {
                return new Observable_1.Observable(function (subscriber) {
                    var sub = new Subscription_1.Subscription();
                    sub.add(scheduler.schedule(function () {
                        var observable = input[observable_1.observable]();
                        sub.add(observable.subscribe({
                            next: function (value) { sub.add(scheduler.schedule(function () { return subscriber.next(value); })); },
                            error: function (err) { sub.add(scheduler.schedule(function () { return subscriber.error(err); })); },
                            complete: function () { sub.add(scheduler.schedule(function () { return subscriber.complete(); })); },
                        }));
                    }));
                    return sub;
                });
            }
        }
        exports.fromObservable = fromObservable;

    },{"../Observable":40,"../Subscription":48,"../symbol/observable":102,"../util/subscribeToObservable":128}],64:[function(require,module,exports){
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var Observable_1 = require("../Observable");
        var Subscription_1 = require("../Subscription");
        var subscribeToPromise_1 = require("../util/subscribeToPromise");
        function fromPromise(input, scheduler) {
            if (!scheduler) {
                return new Observable_1.Observable(subscribeToPromise_1.subscribeToPromise(input));
            }
            else {
                return new Observable_1.Observable(function (subscriber) {
                    var sub = new Subscription_1.Subscription();
                    sub.add(scheduler.schedule(function () { return input.then(function (value) {
                        sub.add(scheduler.schedule(function () {
                            subscriber.next(value);
                            sub.add(scheduler.schedule(function () { return subscriber.complete(); }));
                        }));
                    }, function (err) {
                        sub.add(scheduler.schedule(function () { return subscriber.error(err); }));
                    }); }));
                    return sub;
                });
            }
        }
        exports.fromPromise = fromPromise;

    },{"../Observable":40,"../Subscription":48,"../util/subscribeToPromise":129}],65:[function(require,module,exports){
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var Observable_1 = require("../Observable");
        var identity_1 = require("../util/identity");
        var isScheduler_1 = require("../util/isScheduler");
        function generate(initialStateOrOptions, condition, iterate, resultSelectorOrObservable, scheduler) {
            var resultSelector;
            var initialState;
            if (arguments.length == 1) {
                var options = initialStateOrOptions;
                initialState = options.initialState;
                condition = options.condition;
                iterate = options.iterate;
                resultSelector = options.resultSelector || identity_1.identity;
                scheduler = options.scheduler;
            }
            else if (resultSelectorOrObservable === undefined || isScheduler_1.isScheduler(resultSelectorOrObservable)) {
                initialState = initialStateOrOptions;
                resultSelector = identity_1.identity;
                scheduler = resultSelectorOrObservable;
            }
            else {
                initialState = initialStateOrOptions;
                resultSelector = resultSelectorOrObservable;
            }
            return new Observable_1.Observable(function (subscriber) {
                var state = initialState;
                if (scheduler) {
                    return scheduler.schedule(dispatch, 0, {
                        subscriber: subscriber,
                        iterate: iterate,
                        condition: condition,
                        resultSelector: resultSelector,
                        state: state
                    });
                }
                do {
                    if (condition) {
                        var conditionResult = void 0;
                        try {
                            conditionResult = condition(state);
                        }
                        catch (err) {
                            subscriber.error(err);
                            return undefined;
                        }
                        if (!conditionResult) {
                            subscriber.complete();
                            break;
                        }
                    }
                    var value = void 0;
                    try {
                        value = resultSelector(state);
                    }
                    catch (err) {
                        subscriber.error(err);
                        return undefined;
                    }
                    subscriber.next(value);
                    if (subscriber.closed) {
                        break;
                    }
                    try {
                        state = iterate(state);
                    }
                    catch (err) {
                        subscriber.error(err);
                        return undefined;
                    }
                } while (true);
                return undefined;
            });
        }
        exports.generate = generate;
        function dispatch(state) {
            var subscriber = state.subscriber, condition = state.condition;
            if (subscriber.closed) {
                return undefined;
            }
            if (state.needIterate) {
                try {
                    state.state = state.iterate(state.state);
                }
                catch (err) {
                    subscriber.error(err);
                    return undefined;
                }
            }
            else {
                state.needIterate = true;
            }
            if (condition) {
                var conditionResult = void 0;
                try {
                    conditionResult = condition(state.state);
                }
                catch (err) {
                    subscriber.error(err);
                    return undefined;
                }
                if (!conditionResult) {
                    subscriber.complete();
                    return undefined;
                }
                if (subscriber.closed) {
                    return undefined;
                }
            }
            var value;
            try {
                value = state.resultSelector(state.state);
            }
            catch (err) {
                subscriber.error(err);
                return undefined;
            }
            if (subscriber.closed) {
                return undefined;
            }
            subscriber.next(value);
            if (subscriber.closed) {
                return undefined;
            }
            return this.schedule(state);
        }

    },{"../Observable":40,"../util/identity":112,"../util/isScheduler":122}],66:[function(require,module,exports){
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var defer_1 = require("./defer");
        var empty_1 = require("./empty");
        /**
         * Decides at subscription time which Observable will actually be subscribed.
         *
         * <span class="informal">`If` statement for Observables.</span>
         *
         * `if` accepts a condition function and two Observables. When
         * an Observable returned by the operator is subscribed, condition function will be called.
         * Based on what boolean it returns at that moment, consumer will subscribe either to
         * the first Observable (if condition was true) or to the second (if condition was false). Condition
         * function may also not return anything - in that case condition will be evaluated as false and
         * second Observable will be subscribed.
         *
         * Note that Observables for both cases (true and false) are optional. If condition points to an Observable that
         * was left undefined, resulting stream will simply complete immediately. That allows you to, rather
         * then controlling which Observable will be subscribed, decide at runtime if consumer should have access
         * to given Observable or not.
         *
         * If you have more complex logic that requires decision between more than two Observables, {@link defer}
         * will probably be a better choice. Actually `if` can be easily implemented with {@link defer}
         * and exists only for convenience and readability reasons.
         *
         *
         * @example <caption>Change at runtime which Observable will be subscribed</caption>
         * let subscribeToFirst;
         * const firstOrSecond = Rx.Observable.if(
         *   () => subscribeToFirst,
         *   Rx.Observable.of('first'),
         *   Rx.Observable.of('second')
         * );
         *
         * subscribeToFirst = true;
         * firstOrSecond.subscribe(value => console.log(value));
         *
         * // Logs:
         * // "first"
         *
         * subscribeToFirst = false;
         * firstOrSecond.subscribe(value => console.log(value));
         *
         * // Logs:
         * // "second"
         *
         *
         * @example <caption>Control an access to an Observable</caption>
         * let accessGranted;
         * const observableIfYouHaveAccess = Rx.Observable.if(
         *   () => accessGranted,
         *   Rx.Observable.of('It seems you have an access...') // Note that only one Observable is passed to the operator.
         * );
         *
         * accessGranted = true;
         * observableIfYouHaveAccess.subscribe(
         *   value => console.log(value),
         *   err => {},
         *   () => console.log('The end')
         * );
         *
         * // Logs:
         * // "It seems you have an access..."
         * // "The end"
         *
         * accessGranted = false;
         * observableIfYouHaveAccess.subscribe(
         *   value => console.log(value),
         *   err => {},
         *   () => console.log('The end')
         * );
         *
         * // Logs:
         * // "The end"
         *
         * @see {@link defer}
         *
         * @param {function(): boolean} condition Condition which Observable should be chosen.
         * @param {Observable} [trueObservable] An Observable that will be subscribed if condition is true.
         * @param {Observable} [falseObservable] An Observable that will be subscribed if condition is false.
         * @return {Observable} Either first or second Observable, depending on condition.
         * @static true
         * @name iif
         * @owner Observable
         */
        function iif(condition, trueResult, falseResult) {
            if (trueResult === void 0) { trueResult = empty_1.EMPTY; }
            if (falseResult === void 0) { falseResult = empty_1.EMPTY; }
            return defer_1.defer(function () { return condition() ? trueResult : falseResult; });
        }
        exports.iif = iif;

    },{"./defer":55,"./empty":56}],67:[function(require,module,exports){
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var Observable_1 = require("../Observable");
        var async_1 = require("../scheduler/async");
        var isNumeric_1 = require("../util/isNumeric");
        /**
         * Creates an Observable that emits sequential numbers every specified
         * interval of time, on a specified IScheduler.
         *
         * <span class="informal">Emits incremental numbers periodically in time.
         * </span>
         *
         * <img src="./img/interval.png" width="100%">
         *
         * `interval` returns an Observable that emits an infinite sequence of
         * ascending integers, with a constant interval of time of your choosing
         * between those emissions. The first emission is not sent immediately, but
         * only after the first period has passed. By default, this operator uses the
         * `async` IScheduler to provide a notion of time, but you may pass any
         * IScheduler to it.
         *
         * @example <caption>Emits ascending numbers, one every second (1000ms)</caption>
         * var numbers = Rx.Observable.interval(1000);
         * numbers.subscribe(x => console.log(x));
         *
         * @see {@link timer}
         * @see {@link delay}
         *
         * @param {number} [period=0] The interval size in milliseconds (by default)
         * or the time unit determined by the scheduler's clock.
         * @param {Scheduler} [scheduler=async] The IScheduler to use for scheduling
         * the emission of values, and providing a notion of "time".
         * @return {Observable} An Observable that emits a sequential number each time
         * interval.
         * @static true
         * @name interval
         * @owner Observable
         */
        function interval(period, scheduler) {
            if (period === void 0) { period = 0; }
            if (scheduler === void 0) { scheduler = async_1.async; }
            if (!isNumeric_1.isNumeric(period) || period < 0) {
                period = 0;
            }
            if (!scheduler || typeof scheduler.schedule !== 'function') {
                scheduler = async_1.async;
            }
            return new Observable_1.Observable(function (subscriber) {
                subscriber.add(scheduler.schedule(dispatch, period, { subscriber: subscriber, counter: 0, period: period }));
                return subscriber;
            });
        }
        exports.interval = interval;
        function dispatch(state) {
            var subscriber = state.subscriber, counter = state.counter, period = state.period;
            subscriber.next(counter);
            this.schedule({ subscriber: subscriber, counter: counter + 1, period: period }, period);
        }

    },{"../Observable":40,"../scheduler/async":99,"../util/isNumeric":118}],68:[function(require,module,exports){
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var Observable_1 = require("../Observable");
        var isScheduler_1 = require("../util/isScheduler");
        var mergeAll_1 = require("../operators/mergeAll");
        var fromArray_1 = require("./fromArray");
        /* tslint:enable:max-line-length */
        /**
         * Creates an output Observable which concurrently emits all values from every
         * given input Observable.
         *
         * <span class="informal">Flattens multiple Observables together by blending
         * their values into one Observable.</span>
         *
         * <img src="./img/merge.png" width="100%">
         *
         * `merge` subscribes to each given input Observable (as arguments), and simply
         * forwards (without doing any transformation) all the values from all the input
         * Observables to the output Observable. The output Observable only completes
         * once all input Observables have completed. Any error delivered by an input
         * Observable will be immediately emitted on the output Observable.
         *
         * @example <caption>Merge together two Observables: 1s interval and clicks</caption>
         * var clicks = Rx.Observable.fromEvent(document, 'click');
         * var timer = Rx.Observable.interval(1000);
         * var clicksOrTimer = Rx.Observable.merge(clicks, timer);
         * clicksOrTimer.subscribe(x => console.log(x));
         *
         * // Results in the following:
         * // timer will emit ascending values, one every second(1000ms) to console
         * // clicks logs MouseEvents to console everytime the "document" is clicked
         * // Since the two streams are merged you see these happening
         * // as they occur.
         *
         * @example <caption>Merge together 3 Observables, but only 2 run concurrently</caption>
         * var timer1 = Rx.Observable.interval(1000).take(10);
         * var timer2 = Rx.Observable.interval(2000).take(6);
         * var timer3 = Rx.Observable.interval(500).take(10);
         * var concurrent = 2; // the argument
         * var merged = Rx.Observable.merge(timer1, timer2, timer3, concurrent);
         * merged.subscribe(x => console.log(x));
         *
         * // Results in the following:
         * // - First timer1 and timer2 will run concurrently
         * // - timer1 will emit a value every 1000ms for 10 iterations
         * // - timer2 will emit a value every 2000ms for 6 iterations
         * // - after timer1 hits it's max iteration, timer2 will
         * //   continue, and timer3 will start to run concurrently with timer2
         * // - when timer2 hits it's max iteration it terminates, and
         * //   timer3 will continue to emit a value every 500ms until it is complete
         *
         * @see {@link mergeAll}
         * @see {@link mergeMap}
         * @see {@link mergeMapTo}
         * @see {@link mergeScan}
         *
         * @param {...ObservableInput} observables Input Observables to merge together.
         * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
         * Observables being subscribed to concurrently.
         * @param {Scheduler} [scheduler=null] The IScheduler to use for managing
         * concurrency of input Observables.
         * @return {Observable} an Observable that emits items that are the result of
         * every input Observable.
         * @static true
         * @name merge
         * @owner Observable
         */
        function merge() {
            var observables = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                observables[_i] = arguments[_i];
            }
            var concurrent = Number.POSITIVE_INFINITY;
            var scheduler = null;
            var last = observables[observables.length - 1];
            if (isScheduler_1.isScheduler(last)) {
                scheduler = observables.pop();
                if (observables.length > 1 && typeof observables[observables.length - 1] === 'number') {
                    concurrent = observables.pop();
                }
            }
            else if (typeof last === 'number') {
                concurrent = observables.pop();
            }
            if (scheduler === null && observables.length === 1 && observables[0] instanceof Observable_1.Observable) {
                return observables[0];
            }
            return mergeAll_1.mergeAll(concurrent)(fromArray_1.fromArray(observables, scheduler));
        }
        exports.merge = merge;

    },{"../Observable":40,"../operators/mergeAll":83,"../util/isScheduler":122,"./fromArray":59}],69:[function(require,module,exports){
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var Observable_1 = require("../Observable");
        var noop_1 = require("../util/noop");
        /**
         * An Observable that emits no items to the Observer and never completes.
         *
         * <img src="./img/never.png" width="100%">
         *
         * A simple Observable that emits neither values nor errors nor the completion
         * notification. It can be used for testing purposes or for composing with other
         * Observables. Please note that by never emitting a complete notification, this
         * Observable keeps the subscription from being disposed automatically.
         * Subscriptions need to be manually disposed.
         *
         * @example <caption>Emit the number 7, then never emit anything else (not even complete).</caption>
         * function info() {
 *   console.log('Will not be called');
 * }
         * var result = NEVER.startWith(7);
         * result.subscribe(x => console.log(x), info, info);
         *
         * @see {@link create}
         * @see {@link EMPTY}
         * @see {@link of}
         * @see {@link throwError}
         */
        exports.NEVER = new Observable_1.Observable(noop_1.noop);
        /**
         * @deprecated Deprecated in favor of using NEVER constant.
         */
        function never() {
            return exports.NEVER;
        }
        exports.never = never;

    },{"../Observable":40,"../util/noop":123}],70:[function(require,module,exports){
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var isScheduler_1 = require("../util/isScheduler");
        var fromArray_1 = require("./fromArray");
        var empty_1 = require("./empty");
        var scalar_1 = require("./scalar");
        function of() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var scheduler = args[args.length - 1];
            if (isScheduler_1.isScheduler(scheduler)) {
                args.pop();
            }
            else {
                scheduler = undefined;
            }
            switch (args.length) {
                case 0:
                    return empty_1.empty(scheduler);
                case 1:
                    return scheduler ? fromArray_1.fromArray(args, scheduler) : scalar_1.scalar(args[0]);
                default:
                    return fromArray_1.fromArray(args, scheduler);
            }
        }
        exports.of = of;

    },{"../util/isScheduler":122,"./empty":56,"./fromArray":59,"./scalar":75}],71:[function(require,module,exports){
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var Observable_1 = require("../Observable");
        var from_1 = require("./from");
        var isArray_1 = require("../util/isArray");
        var empty_1 = require("./empty");
        /* tslint:enable:max-line-length */
        /**
         * When any of the provided Observable emits an complete or error notification, it immediately subscribes to the next one
         * that was passed.
         *
         * <span class="informal">Execute series of Observables no matter what, even if it means swallowing errors.</span>
         *
         * <img src="./img/onErrorResumeNext.png" width="100%">
         *
         * `onErrorResumeNext` Will subscribe to each observable source it is provided, in order.
         * If the source it's subscribed to emits an error or completes, it will move to the next source
         * without error.
         *
         * If `onErrorResumeNext` is provided no arguments, or a single, empty array, it will return {@link EMPTY}.
         *
         * `onErrorResumeNext` is basically {@link concat}, only it will continue, even if one of its
         * sources emits an error.
         *
         * Note that there is no way to handle any errors thrown by sources via the resuult of
         * `onErrorResumeNext`. If you want to handle errors thrown in any given source, you can
         * always use the {@link catchError} operator on them before passing them into `onErrorResumeNext`.
         *
         * @example <caption>Subscribe to the next Observable after map fails</caption>
         * import { onErrorResumeNext, of } from 'rxjs/create';
         * import { map } from 'rxjs/operators';
         *
         * onErrorResumeNext(
         *  of(1, 2, 3, 0).pipe(
         *    map(x => {
 *      if (x === 0) throw Error();
 *      return 10 / x;
 *    })
         *  ),
         *  of(1, 2, 3),
         * )
         * .subscribe(
         *   val => console.log(val),
         *   err => console.log(err),          // Will never be called.
         *   () => console.log('done')
         * );
         *
         * // Logs:
         * // 10
         * // 5
         * // 3.3333333333333335
         * // 1
         * // 2
         * // 3
         * // "done"
         *
         * @see {@link concat}
         * @see {@link catch}
         *
         * @param {...ObservableInput} sources Observables (or anything that *is* observable) passed either directly or as an array.
         * @return {Observable} An Observable that concatenates all sources, one after the other,
         * ignoring all errors, such that any error causes it to move on to the next source.
         */
        function onErrorResumeNext() {
            var sources = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                sources[_i] = arguments[_i];
            }
            if (sources.length === 0) {
                return empty_1.EMPTY;
            }
            var first = sources[0], remainder = sources.slice(1);
            if (sources.length === 1 && isArray_1.isArray(first)) {
                return onErrorResumeNext.apply(void 0, first);
            }
            return new Observable_1.Observable(function (subscriber) {
                var subNext = function () { return subscriber.add(onErrorResumeNext.apply(void 0, remainder).subscribe(subscriber)); };
                return from_1.from(first).subscribe({
                    next: function (value) { subscriber.next(value); },
                    error: subNext,
                    complete: subNext,
                });
            });
        }
        exports.onErrorResumeNext = onErrorResumeNext;

    },{"../Observable":40,"../util/isArray":113,"./empty":56,"./from":58}],72:[function(require,module,exports){
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var Observable_1 = require("../Observable");
        var Subscription_1 = require("../Subscription");
        /**
         * Convert an object into an observable sequence of [key, value] pairs
         * using an optional IScheduler to enumerate the object.
         *
         * @example <caption>Converts a javascript object to an Observable</caption>
         * var obj = {
 *   foo: 42,
 *   bar: 56,
 *   baz: 78
 * };
         *
         * var source = Rx.Observable.pairs(obj);
         *
         * var subscription = source.subscribe(
         *   function (x) {
 *     console.log('Next: %s', x);
 *   },
         *   function (err) {
 *     console.log('Error: %s', err);
 *   },
         *   function () {
 *     console.log('Completed');
 *   });
         *
         * @param {Object} obj The object to inspect and turn into an
         * Observable sequence.
         * @param {Scheduler} [scheduler] An optional IScheduler to run the
         * enumeration of the input sequence on.
         * @returns {(Observable<[string, T]>)} An observable sequence of
         * [key, value] pairs from the object.
         */
        function pairs(obj, scheduler) {
            if (!scheduler) {
                return new Observable_1.Observable(function (subscriber) {
                    var keys = Object.keys(obj);
                    for (var i = 0; i < keys.length && !subscriber.closed; i++) {
                        var key = keys[i];
                        if (obj.hasOwnProperty(key)) {
                            subscriber.next([key, obj[key]]);
                        }
                    }
                    subscriber.complete();
                });
            }
            else {
                return new Observable_1.Observable(function (subscriber) {
                    var keys = Object.keys(obj);
                    var subscription = new Subscription_1.Subscription();
                    subscription.add(scheduler.schedule(dispatch, 0, { keys: keys, index: 0, subscriber: subscriber, subscription: subscription, obj: obj }));
                    return subscription;
                });
            }
        }
        exports.pairs = pairs;
        /** @internal */
        function dispatch(state) {
            var keys = state.keys, index = state.index, subscriber = state.subscriber, subscription = state.subscription, obj = state.obj;
            if (!subscriber.closed) {
                if (index < keys.length) {
                    var key = keys[index];
                    subscriber.next([key, obj[key]]);
                    subscription.add(this.schedule({ keys: keys, index: index + 1, subscriber: subscriber, subscription: subscription, obj: obj }));
                }
                else {
                    subscriber.complete();
                }
            }
        }
        exports.dispatch = dispatch;

    },{"../Observable":40,"../Subscription":48}],73:[function(require,module,exports){
        "use strict";
        var __extends = (this && this.__extends) || (function () {
                    var extendStatics = Object.setPrototypeOf ||
                            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
                    return function (d, b) {
                        extendStatics(d, b);
                        function __() { this.constructor = d; }
                        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                    };
                })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var isArray_1 = require("../util/isArray");
        var fromArray_1 = require("./fromArray");
        var OuterSubscriber_1 = require("../OuterSubscriber");
        var subscribeToResult_1 = require("../util/subscribeToResult");
        function race() {
            var observables = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                observables[_i] = arguments[_i];
            }
            // if the only argument is an array, it was most likely called with
            // `race([obs1, obs2, ...])`
            if (observables.length === 1) {
                if (isArray_1.isArray(observables[0])) {
                    observables = observables[0];
                }
                else {
                    return observables[0];
                }
            }
            return fromArray_1.fromArray(observables, undefined).lift(new RaceOperator());
        }
        exports.race = race;
        var RaceOperator = /** @class */ (function () {
            function RaceOperator() {
            }
            RaceOperator.prototype.call = function (subscriber, source) {
                return source.subscribe(new RaceSubscriber(subscriber));
            };
            return RaceOperator;
        }());
        exports.RaceOperator = RaceOperator;
        /**
         * We need this JSDoc comment for affecting ESDoc.
         * @ignore
         * @extends {Ignored}
         */
        var RaceSubscriber = /** @class */ (function (_super) {
            __extends(RaceSubscriber, _super);
            function RaceSubscriber(destination) {
                var _this = _super.call(this, destination) || this;
                _this.hasFirst = false;
                _this.observables = [];
                _this.subscriptions = [];
                return _this;
            }
            RaceSubscriber.prototype._next = function (observable) {
                this.observables.push(observable);
            };
            RaceSubscriber.prototype._complete = function () {
                var observables = this.observables;
                var len = observables.length;
                if (len === 0) {
                    this.destination.complete();
                }
                else {
                    for (var i = 0; i < len && !this.hasFirst; i++) {
                        var observable = observables[i];
                        var subscription = subscribeToResult_1.subscribeToResult(this, observable, observable, i);
                        if (this.subscriptions) {
                            this.subscriptions.push(subscription);
                        }
                        this.add(subscription);
                    }
                    this.observables = null;
                }
            };
            RaceSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
                if (!this.hasFirst) {
                    this.hasFirst = true;
                    for (var i = 0; i < this.subscriptions.length; i++) {
                        if (i !== outerIndex) {
                            var subscription = this.subscriptions[i];
                            subscription.unsubscribe();
                            this.remove(subscription);
                        }
                    }
                    this.subscriptions = null;
                }
                this.destination.next(innerValue);
            };
            return RaceSubscriber;
        }(OuterSubscriber_1.OuterSubscriber));
        exports.RaceSubscriber = RaceSubscriber;

    },{"../OuterSubscriber":42,"../util/isArray":113,"../util/subscribeToResult":130,"./fromArray":59}],74:[function(require,module,exports){
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var Observable_1 = require("../Observable");
        /**
         * Creates an Observable that emits a sequence of numbers within a specified
         * range.
         *
         * <span class="informal">Emits a sequence of numbers in a range.</span>
         *
         * <img src="./img/range.png" width="100%">
         *
         * `range` operator emits a range of sequential integers, in order, where you
         * select the `start` of the range and its `length`. By default, uses no
         * IScheduler and just delivers the notifications synchronously, but may use
         * an optional IScheduler to regulate those deliveries.
         *
         * @example <caption>Emits the numbers 1 to 10</caption>
         * var numbers = Rx.Observable.range(1, 10);
         * numbers.subscribe(x => console.log(x));
         *
         * @see {@link timer}
         * @see {@link interval}
         *
         * @param {number} [start=0] The value of the first integer in the sequence.
         * @param {number} [count=0] The number of sequential integers to generate.
         * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling
         * the emissions of the notifications.
         * @return {Observable} An Observable of numbers that emits a finite range of
         * sequential integers.
         * @static true
         * @name range
         * @owner Observable
         */
        function range(start, count, scheduler) {
            if (start === void 0) { start = 0; }
            if (count === void 0) { count = 0; }
            return new Observable_1.Observable(function (subscriber) {
                var index = 0;
                var current = start;
                if (scheduler) {
                    return scheduler.schedule(dispatch, 0, {
                        index: index, count: count, start: start, subscriber: subscriber
                    });
                }
                else {
                    do {
                        if (index++ >= count) {
                            subscriber.complete();
                            break;
                        }
                        subscriber.next(current++);
                        if (subscriber.closed) {
                            break;
                        }
                    } while (true);
                }
                return undefined;
            });
        }
        exports.range = range;
        /** @internal */
        function dispatch(state) {
            var start = state.start, index = state.index, count = state.count, subscriber = state.subscriber;
            if (index >= count) {
                subscriber.complete();
                return;
            }
            subscriber.next(start);
            if (subscriber.closed) {
                return;
            }
            state.index = index + 1;
            state.start = start + 1;
            this.schedule(state);
        }
        exports.dispatch = dispatch;

    },{"../Observable":40}],75:[function(require,module,exports){
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var Observable_1 = require("../Observable");
        function scalar(value) {
            var result = new Observable_1.Observable(function (subscriber) {
                subscriber.next(value);
                subscriber.complete();
            });
            result._isScalar = true;
            result.value = value;
            return result;
        }
        exports.scalar = scalar;

    },{"../Observable":40}],76:[function(require,module,exports){
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var Observable_1 = require("../Observable");
        /**
         * Creates an Observable that emits no items to the Observer and immediately
         * emits an error notification.
         *
         * <span class="informal">Just emits 'error', and nothing else.
         * </span>
         *
         * <img src="./img/throw.png" width="100%">
         *
         * This static operator is useful for creating a simple Observable that only
         * emits the error notification. It can be used for composing with other
         * Observables, such as in a {@link mergeMap}.
         *
         * @example <caption>Emit the number 7, then emit an error.</caption>
         * import { throwError, concat, of } from 'rxjs/create';
         *
         * const result = concat(of(7), throwError(new Error('oops!')));
         * result.subscribe(x => console.log(x), e => console.error(e));
         *
         * @example <caption>Map and flatten numbers to the sequence 'a', 'b', 'c', but throw an error for 13</caption>
         * import { throwError, interval, of } from 'rxjs/create';
         * import { mergeMap } from 'rxjs/operators';
         *
         * interval(1000).pipe(
         *   mergeMap(x => x === 13 ?
         *     throwError('Thirteens are bad') :
         *     of('a', 'b', 'c')
         *   )
         * ).subscribe(x => console.log(x), e => console.error(e));
         *
         * @see {@link create}
         * @see {@link empty}
         * @see {@link never}
         * @see {@link of}
         *
         * @param {any} error The particular Error to pass to the error notification.
         * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling
         * the emission of the error notification.
         * @return {Observable} An error Observable: emits only the error notification
         * using the given error argument.
         * @static true
         * @name throw
         * @owner Observable
         */
        function throwError(error, scheduler) {
            if (!scheduler) {
                return new Observable_1.Observable(function (subscriber) { return subscriber.error(error); });
            }
            else {
                return new Observable_1.Observable(function (subscriber) { return scheduler.schedule(dispatch, 0, { error: error, subscriber: subscriber }); });
            }
        }
        exports.throwError = throwError;
        function dispatch(_a) {
            var error = _a.error, subscriber = _a.subscriber;
            subscriber.error(error);
        }

    },{"../Observable":40}],77:[function(require,module,exports){
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var Observable_1 = require("../Observable");
        var async_1 = require("../scheduler/async");
        var isNumeric_1 = require("../util/isNumeric");
        var isScheduler_1 = require("../util/isScheduler");
        /**
         * Creates an Observable that starts emitting after an `initialDelay` and
         * emits ever increasing numbers after each `period` of time thereafter.
         *
         * <span class="informal">Its like {@link interval}, but you can specify when
         * should the emissions start.</span>
         *
         * <img src="./img/timer.png" width="100%">
         *
         * `timer` returns an Observable that emits an infinite sequence of ascending
         * integers, with a constant interval of time, `period` of your choosing
         * between those emissions. The first emission happens after the specified
         * `initialDelay`. The initial delay may be a {@link Date}. By default, this
         * operator uses the `async` IScheduler to provide a notion of time, but you
         * may pass any IScheduler to it. If `period` is not specified, the output
         * Observable emits only one value, `0`. Otherwise, it emits an infinite
         * sequence.
         *
         * @example <caption>Emits ascending numbers, one every second (1000ms), starting after 3 seconds</caption>
         * var numbers = Rx.Observable.timer(3000, 1000);
         * numbers.subscribe(x => console.log(x));
         *
         * @example <caption>Emits one number after five seconds</caption>
         * var numbers = Rx.Observable.timer(5000);
         * numbers.subscribe(x => console.log(x));
         *
         * @see {@link interval}
         * @see {@link delay}
         *
         * @param {number|Date} [dueTime] The initial delay time to wait before
         * emitting the first value of `0`.
         * @param {number|SchedulerLike} [periodOrScheduler] The period of time between emissions of the
         * subsequent numbers.
         * @param {SchedulerLike} [scheduler=async] The IScheduler to use for scheduling
         * the emission of values, and providing a notion of "time".
         * @return {Observable} An Observable that emits a `0` after the
         * `initialDelay` and ever increasing numbers after each `period` of time
         * thereafter.
         * @static true
         * @name timer
         * @owner Observable
         */
        function timer(dueTime, periodOrScheduler, scheduler) {
            if (dueTime === void 0) { dueTime = 0; }
            var period = -1;
            if (isNumeric_1.isNumeric(periodOrScheduler)) {
                period = Number(periodOrScheduler) < 1 && 1 || Number(periodOrScheduler);
            }
            else if (isScheduler_1.isScheduler(periodOrScheduler)) {
                scheduler = periodOrScheduler;
            }
            if (!isScheduler_1.isScheduler(scheduler)) {
                scheduler = async_1.async;
            }
            return new Observable_1.Observable(function (subscriber) {
                var due = isNumeric_1.isNumeric(dueTime)
                        ? dueTime
                        : (+dueTime - scheduler.now());
                return scheduler.schedule(dispatch, due, {
                    index: 0, period: period, subscriber: subscriber
                });
            });
        }
        exports.timer = timer;
        function dispatch(state) {
            var index = state.index, period = state.period, subscriber = state.subscriber;
            subscriber.next(index);
            if (subscriber.closed) {
                return;
            }
            else if (period === -1) {
                return subscriber.complete();
            }
            state.index = index + 1;
            this.schedule(state, period);
        }

    },{"../Observable":40,"../scheduler/async":99,"../util/isNumeric":118,"../util/isScheduler":122}],78:[function(require,module,exports){
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var Observable_1 = require("../Observable");
        var from_1 = require("./from"); // from from from! LAWL
        var empty_1 = require("./empty");
        /**
         * Creates an Observable that uses a resource which will be disposed at the same time as the Observable.
         *
         * <span class="informal">Use it when you catch yourself cleaning up after an Observable.</span>
         *
         * `using` is a factory operator, which accepts two functions. First function returns a disposable resource.
         * It can be an arbitrary object that implements `unsubscribe` method. Second function will be injected with
         * that object and should return an Observable. That Observable can use resource object during its execution.
         * Both functions passed to `using` will be called every time someone subscribes - neither an Observable nor
         * resource object will be shared in any way between subscriptions.
         *
         * When Observable returned by `using` is subscribed, Observable returned from the second function will be subscribed
         * as well. All its notifications (nexted values, completion and error events) will be emitted unchanged by the output
         * Observable. If however someone unsubscribes from the Observable or source Observable completes or errors by itself,
         * the `unsubscribe` method on resource object will be called. This can be used to do any necessary clean up, which
         * otherwise would have to be handled by hand. Note that complete or error notifications are not emitted when someone
         * cancels subscription to an Observable via `unsubscribe`, so `using` can be used as a hook, allowing you to make
         * sure that all resources which need to exist during an Observable execution will be disposed at appropriate time.
         *
         * @see {@link defer}
         *
         * @param {function(): ISubscription} resourceFactory A function which creates any resource object
         * that implements `unsubscribe` method.
         * @param {function(resource: ISubscription): Observable<T>} observableFactory A function which
         * creates an Observable, that can use injected resource object.
         * @return {Observable<T>} An Observable that behaves the same as Observable returned by `observableFactory`, but
         * which - when completed, errored or unsubscribed - will also call `unsubscribe` on created resource object.
         */
        function using(resourceFactory, observableFactory) {
            return new Observable_1.Observable(function (subscriber) {
                var resource;
                try {
                    resource = resourceFactory();
                }
                catch (err) {
                    subscriber.error(err);
                    return undefined;
                }
                var result;
                try {
                    result = observableFactory(resource);
                }
                catch (err) {
                    subscriber.error(err);
                    return undefined;
                }
                var source = result ? from_1.from(result) : empty_1.EMPTY;
                var subscription = source.subscribe(subscriber);
                return function () {
                    subscription.unsubscribe();
                    if (resource) {
                        resource.unsubscribe();
                    }
                };
            });
        }
        exports.using = using;

    },{"../Observable":40,"./empty":56,"./from":58}],79:[function(require,module,exports){
        "use strict";
        var __extends = (this && this.__extends) || (function () {
                    var extendStatics = Object.setPrototypeOf ||
                            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
                    return function (d, b) {
                        extendStatics(d, b);
                        function __() { this.constructor = d; }
                        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                    };
                })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var fromArray_1 = require("./fromArray");
        var isArray_1 = require("../util/isArray");
        var Subscriber_1 = require("../Subscriber");
        var OuterSubscriber_1 = require("../OuterSubscriber");
        var subscribeToResult_1 = require("../util/subscribeToResult");
        var iterator_1 = require("../../internal/symbol/iterator");
        /* tslint:enable:max-line-length */
        /**
         * Combines multiple Observables to create an Observable whose values are calculated from the values, in order, of each
         * of its input Observables.
         *
         * If the latest parameter is a function, this function is used to compute the created value from the input values.
         * Otherwise, an array of the input values is returned.
         *
         * @example <caption>Combine age and name from different sources</caption>
         *
         * let age$ = Observable.of<number>(27, 25, 29);
         * let name$ = Observable.of<string>('Foo', 'Bar', 'Beer');
         * let isDev$ = Observable.of<boolean>(true, true, false);
         *
         * Observable
         *     .zip(age$,
         *          name$,
         *          isDev$,
         *          (age: number, name: string, isDev: boolean) => ({ age, name, isDev }))
         *     .subscribe(x => console.log(x));
         *
         * // outputs
         * // { age: 27, name: 'Foo', isDev: true }
         * // { age: 25, name: 'Bar', isDev: true }
         * // { age: 29, name: 'Beer', isDev: false }
         *
         * @param observables
         * @return {Observable<R>}
         * @static true
         * @name zip
         * @owner Observable
         */
        function zip() {
            var observables = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                observables[_i] = arguments[_i];
            }
            var resultSelector = observables[observables.length - 1];
            if (typeof resultSelector === 'function') {
                observables.pop();
            }
            return fromArray_1.fromArray(observables, undefined).lift(new ZipOperator(resultSelector));
        }
        exports.zip = zip;
        var ZipOperator = /** @class */ (function () {
            function ZipOperator(resultSelector) {
                this.resultSelector = resultSelector;
            }
            ZipOperator.prototype.call = function (subscriber, source) {
                return source.subscribe(new ZipSubscriber(subscriber, this.resultSelector));
            };
            return ZipOperator;
        }());
        exports.ZipOperator = ZipOperator;
        /**
         * We need this JSDoc comment for affecting ESDoc.
         * @ignore
         * @extends {Ignored}
         */
        var ZipSubscriber = /** @class */ (function (_super) {
            __extends(ZipSubscriber, _super);
            function ZipSubscriber(destination, resultSelector, values) {
                if (values === void 0) { values = Object.create(null); }
                var _this = _super.call(this, destination) || this;
                _this.iterators = [];
                _this.active = 0;
                _this.resultSelector = (typeof resultSelector === 'function') ? resultSelector : null;
                _this.values = values;
                return _this;
            }
            ZipSubscriber.prototype._next = function (value) {
                var iterators = this.iterators;
                if (isArray_1.isArray(value)) {
                    iterators.push(new StaticArrayIterator(value));
                }
                else if (typeof value[iterator_1.iterator] === 'function') {
                    iterators.push(new StaticIterator(value[iterator_1.iterator]()));
                }
                else {
                    iterators.push(new ZipBufferIterator(this.destination, this, value));
                }
            };
            ZipSubscriber.prototype._complete = function () {
                var iterators = this.iterators;
                var len = iterators.length;
                if (len === 0) {
                    this.destination.complete();
                    return;
                }
                this.active = len;
                for (var i = 0; i < len; i++) {
                    var iterator = iterators[i];
                    if (iterator.stillUnsubscribed) {
                        this.add(iterator.subscribe(iterator, i));
                    }
                    else {
                        this.active--; // not an observable
                    }
                }
            };
            ZipSubscriber.prototype.notifyInactive = function () {
                this.active--;
                if (this.active === 0) {
                    this.destination.complete();
                }
            };
            ZipSubscriber.prototype.checkIterators = function () {
                var iterators = this.iterators;
                var len = iterators.length;
                var destination = this.destination;
                // abort if not all of them have values
                for (var i = 0; i < len; i++) {
                    var iterator = iterators[i];
                    if (typeof iterator.hasValue === 'function' && !iterator.hasValue()) {
                        return;
                    }
                }
                var shouldComplete = false;
                var args = [];
                for (var i = 0; i < len; i++) {
                    var iterator = iterators[i];
                    var result = iterator.next();
                    // check to see if it's completed now that you've gotten
                    // the next value.
                    if (iterator.hasCompleted()) {
                        shouldComplete = true;
                    }
                    if (result.done) {
                        destination.complete();
                        return;
                    }
                    args.push(result.value);
                }
                if (this.resultSelector) {
                    this._tryresultSelector(args);
                }
                else {
                    destination.next(args);
                }
                if (shouldComplete) {
                    destination.complete();
                }
            };
            ZipSubscriber.prototype._tryresultSelector = function (args) {
                var result;
                try {
                    result = this.resultSelector.apply(this, args);
                }
                catch (err) {
                    this.destination.error(err);
                    return;
                }
                this.destination.next(result);
            };
            return ZipSubscriber;
        }(Subscriber_1.Subscriber));
        exports.ZipSubscriber = ZipSubscriber;
        var StaticIterator = /** @class */ (function () {
            function StaticIterator(iterator) {
                this.iterator = iterator;
                this.nextResult = iterator.next();
            }
            StaticIterator.prototype.hasValue = function () {
                return true;
            };
            StaticIterator.prototype.next = function () {
                var result = this.nextResult;
                this.nextResult = this.iterator.next();
                return result;
            };
            StaticIterator.prototype.hasCompleted = function () {
                var nextResult = this.nextResult;
                return nextResult && nextResult.done;
            };
            return StaticIterator;
        }());
        var StaticArrayIterator = /** @class */ (function () {
            function StaticArrayIterator(array) {
                this.array = array;
                this.index = 0;
                this.length = 0;
                this.length = array.length;
            }
            StaticArrayIterator.prototype[iterator_1.iterator] = function () {
                return this;
            };
            StaticArrayIterator.prototype.next = function (value) {
                var i = this.index++;
                var array = this.array;
                return i < this.length ? { value: array[i], done: false } : { value: null, done: true };
            };
            StaticArrayIterator.prototype.hasValue = function () {
                return this.array.length > this.index;
            };
            StaticArrayIterator.prototype.hasCompleted = function () {
                return this.array.length === this.index;
            };
            return StaticArrayIterator;
        }());
        /**
         * We need this JSDoc comment for affecting ESDoc.
         * @ignore
         * @extends {Ignored}
         */
        var ZipBufferIterator = /** @class */ (function (_super) {
            __extends(ZipBufferIterator, _super);
            function ZipBufferIterator(destination, parent, observable) {
                var _this = _super.call(this, destination) || this;
                _this.parent = parent;
                _this.observable = observable;
                _this.stillUnsubscribed = true;
                _this.buffer = [];
                _this.isComplete = false;
                return _this;
            }
            ZipBufferIterator.prototype[iterator_1.iterator] = function () {
                return this;
            };
            // NOTE: there is actually a name collision here with Subscriber.next and Iterator.next
            //    this is legit because `next()` will never be called by a subscription in this case.
            ZipBufferIterator.prototype.next = function () {
                var buffer = this.buffer;
                if (buffer.length === 0 && this.isComplete) {
                    return { value: null, done: true };
                }
                else {
                    return { value: buffer.shift(), done: false };
                }
            };
            ZipBufferIterator.prototype.hasValue = function () {
                return this.buffer.length > 0;
            };
            ZipBufferIterator.prototype.hasCompleted = function () {
                return this.buffer.length === 0 && this.isComplete;
            };
            ZipBufferIterator.prototype.notifyComplete = function () {
                if (this.buffer.length > 0) {
                    this.isComplete = true;
                    this.parent.notifyInactive();
                }
                else {
                    this.destination.complete();
                }
            };
            ZipBufferIterator.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
                this.buffer.push(innerValue);
                this.parent.checkIterators();
            };
            ZipBufferIterator.prototype.subscribe = function (value, index) {
                return subscribeToResult_1.subscribeToResult(this, this.observable, this, index);
            };
            return ZipBufferIterator;
        }(OuterSubscriber_1.OuterSubscriber));

    },{"../../internal/symbol/iterator":101,"../OuterSubscriber":42,"../Subscriber":47,"../util/isArray":113,"../util/subscribeToResult":130,"./fromArray":59}],80:[function(require,module,exports){
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var mergeAll_1 = require("./mergeAll");
        /**
         * Converts a higher-order Observable into a first-order Observable by
         * concatenating the inner Observables in order.
         *
         * <span class="informal">Flattens an Observable-of-Observables by putting one
         * inner Observable after the other.</span>
         *
         * <img src="./img/concatAll.png" width="100%">
         *
         * Joins every Observable emitted by the source (a higher-order Observable), in
         * a serial fashion. It subscribes to each inner Observable only after the
         * previous inner Observable has completed, and merges all of their values into
         * the returned observable.
         *
         * __Warning:__ If the source Observable emits Observables quickly and
         * endlessly, and the inner Observables it emits generally complete slower than
         * the source emits, you can run into memory issues as the incoming Observables
         * collect in an unbounded buffer.
         *
         * Note: `concatAll` is equivalent to `mergeAll` with concurrency parameter set
         * to `1`.
         *
         * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>
         * var clicks = Rx.Observable.fromEvent(document, 'click');
         * var higherOrder = clicks.map(ev => Rx.Observable.interval(1000).take(4));
         * var firstOrder = higherOrder.concatAll();
         * firstOrder.subscribe(x => console.log(x));
         *
         * // Results in the following:
         * // (results are not concurrent)
         * // For every click on the "document" it will emit values 0 to 3 spaced
         * // on a 1000ms interval
         * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3
         *
         * @see {@link combineAll}
         * @see {@link concat}
         * @see {@link concatMap}
         * @see {@link concatMapTo}
         * @see {@link exhaust}
         * @see {@link mergeAll}
         * @see {@link switch}
         * @see {@link zipAll}
         *
         * @return {Observable} An Observable emitting values from all the inner
         * Observables concatenated.
         * @method concatAll
         * @owner Observable
         */
        function concatAll() {
            return mergeAll_1.mergeAll(1);
        }
        exports.concatAll = concatAll;

    },{"./mergeAll":83}],81:[function(require,module,exports){
        "use strict";
        var __extends = (this && this.__extends) || (function () {
                    var extendStatics = Object.setPrototypeOf ||
                            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
                    return function (d, b) {
                        extendStatics(d, b);
                        function __() { this.constructor = d; }
                        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                    };
                })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var Subscriber_1 = require("../Subscriber");
        var Subscription_1 = require("../Subscription");
        var Observable_1 = require("../Observable");
        var Subject_1 = require("../Subject");
        /* tslint:enable:max-line-length */
        /**
         * Groups the items emitted by an Observable according to a specified criterion,
         * and emits these grouped items as `GroupedObservables`, one
         * {@link GroupedObservable} per group.
         *
         * <img src="./img/groupBy.png" width="100%">
         *
         * @example <caption>Group objects by id and return as array</caption>
         * Observable.of<Obj>({id: 1, name: 'aze1'},
         *                    {id: 2, name: 'sf2'},
         *                    {id: 2, name: 'dg2'},
         *                    {id: 1, name: 'erg1'},
         *                    {id: 1, name: 'df1'},
         *                    {id: 2, name: 'sfqfb2'},
         *                    {id: 3, name: 'qfs3'},
         *                    {id: 2, name: 'qsgqsfg2'}
         *     )
         *     .groupBy(p => p.id)
         *     .flatMap( (group$) => group$.reduce((acc, cur) => [...acc, cur], []))
         *     .subscribe(p => console.log(p));
         *
         * // displays:
         * // [ { id: 1, name: 'aze1' },
         * //   { id: 1, name: 'erg1' },
         * //   { id: 1, name: 'df1' } ]
         * //
         * // [ { id: 2, name: 'sf2' },
         * //   { id: 2, name: 'dg2' },
         * //   { id: 2, name: 'sfqfb2' },
         * //   { id: 2, name: 'qsgqsfg2' } ]
         * //
         * // [ { id: 3, name: 'qfs3' } ]
         *
         * @example <caption>Pivot data on the id field</caption>
         * Observable.of<Obj>({id: 1, name: 'aze1'},
         *                    {id: 2, name: 'sf2'},
         *                    {id: 2, name: 'dg2'},
         *                    {id: 1, name: 'erg1'},
         *                    {id: 1, name: 'df1'},
         *                    {id: 2, name: 'sfqfb2'},
         *                    {id: 3, name: 'qfs1'},
         *                    {id: 2, name: 'qsgqsfg2'}
         *                   )
         *     .groupBy(p => p.id, p => p.name)
         *     .flatMap( (group$) => group$.reduce((acc, cur) => [...acc, cur], ["" + group$.key]))
         *     .map(arr => ({'id': parseInt(arr[0]), 'values': arr.slice(1)}))
         *     .subscribe(p => console.log(p));
         *
         * // displays:
         * // { id: 1, values: [ 'aze1', 'erg1', 'df1' ] }
         * // { id: 2, values: [ 'sf2', 'dg2', 'sfqfb2', 'qsgqsfg2' ] }
         * // { id: 3, values: [ 'qfs1' ] }
         *
         * @param {function(value: T): K} keySelector A function that extracts the key
         * for each item.
         * @param {function(value: T): R} [elementSelector] A function that extracts the
         * return element for each item.
         * @param {function(grouped: GroupedObservable<K,R>): Observable<any>} [durationSelector]
         * A function that returns an Observable to determine how long each group should
         * exist.
         * @return {Observable<GroupedObservable<K,R>>} An Observable that emits
         * GroupedObservables, each of which corresponds to a unique key value and each
         * of which emits those items from the source Observable that share that key
         * value.
         * @method groupBy
         * @owner Observable
         */
        function groupBy(keySelector, elementSelector, durationSelector, subjectSelector) {
            return function (source) {
                return source.lift(new GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector));
            };
        }
        exports.groupBy = groupBy;
        var GroupByOperator = /** @class */ (function () {
            function GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector) {
                this.keySelector = keySelector;
                this.elementSelector = elementSelector;
                this.durationSelector = durationSelector;
                this.subjectSelector = subjectSelector;
            }
            GroupByOperator.prototype.call = function (subscriber, source) {
                return source.subscribe(new GroupBySubscriber(subscriber, this.keySelector, this.elementSelector, this.durationSelector, this.subjectSelector));
            };
            return GroupByOperator;
        }());
        /**
         * We need this JSDoc comment for affecting ESDoc.
         * @ignore
         * @extends {Ignored}
         */
        var GroupBySubscriber = /** @class */ (function (_super) {
            __extends(GroupBySubscriber, _super);
            function GroupBySubscriber(destination, keySelector, elementSelector, durationSelector, subjectSelector) {
                var _this = _super.call(this, destination) || this;
                _this.keySelector = keySelector;
                _this.elementSelector = elementSelector;
                _this.durationSelector = durationSelector;
                _this.subjectSelector = subjectSelector;
                _this.groups = null;
                _this.attemptedToUnsubscribe = false;
                _this.count = 0;
                return _this;
            }
            GroupBySubscriber.prototype._next = function (value) {
                var key;
                try {
                    key = this.keySelector(value);
                }
                catch (err) {
                    this.error(err);
                    return;
                }
                this._group(value, key);
            };
            GroupBySubscriber.prototype._group = function (value, key) {
                var groups = this.groups;
                if (!groups) {
                    groups = this.groups = new Map();
                }
                var group = groups.get(key);
                var element;
                if (this.elementSelector) {
                    try {
                        element = this.elementSelector(value);
                    }
                    catch (err) {
                        this.error(err);
                    }
                }
                else {
                    element = value;
                }
                if (!group) {
                    group = (this.subjectSelector ? this.subjectSelector() : new Subject_1.Subject());
                    groups.set(key, group);
                    var groupedObservable = new GroupedObservable(key, group, this);
                    this.destination.next(groupedObservable);
                    if (this.durationSelector) {
                        var duration = void 0;
                        try {
                            duration = this.durationSelector(new GroupedObservable(key, group));
                        }
                        catch (err) {
                            this.error(err);
                            return;
                        }
                        this.add(duration.subscribe(new GroupDurationSubscriber(key, group, this)));
                    }
                }
                if (!group.closed) {
                    group.next(element);
                }
            };
            GroupBySubscriber.prototype._error = function (err) {
                var groups = this.groups;
                if (groups) {
                    groups.forEach(function (group, key) {
                        group.error(err);
                    });
                    groups.clear();
                }
                this.destination.error(err);
            };
            GroupBySubscriber.prototype._complete = function () {
                var groups = this.groups;
                if (groups) {
                    groups.forEach(function (group, key) {
                        group.complete();
                    });
                    groups.clear();
                }
                this.destination.complete();
            };
            GroupBySubscriber.prototype.removeGroup = function (key) {
                this.groups.delete(key);
            };
            GroupBySubscriber.prototype.unsubscribe = function () {
                if (!this.closed) {
                    this.attemptedToUnsubscribe = true;
                    if (this.count === 0) {
                        _super.prototype.unsubscribe.call(this);
                    }
                }
            };
            return GroupBySubscriber;
        }(Subscriber_1.Subscriber));
        /**
         * We need this JSDoc comment for affecting ESDoc.
         * @ignore
         * @extends {Ignored}
         */
        var GroupDurationSubscriber = /** @class */ (function (_super) {
            __extends(GroupDurationSubscriber, _super);
            function GroupDurationSubscriber(key, group, parent) {
                var _this = _super.call(this, group) || this;
                _this.key = key;
                _this.group = group;
                _this.parent = parent;
                return _this;
            }
            GroupDurationSubscriber.prototype._next = function (value) {
                this.complete();
            };
            /** @deprecated This is an internal implementation detail, do not use. */
            GroupDurationSubscriber.prototype._unsubscribe = function () {
                var _a = this, parent = _a.parent, key = _a.key;
                this.key = this.parent = null;
                if (parent) {
                    parent.removeGroup(key);
                }
            };
            return GroupDurationSubscriber;
        }(Subscriber_1.Subscriber));
        /**
         * An Observable representing values belonging to the same group represented by
         * a common key. The values emitted by a GroupedObservable come from the source
         * Observable. The common key is available as the field `key` on a
         * GroupedObservable instance.
         *
         * @class GroupedObservable<K, T>
         */
        var GroupedObservable = /** @class */ (function (_super) {
            __extends(GroupedObservable, _super);
            /** @deprecated Do not construct this type. Internal use only */
            function GroupedObservable(key, groupSubject, refCountSubscription) {
                var _this = _super.call(this) || this;
                _this.key = key;
                _this.groupSubject = groupSubject;
                _this.refCountSubscription = refCountSubscription;
                return _this;
            }
            /** @deprecated This is an internal implementation detail, do not use. */
            GroupedObservable.prototype._subscribe = function (subscriber) {
                var subscription = new Subscription_1.Subscription();
                var _a = this, refCountSubscription = _a.refCountSubscription, groupSubject = _a.groupSubject;
                if (refCountSubscription && !refCountSubscription.closed) {
                    subscription.add(new InnerRefCountSubscription(refCountSubscription));
                }
                subscription.add(groupSubject.subscribe(subscriber));
                return subscription;
            };
            return GroupedObservable;
        }(Observable_1.Observable));
        exports.GroupedObservable = GroupedObservable;
        /**
         * We need this JSDoc comment for affecting ESDoc.
         * @ignore
         * @extends {Ignored}
         */
        var InnerRefCountSubscription = /** @class */ (function (_super) {
            __extends(InnerRefCountSubscription, _super);
            function InnerRefCountSubscription(parent) {
                var _this = _super.call(this) || this;
                _this.parent = parent;
                parent.count++;
                return _this;
            }
            InnerRefCountSubscription.prototype.unsubscribe = function () {
                var parent = this.parent;
                if (!parent.closed && !this.closed) {
                    _super.prototype.unsubscribe.call(this);
                    parent.count -= 1;
                    if (parent.count === 0 && parent.attemptedToUnsubscribe) {
                        parent.unsubscribe();
                    }
                }
            };
            return InnerRefCountSubscription;
        }(Subscription_1.Subscription));

    },{"../Observable":40,"../Subject":45,"../Subscriber":47,"../Subscription":48}],82:[function(require,module,exports){
        "use strict";
        var __extends = (this && this.__extends) || (function () {
                    var extendStatics = Object.setPrototypeOf ||
                            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
                    return function (d, b) {
                        extendStatics(d, b);
                        function __() { this.constructor = d; }
                        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                    };
                })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var Subscriber_1 = require("../Subscriber");
        /**
         * Applies a given `project` function to each value emitted by the source
         * Observable, and emits the resulting values as an Observable.
         *
         * <span class="informal">Like [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map),
         * it passes each source value through a transformation function to get
         * corresponding output values.</span>
         *
         * <img src="./img/map.png" width="100%">
         *
         * Similar to the well known `Array.prototype.map` function, this operator
         * applies a projection to each value and emits that projection in the output
         * Observable.
         *
         * @example <caption>Map every click to the clientX position of that click</caption>
         * var clicks = Rx.Observable.fromEvent(document, 'click');
         * var positions = clicks.map(ev => ev.clientX);
         * positions.subscribe(x => console.log(x));
         *
         * @see {@link mapTo}
         * @see {@link pluck}
         *
         * @param {function(value: T, index: number): R} project The function to apply
         * to each `value` emitted by the source Observable. The `index` parameter is
         * the number `i` for the i-th emission that has happened since the
         * subscription, starting from the number `0`.
         * @param {any} [thisArg] An optional argument to define what `this` is in the
         * `project` function.
         * @return {Observable<R>} An Observable that emits the values from the source
         * Observable transformed by the given `project` function.
         * @method map
         * @owner Observable
         */
        function map(project, thisArg) {
            return function mapOperation(source) {
                if (typeof project !== 'function') {
                    throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');
                }
                return source.lift(new MapOperator(project, thisArg));
            };
        }
        exports.map = map;
        var MapOperator = /** @class */ (function () {
            function MapOperator(project, thisArg) {
                this.project = project;
                this.thisArg = thisArg;
            }
            MapOperator.prototype.call = function (subscriber, source) {
                return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));
            };
            return MapOperator;
        }());
        exports.MapOperator = MapOperator;
        /**
         * We need this JSDoc comment for affecting ESDoc.
         * @ignore
         * @extends {Ignored}
         */
        var MapSubscriber = /** @class */ (function (_super) {
            __extends(MapSubscriber, _super);
            function MapSubscriber(destination, project, thisArg) {
                var _this = _super.call(this, destination) || this;
                _this.project = project;
                _this.count = 0;
                _this.thisArg = thisArg || _this;
                return _this;
            }
            // NOTE: This looks unoptimized, but it's actually purposefully NOT
            // using try/catch optimizations.
            MapSubscriber.prototype._next = function (value) {
                var result;
                try {
                    result = this.project.call(this.thisArg, value, this.count++);
                }
                catch (err) {
                    this.destination.error(err);
                    return;
                }
                this.destination.next(result);
            };
            return MapSubscriber;
        }(Subscriber_1.Subscriber));

    },{"../Subscriber":47}],83:[function(require,module,exports){
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var mergeMap_1 = require("./mergeMap");
        var identity_1 = require("../util/identity");
        /**
         * Converts a higher-order Observable into a first-order Observable which
         * concurrently delivers all values that are emitted on the inner Observables.
         *
         * <span class="informal">Flattens an Observable-of-Observables.</span>
         *
         * <img src="./img/mergeAll.png" width="100%">
         *
         * `mergeAll` subscribes to an Observable that emits Observables, also known as
         * a higher-order Observable. Each time it observes one of these emitted inner
         * Observables, it subscribes to that and delivers all the values from the
         * inner Observable on the output Observable. The output Observable only
         * completes once all inner Observables have completed. Any error delivered by
         * a inner Observable will be immediately emitted on the output Observable.
         *
         * @example <caption>Spawn a new interval Observable for each click event, and blend their outputs as one Observable</caption>
         * var clicks = Rx.Observable.fromEvent(document, 'click');
         * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000));
         * var firstOrder = higherOrder.mergeAll();
         * firstOrder.subscribe(x => console.log(x));
         *
         * @example <caption>Count from 0 to 9 every second for each click, but only allow 2 concurrent timers</caption>
         * var clicks = Rx.Observable.fromEvent(document, 'click');
         * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000).take(10));
         * var firstOrder = higherOrder.mergeAll(2);
         * firstOrder.subscribe(x => console.log(x));
         *
         * @see {@link combineAll}
         * @see {@link concatAll}
         * @see {@link exhaust}
         * @see {@link merge}
         * @see {@link mergeMap}
         * @see {@link mergeMapTo}
         * @see {@link mergeScan}
         * @see {@link switch}
         * @see {@link zipAll}
         *
         * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of inner
         * Observables being subscribed to concurrently.
         * @return {Observable} An Observable that emits values coming from all the
         * inner Observables emitted by the source Observable.
         * @method mergeAll
         * @owner Observable
         */
        function mergeAll(concurrent) {
            if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
            return mergeMap_1.mergeMap(identity_1.identity, concurrent);
        }
        exports.mergeAll = mergeAll;

    },{"../util/identity":112,"./mergeMap":84}],84:[function(require,module,exports){
        "use strict";
        var __extends = (this && this.__extends) || (function () {
                    var extendStatics = Object.setPrototypeOf ||
                            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
                    return function (d, b) {
                        extendStatics(d, b);
                        function __() { this.constructor = d; }
                        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                    };
                })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var subscribeToResult_1 = require("../util/subscribeToResult");
        var OuterSubscriber_1 = require("../OuterSubscriber");
        var map_1 = require("./map");
        var from_1 = require("../observable/from");
        /* tslint:enable:max-line-length */
        /**
         * Projects each source value to an Observable which is merged in the output
         * Observable.
         *
         * <span class="informal">Maps each value to an Observable, then flattens all of
         * these inner Observables using {@link mergeAll}.</span>
         *
         * <img src="./img/mergeMap.png" width="100%">
         *
         * Returns an Observable that emits items based on applying a function that you
         * supply to each item emitted by the source Observable, where that function
         * returns an Observable, and then merging those resulting Observables and
         * emitting the results of this merger.
         *
         * @example <caption>Map and flatten each letter to an Observable ticking every 1 second</caption>
         * var letters = Rx.Observable.of('a', 'b', 'c');
         * var result = letters.mergeMap(x =>
         *   Rx.Observable.interval(1000).map(i => x+i)
         * );
         * result.subscribe(x => console.log(x));
         *
         * // Results in the following:
         * // a0
         * // b0
         * // c0
         * // a1
         * // b1
         * // c1
         * // continues to list a,b,c with respective ascending integers
         *
         * @see {@link concatMap}
         * @see {@link exhaustMap}
         * @see {@link merge}
         * @see {@link mergeAll}
         * @see {@link mergeMapTo}
         * @see {@link mergeScan}
         * @see {@link switchMap}
         *
         * @param {function(value: T, ?index: number): ObservableInput} project A function
         * that, when applied to an item emitted by the source Observable, returns an
         * Observable.
         * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
         * Observables being subscribed to concurrently.
         * @return {Observable} An Observable that emits the result of applying the
         * projection function (and the optional `resultSelector`) to each item emitted
         * by the source Observable and merging the results of the Observables obtained
         * from this transformation.
         * @method mergeMap
         * @owner Observable
         */
        function mergeMap(project, resultSelector, concurrent) {
            if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
            if (typeof resultSelector === 'function') {
                // DEPRECATED PATH
                return function (source) { return source.pipe(mergeMap(function (a, i) { return from_1.from(project(a, i)).pipe(map_1.map(function (b, ii) { return resultSelector(a, b, i, ii); })); }, concurrent)); };
            }
            else if (typeof resultSelector === 'number') {
                concurrent = resultSelector;
            }
            return function (source) { return source.lift(new MergeMapOperator(project, concurrent)); };
        }
        exports.mergeMap = mergeMap;
        var MergeMapOperator = /** @class */ (function () {
            function MergeMapOperator(project, concurrent) {
                if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
                this.project = project;
                this.concurrent = concurrent;
            }
            MergeMapOperator.prototype.call = function (observer, source) {
                return source.subscribe(new MergeMapSubscriber(observer, this.project, this.concurrent));
            };
            return MergeMapOperator;
        }());
        exports.MergeMapOperator = MergeMapOperator;
        /**
         * We need this JSDoc comment for affecting ESDoc.
         * @ignore
         * @extends {Ignored}
         */
        var MergeMapSubscriber = /** @class */ (function (_super) {
            __extends(MergeMapSubscriber, _super);
            function MergeMapSubscriber(destination, project, concurrent) {
                if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
                var _this = _super.call(this, destination) || this;
                _this.project = project;
                _this.concurrent = concurrent;
                _this.hasCompleted = false;
                _this.buffer = [];
                _this.active = 0;
                _this.index = 0;
                return _this;
            }
            MergeMapSubscriber.prototype._next = function (value) {
                if (this.active < this.concurrent) {
                    this._tryNext(value);
                }
                else {
                    this.buffer.push(value);
                }
            };
            MergeMapSubscriber.prototype._tryNext = function (value) {
                var result;
                var index = this.index++;
                try {
                    result = this.project(value, index);
                }
                catch (err) {
                    this.destination.error(err);
                    return;
                }
                this.active++;
                this._innerSub(result, value, index);
            };
            MergeMapSubscriber.prototype._innerSub = function (ish, value, index) {
                this.add(subscribeToResult_1.subscribeToResult(this, ish, value, index));
            };
            MergeMapSubscriber.prototype._complete = function () {
                this.hasCompleted = true;
                if (this.active === 0 && this.buffer.length === 0) {
                    this.destination.complete();
                }
            };
            MergeMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
                this.destination.next(innerValue);
            };
            MergeMapSubscriber.prototype.notifyComplete = function (innerSub) {
                var buffer = this.buffer;
                this.remove(innerSub);
                this.active--;
                if (buffer.length > 0) {
                    this._next(buffer.shift());
                }
                else if (this.active === 0 && this.hasCompleted) {
                    this.destination.complete();
                }
            };
            return MergeMapSubscriber;
        }(OuterSubscriber_1.OuterSubscriber));
        exports.MergeMapSubscriber = MergeMapSubscriber;

    },{"../OuterSubscriber":42,"../observable/from":58,"../util/subscribeToResult":130,"./map":82}],85:[function(require,module,exports){
        "use strict";
        var __extends = (this && this.__extends) || (function () {
                    var extendStatics = Object.setPrototypeOf ||
                            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
                    return function (d, b) {
                        extendStatics(d, b);
                        function __() { this.constructor = d; }
                        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                    };
                })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var Subscriber_1 = require("../Subscriber");
        var Notification_1 = require("../Notification");
        /**
         *
         * Re-emits all notifications from source Observable with specified scheduler.
         *
         * <span class="informal">Ensure a specific scheduler is used, from outside of an Observable.</span>
         *
         * `observeOn` is an operator that accepts a scheduler as a first parameter, which will be used to reschedule
         * notifications emitted by the source Observable. It might be useful, if you do not have control over
         * internal scheduler of a given Observable, but want to control when its values are emitted nevertheless.
         *
         * Returned Observable emits the same notifications (nexted values, complete and error events) as the source Observable,
         * but rescheduled with provided scheduler. Note that this doesn't mean that source Observables internal
         * scheduler will be replaced in any way. Original scheduler still will be used, but when the source Observable emits
         * notification, it will be immediately scheduled again - this time with scheduler passed to `observeOn`.
         * An anti-pattern would be calling `observeOn` on Observable that emits lots of values synchronously, to split
         * that emissions into asynchronous chunks. For this to happen, scheduler would have to be passed into the source
         * Observable directly (usually into the operator that creates it). `observeOn` simply delays notifications a
         * little bit more, to ensure that they are emitted at expected moments.
         *
         * As a matter of fact, `observeOn` accepts second parameter, which specifies in milliseconds with what delay notifications
         * will be emitted. The main difference between {@link delay} operator and `observeOn` is that `observeOn`
         * will delay all notifications - including error notifications - while `delay` will pass through error
         * from source Observable immediately when it is emitted. In general it is highly recommended to use `delay` operator
         * for any kind of delaying of values in the stream, while using `observeOn` to specify which scheduler should be used
         * for notification emissions in general.
         *
         * @example <caption>Ensure values in subscribe are called just before browser repaint.</caption>
         * const intervals = Rx.Observable.interval(10); // Intervals are scheduled
         *                                               // with async scheduler by default...
         *
         * intervals
         * .observeOn(Rx.Scheduler.animationFrame)       // ...but we will observe on animationFrame
         * .subscribe(val => {                           // scheduler to ensure smooth animation.
 *   someDiv.style.height = val + 'px';
 * });
         *
         * @see {@link delay}
         *
         * @param {SchedulerLike} scheduler Scheduler that will be used to reschedule notifications from source Observable.
         * @param {number} [delay] Number of milliseconds that states with what delay every notification should be rescheduled.
         * @return {Observable<T>} Observable that emits the same notifications as the source Observable,
         * but with provided scheduler.
         *
         * @method observeOn
         * @owner Observable
         */
        function observeOn(scheduler, delay) {
            if (delay === void 0) { delay = 0; }
            return function observeOnOperatorFunction(source) {
                return source.lift(new ObserveOnOperator(scheduler, delay));
            };
        }
        exports.observeOn = observeOn;
        var ObserveOnOperator = /** @class */ (function () {
            function ObserveOnOperator(scheduler, delay) {
                if (delay === void 0) { delay = 0; }
                this.scheduler = scheduler;
                this.delay = delay;
            }
            ObserveOnOperator.prototype.call = function (subscriber, source) {
                return source.subscribe(new ObserveOnSubscriber(subscriber, this.scheduler, this.delay));
            };
            return ObserveOnOperator;
        }());
        exports.ObserveOnOperator = ObserveOnOperator;
        /**
         * We need this JSDoc comment for affecting ESDoc.
         * @ignore
         * @extends {Ignored}
         */
        var ObserveOnSubscriber = /** @class */ (function (_super) {
            __extends(ObserveOnSubscriber, _super);
            function ObserveOnSubscriber(destination, scheduler, delay) {
                if (delay === void 0) { delay = 0; }
                var _this = _super.call(this, destination) || this;
                _this.scheduler = scheduler;
                _this.delay = delay;
                return _this;
            }
            /** @nocollapse */
            ObserveOnSubscriber.dispatch = function (arg) {
                var notification = arg.notification, destination = arg.destination;
                notification.observe(destination);
                this.unsubscribe();
            };
            ObserveOnSubscriber.prototype.scheduleMessage = function (notification) {
                this.add(this.scheduler.schedule(ObserveOnSubscriber.dispatch, this.delay, new ObserveOnMessage(notification, this.destination)));
            };
            ObserveOnSubscriber.prototype._next = function (value) {
                this.scheduleMessage(Notification_1.Notification.createNext(value));
            };
            ObserveOnSubscriber.prototype._error = function (err) {
                this.scheduleMessage(Notification_1.Notification.createError(err));
            };
            ObserveOnSubscriber.prototype._complete = function () {
                this.scheduleMessage(Notification_1.Notification.createComplete());
            };
            return ObserveOnSubscriber;
        }(Subscriber_1.Subscriber));
        exports.ObserveOnSubscriber = ObserveOnSubscriber;
        var ObserveOnMessage = /** @class */ (function () {
            function ObserveOnMessage(notification, destination) {
                this.notification = notification;
                this.destination = destination;
            }
            return ObserveOnMessage;
        }());
        exports.ObserveOnMessage = ObserveOnMessage;

    },{"../Notification":39,"../Subscriber":47}],86:[function(require,module,exports){
        "use strict";
        var __extends = (this && this.__extends) || (function () {
                    var extendStatics = Object.setPrototypeOf ||
                            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
                    return function (d, b) {
                        extendStatics(d, b);
                        function __() { this.constructor = d; }
                        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                    };
                })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var Subscriber_1 = require("../Subscriber");
        function refCount() {
            return function refCountOperatorFunction(source) {
                return source.lift(new RefCountOperator(source));
            };
        }
        exports.refCount = refCount;
        var RefCountOperator = /** @class */ (function () {
            function RefCountOperator(connectable) {
                this.connectable = connectable;
            }
            RefCountOperator.prototype.call = function (subscriber, source) {
                var connectable = this.connectable;
                connectable._refCount++;
                var refCounter = new RefCountSubscriber(subscriber, connectable);
                var subscription = source.subscribe(refCounter);
                if (!refCounter.closed) {
                    refCounter.connection = connectable.connect();
                }
                return subscription;
            };
            return RefCountOperator;
        }());
        var RefCountSubscriber = /** @class */ (function (_super) {
            __extends(RefCountSubscriber, _super);
            function RefCountSubscriber(destination, connectable) {
                var _this = _super.call(this, destination) || this;
                _this.connectable = connectable;
                return _this;
            }
            RefCountSubscriber.prototype._unsubscribe = function () {
                var connectable = this.connectable;
                if (!connectable) {
                    this.connection = null;
                    return;
                }
                this.connectable = null;
                var refCount = connectable._refCount;
                if (refCount <= 0) {
                    this.connection = null;
                    return;
                }
                connectable._refCount = refCount - 1;
                if (refCount > 1) {
                    this.connection = null;
                    return;
                }
                ///
                // Compare the local RefCountSubscriber's connection Subscription to the
                // connection Subscription on the shared ConnectableObservable. In cases
                // where the ConnectableObservable source synchronously emits values, and
                // the RefCountSubscriber's downstream Observers synchronously unsubscribe,
                // execution continues to here before the RefCountOperator has a chance to
                // supply the RefCountSubscriber with the shared connection Subscription.
                // For example:
                // ```
                // Observable.range(0, 10)
                //   .publish()
                //   .refCount()
                //   .take(5)
                //   .subscribe();
                // ```
                // In order to account for this case, RefCountSubscriber should only dispose
                // the ConnectableObservable's shared connection Subscription if the
                // connection Subscription exists, *and* either:
                //   a. RefCountSubscriber doesn't have a reference to the shared connection
                //      Subscription yet, or,
                //   b. RefCountSubscriber's connection Subscription reference is identical
                //      to the shared connection Subscription
                ///
                var connection = this.connection;
                var sharedConnection = connectable._connection;
                this.connection = null;
                if (sharedConnection && (!connection || sharedConnection === connection)) {
                    sharedConnection.unsubscribe();
                }
            };
            return RefCountSubscriber;
        }(Subscriber_1.Subscriber));

    },{"../Subscriber":47}],87:[function(require,module,exports){
        "use strict";
        var __extends = (this && this.__extends) || (function () {
                    var extendStatics = Object.setPrototypeOf ||
                            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
                    return function (d, b) {
                        extendStatics(d, b);
                        function __() { this.constructor = d; }
                        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                    };
                })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var Subscription_1 = require("../Subscription");
        /**
         * A unit of work to be executed in a {@link Scheduler}. An action is typically
         * created from within a Scheduler and an RxJS user does not need to concern
         * themselves about creating and manipulating an Action.
         *
         * ```ts
         * class Action<T> extends Subscription {
 *   new (scheduler: Scheduler, work: (state?: T) => void);
 *   schedule(state?: T, delay: number = 0): Subscription;
 * }
         * ```
         *
         * @class Action<T>
         */
        var Action = /** @class */ (function (_super) {
            __extends(Action, _super);
            function Action(scheduler, work) {
                return _super.call(this) || this;
            }
            /**
             * Schedules this action on its parent Scheduler for execution. May be passed
             * some context object, `state`. May happen at some point in the future,
             * according to the `delay` parameter, if specified.
             * @param {T} [state] Some contextual data that the `work` function uses when
             * called by the Scheduler.
             * @param {number} [delay] Time to wait before executing the work, where the
             * time unit is implicit and defined by the Scheduler.
             * @return {void}
             */
            Action.prototype.schedule = function (state, delay) {
                if (delay === void 0) { delay = 0; }
                return this;
            };
            return Action;
        }(Subscription_1.Subscription));
        exports.Action = Action;

    },{"../Subscription":48}],88:[function(require,module,exports){
        "use strict";
        var __extends = (this && this.__extends) || (function () {
                    var extendStatics = Object.setPrototypeOf ||
                            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
                    return function (d, b) {
                        extendStatics(d, b);
                        function __() { this.constructor = d; }
                        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                    };
                })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var AsyncAction_1 = require("./AsyncAction");
        /**
         * We need this JSDoc comment for affecting ESDoc.
         * @ignore
         * @extends {Ignored}
         */
        var AnimationFrameAction = /** @class */ (function (_super) {
            __extends(AnimationFrameAction, _super);
            function AnimationFrameAction(scheduler, work) {
                var _this = _super.call(this, scheduler, work) || this;
                _this.scheduler = scheduler;
                _this.work = work;
                return _this;
            }
            AnimationFrameAction.prototype.requestAsyncId = function (scheduler, id, delay) {
                if (delay === void 0) { delay = 0; }
                // If delay is greater than 0, request as an async action.
                if (delay !== null && delay > 0) {
                    return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
                }
                // Push the action to the end of the scheduler queue.
                scheduler.actions.push(this);
                // If an animation frame has already been requested, don't request another
                // one. If an animation frame hasn't been requested yet, request one. Return
                // the current animation frame request id.
                return scheduler.scheduled || (scheduler.scheduled = requestAnimationFrame(function () { return scheduler.flush(null); }));
            };
            AnimationFrameAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
                if (delay === void 0) { delay = 0; }
                // If delay exists and is greater than 0, or if the delay is null (the
                // action wasn't rescheduled) but was originally scheduled as an async
                // action, then recycle as an async action.
                if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {
                    return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
                }
                // If the scheduler queue is empty, cancel the requested animation frame and
                // set the scheduled flag to undefined so the next AnimationFrameAction will
                // request its own.
                if (scheduler.actions.length === 0) {
                    cancelAnimationFrame(id);
                    scheduler.scheduled = undefined;
                }
                // Return undefined so the action knows to request a new async id if it's rescheduled.
                return undefined;
            };
            return AnimationFrameAction;
        }(AsyncAction_1.AsyncAction));
        exports.AnimationFrameAction = AnimationFrameAction;

    },{"./AsyncAction":92}],89:[function(require,module,exports){
        "use strict";
        var __extends = (this && this.__extends) || (function () {
                    var extendStatics = Object.setPrototypeOf ||
                            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
                    return function (d, b) {
                        extendStatics(d, b);
                        function __() { this.constructor = d; }
                        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                    };
                })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var AsyncScheduler_1 = require("./AsyncScheduler");
        var AnimationFrameScheduler = /** @class */ (function (_super) {
            __extends(AnimationFrameScheduler, _super);
            function AnimationFrameScheduler() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            AnimationFrameScheduler.prototype.flush = function (action) {
                this.active = true;
                this.scheduled = undefined;
                var actions = this.actions;
                var error;
                var index = -1;
                var count = actions.length;
                action = action || actions.shift();
                do {
                    if (error = action.execute(action.state, action.delay)) {
                        break;
                    }
                } while (++index < count && (action = actions.shift()));
                this.active = false;
                if (error) {
                    while (++index < count && (action = actions.shift())) {
                        action.unsubscribe();
                    }
                    throw error;
                }
            };
            return AnimationFrameScheduler;
        }(AsyncScheduler_1.AsyncScheduler));
        exports.AnimationFrameScheduler = AnimationFrameScheduler;

    },{"./AsyncScheduler":93}],90:[function(require,module,exports){
        "use strict";
        var __extends = (this && this.__extends) || (function () {
                    var extendStatics = Object.setPrototypeOf ||
                            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
                    return function (d, b) {
                        extendStatics(d, b);
                        function __() { this.constructor = d; }
                        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                    };
                })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var Immediate_1 = require("../util/Immediate");
        var AsyncAction_1 = require("./AsyncAction");
        /**
         * We need this JSDoc comment for affecting ESDoc.
         * @ignore
         * @extends {Ignored}
         */
        var AsapAction = /** @class */ (function (_super) {
            __extends(AsapAction, _super);
            function AsapAction(scheduler, work) {
                var _this = _super.call(this, scheduler, work) || this;
                _this.scheduler = scheduler;
                _this.work = work;
                return _this;
            }
            AsapAction.prototype.requestAsyncId = function (scheduler, id, delay) {
                if (delay === void 0) { delay = 0; }
                // If delay is greater than 0, request as an async action.
                if (delay !== null && delay > 0) {
                    return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
                }
                // Push the action to the end of the scheduler queue.
                scheduler.actions.push(this);
                // If a microtask has already been scheduled, don't schedule another
                // one. If a microtask hasn't been scheduled yet, schedule one now. Return
                // the current scheduled microtask id.
                return scheduler.scheduled || (scheduler.scheduled = Immediate_1.Immediate.setImmediate(scheduler.flush.bind(scheduler, null)));
            };
            AsapAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
                if (delay === void 0) { delay = 0; }
                // If delay exists and is greater than 0, or if the delay is null (the
                // action wasn't rescheduled) but was originally scheduled as an async
                // action, then recycle as an async action.
                if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {
                    return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
                }
                // If the scheduler queue is empty, cancel the requested microtask and
                // set the scheduled flag to undefined so the next AsapAction will schedule
                // its own.
                if (scheduler.actions.length === 0) {
                    Immediate_1.Immediate.clearImmediate(id);
                    scheduler.scheduled = undefined;
                }
                // Return undefined so the action knows to request a new async id if it's rescheduled.
                return undefined;
            };
            return AsapAction;
        }(AsyncAction_1.AsyncAction));
        exports.AsapAction = AsapAction;

    },{"../util/Immediate":106,"./AsyncAction":92}],91:[function(require,module,exports){
        "use strict";
        var __extends = (this && this.__extends) || (function () {
                    var extendStatics = Object.setPrototypeOf ||
                            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
                    return function (d, b) {
                        extendStatics(d, b);
                        function __() { this.constructor = d; }
                        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                    };
                })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var AsyncScheduler_1 = require("./AsyncScheduler");
        var AsapScheduler = /** @class */ (function (_super) {
            __extends(AsapScheduler, _super);
            function AsapScheduler() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            AsapScheduler.prototype.flush = function (action) {
                this.active = true;
                this.scheduled = undefined;
                var actions = this.actions;
                var error;
                var index = -1;
                var count = actions.length;
                action = action || actions.shift();
                do {
                    if (error = action.execute(action.state, action.delay)) {
                        break;
                    }
                } while (++index < count && (action = actions.shift()));
                this.active = false;
                if (error) {
                    while (++index < count && (action = actions.shift())) {
                        action.unsubscribe();
                    }
                    throw error;
                }
            };
            return AsapScheduler;
        }(AsyncScheduler_1.AsyncScheduler));
        exports.AsapScheduler = AsapScheduler;

    },{"./AsyncScheduler":93}],92:[function(require,module,exports){
        "use strict";
        var __extends = (this && this.__extends) || (function () {
                    var extendStatics = Object.setPrototypeOf ||
                            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
                    return function (d, b) {
                        extendStatics(d, b);
                        function __() { this.constructor = d; }
                        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                    };
                })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var Action_1 = require("./Action");
        /**
         * We need this JSDoc comment for affecting ESDoc.
         * @ignore
         * @extends {Ignored}
         */
        var AsyncAction = /** @class */ (function (_super) {
            __extends(AsyncAction, _super);
            function AsyncAction(scheduler, work) {
                var _this = _super.call(this, scheduler, work) || this;
                _this.scheduler = scheduler;
                _this.work = work;
                _this.pending = false;
                return _this;
            }
            AsyncAction.prototype.schedule = function (state, delay) {
                if (delay === void 0) { delay = 0; }
                if (this.closed) {
                    return this;
                }
                // Always replace the current state with the new state.
                this.state = state;
                var id = this.id;
                var scheduler = this.scheduler;
                //
                // Important implementation note:
                //
                // Actions only execute once by default, unless rescheduled from within the
                // scheduled callback. This allows us to implement single and repeat
                // actions via the same code path, without adding API surface area, as well
                // as mimic traditional recursion but across asynchronous boundaries.
                //
                // However, JS runtimes and timers distinguish between intervals achieved by
                // serial `setTimeout` calls vs. a single `setInterval` call. An interval of
                // serial `setTimeout` calls can be individually delayed, which delays
                // scheduling the next `setTimeout`, and so on. `setInterval` attempts to
                // guarantee the interval callback will be invoked more precisely to the
                // interval period, regardless of load.
                //
                // Therefore, we use `setInterval` to schedule single and repeat actions.
                // If the action reschedules itself with the same delay, the interval is not
                // canceled. If the action doesn't reschedule, or reschedules with a
                // different delay, the interval will be canceled after scheduled callback
                // execution.
                //
                if (id != null) {
                    this.id = this.recycleAsyncId(scheduler, id, delay);
                }
                // Set the pending flag indicating that this action has been scheduled, or
                // has recursively rescheduled itself.
                this.pending = true;
                this.delay = delay;
                // If this action has already an async Id, don't request a new one.
                this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);
                return this;
            };
            AsyncAction.prototype.requestAsyncId = function (scheduler, id, delay) {
                if (delay === void 0) { delay = 0; }
                return setInterval(scheduler.flush.bind(scheduler, this), delay);
            };
            AsyncAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
                if (delay === void 0) { delay = 0; }
                // If this action is rescheduled with the same delay time, don't clear the interval id.
                if (delay !== null && this.delay === delay && this.pending === false) {
                    return id;
                }
                // Otherwise, if the action's delay time is different from the current delay,
                // or the action has been rescheduled before it's executed, clear the interval id
                return clearInterval(id) && undefined || undefined;
            };
            /**
             * Immediately executes this action and the `work` it contains.
             * @return {any}
             */
            AsyncAction.prototype.execute = function (state, delay) {
                if (this.closed) {
                    return new Error('executing a cancelled action');
                }
                this.pending = false;
                var error = this._execute(state, delay);
                if (error) {
                    return error;
                }
                else if (this.pending === false && this.id != null) {
                    // Dequeue if the action didn't reschedule itself. Don't call
                    // unsubscribe(), because the action could reschedule later.
                    // For example:
                    // ```
                    // scheduler.schedule(function doWork(counter) {
                    //   /* ... I'm a busy worker bee ... */
                    //   var originalAction = this;
                    //   /* wait 100ms before rescheduling the action */
                    //   setTimeout(function () {
                    //     originalAction.schedule(counter + 1);
                    //   }, 100);
                    // }, 1000);
                    // ```
                    this.id = this.recycleAsyncId(this.scheduler, this.id, null);
                }
            };
            AsyncAction.prototype._execute = function (state, delay) {
                var errored = false;
                var errorValue = undefined;
                try {
                    this.work(state);
                }
                catch (e) {
                    errored = true;
                    errorValue = !!e && e || new Error(e);
                }
                if (errored) {
                    this.unsubscribe();
                    return errorValue;
                }
            };
            /** @deprecated This is an internal implementation detail, do not use. */
            AsyncAction.prototype._unsubscribe = function () {
                var id = this.id;
                var scheduler = this.scheduler;
                var actions = scheduler.actions;
                var index = actions.indexOf(this);
                this.work = null;
                this.state = null;
                this.pending = false;
                this.scheduler = null;
                if (index !== -1) {
                    actions.splice(index, 1);
                }
                if (id != null) {
                    this.id = this.recycleAsyncId(scheduler, id, null);
                }
                this.delay = null;
            };
            return AsyncAction;
        }(Action_1.Action));
        exports.AsyncAction = AsyncAction;

    },{"./Action":87}],93:[function(require,module,exports){
        "use strict";
        var __extends = (this && this.__extends) || (function () {
                    var extendStatics = Object.setPrototypeOf ||
                            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
                    return function (d, b) {
                        extendStatics(d, b);
                        function __() { this.constructor = d; }
                        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                    };
                })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var Scheduler_1 = require("../Scheduler");
        var AsyncScheduler = /** @class */ (function (_super) {
            __extends(AsyncScheduler, _super);
            function AsyncScheduler(SchedulerAction, now) {
                if (now === void 0) { now = Scheduler_1.Scheduler.now; }
                var _this = _super.call(this, SchedulerAction, function () {
                            if (AsyncScheduler.delegate && AsyncScheduler.delegate !== _this) {
                                return AsyncScheduler.delegate.now();
                            }
                            else {
                                return now();
                            }
                        }) || this;
                _this.actions = [];
                /**
                 * A flag to indicate whether the Scheduler is currently executing a batch of
                 * queued actions.
                 * @type {boolean}
                 * @deprecated internal use only
                 */
                _this.active = false;
                /**
                 * An internal ID used to track the latest asynchronous task such as those
                 * coming from `setTimeout`, `setInterval`, `requestAnimationFrame`, and
                 * others.
                 * @type {any}
                 * @deprecated internal use only
                 */
                _this.scheduled = undefined;
                return _this;
            }
            AsyncScheduler.prototype.schedule = function (work, delay, state) {
                if (delay === void 0) { delay = 0; }
                if (AsyncScheduler.delegate && AsyncScheduler.delegate !== this) {
                    return AsyncScheduler.delegate.schedule(work, delay, state);
                }
                else {
                    return _super.prototype.schedule.call(this, work, delay, state);
                }
            };
            AsyncScheduler.prototype.flush = function (action) {
                var actions = this.actions;
                if (this.active) {
                    actions.push(action);
                    return;
                }
                var error;
                this.active = true;
                do {
                    if (error = action.execute(action.state, action.delay)) {
                        break;
                    }
                } while (action = actions.shift()); // exhaust the scheduler queue
                this.active = false;
                if (error) {
                    while (action = actions.shift()) {
                        action.unsubscribe();
                    }
                    throw error;
                }
            };
            return AsyncScheduler;
        }(Scheduler_1.Scheduler));
        exports.AsyncScheduler = AsyncScheduler;

    },{"../Scheduler":44}],94:[function(require,module,exports){
        "use strict";
        var __extends = (this && this.__extends) || (function () {
                    var extendStatics = Object.setPrototypeOf ||
                            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
                    return function (d, b) {
                        extendStatics(d, b);
                        function __() { this.constructor = d; }
                        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                    };
                })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var AsyncAction_1 = require("./AsyncAction");
        /**
         * We need this JSDoc comment for affecting ESDoc.
         * @ignore
         * @extends {Ignored}
         */
        var QueueAction = /** @class */ (function (_super) {
            __extends(QueueAction, _super);
            function QueueAction(scheduler, work) {
                var _this = _super.call(this, scheduler, work) || this;
                _this.scheduler = scheduler;
                _this.work = work;
                return _this;
            }
            QueueAction.prototype.schedule = function (state, delay) {
                if (delay === void 0) { delay = 0; }
                if (delay > 0) {
                    return _super.prototype.schedule.call(this, state, delay);
                }
                this.delay = delay;
                this.state = state;
                this.scheduler.flush(this);
                return this;
            };
            QueueAction.prototype.execute = function (state, delay) {
                return (delay > 0 || this.closed) ?
                        _super.prototype.execute.call(this, state, delay) :
                        this._execute(state, delay);
            };
            QueueAction.prototype.requestAsyncId = function (scheduler, id, delay) {
                if (delay === void 0) { delay = 0; }
                // If delay exists and is greater than 0, or if the delay is null (the
                // action wasn't rescheduled) but was originally scheduled as an async
                // action, then recycle as an async action.
                if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {
                    return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
                }
                // Otherwise flush the scheduler starting with this action.
                return scheduler.flush(this);
            };
            return QueueAction;
        }(AsyncAction_1.AsyncAction));
        exports.QueueAction = QueueAction;

    },{"./AsyncAction":92}],95:[function(require,module,exports){
        "use strict";
        var __extends = (this && this.__extends) || (function () {
                    var extendStatics = Object.setPrototypeOf ||
                            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
                    return function (d, b) {
                        extendStatics(d, b);
                        function __() { this.constructor = d; }
                        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                    };
                })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var AsyncScheduler_1 = require("./AsyncScheduler");
        var QueueScheduler = /** @class */ (function (_super) {
            __extends(QueueScheduler, _super);
            function QueueScheduler() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            return QueueScheduler;
        }(AsyncScheduler_1.AsyncScheduler));
        exports.QueueScheduler = QueueScheduler;

    },{"./AsyncScheduler":93}],96:[function(require,module,exports){
        "use strict";
        var __extends = (this && this.__extends) || (function () {
                    var extendStatics = Object.setPrototypeOf ||
                            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
                    return function (d, b) {
                        extendStatics(d, b);
                        function __() { this.constructor = d; }
                        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                    };
                })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var AsyncAction_1 = require("./AsyncAction");
        var AsyncScheduler_1 = require("./AsyncScheduler");
        var VirtualTimeScheduler = /** @class */ (function (_super) {
            __extends(VirtualTimeScheduler, _super);
            function VirtualTimeScheduler(SchedulerAction, maxFrames) {
                if (SchedulerAction === void 0) { SchedulerAction = VirtualAction; }
                if (maxFrames === void 0) { maxFrames = Number.POSITIVE_INFINITY; }
                var _this = _super.call(this, SchedulerAction, function () { return _this.frame; }) || this;
                _this.maxFrames = maxFrames;
                _this.frame = 0;
                _this.index = -1;
                return _this;
            }
            /**
             * Prompt the Scheduler to execute all of its queued actions, therefore
             * clearing its queue.
             * @return {void}
             */
            VirtualTimeScheduler.prototype.flush = function () {
                var _a = this, actions = _a.actions, maxFrames = _a.maxFrames;
                var error, action;
                while ((action = actions.shift()) && (this.frame = action.delay) <= maxFrames) {
                    if (error = action.execute(action.state, action.delay)) {
                        break;
                    }
                }
                if (error) {
                    while (action = actions.shift()) {
                        action.unsubscribe();
                    }
                    throw error;
                }
            };
            VirtualTimeScheduler.frameTimeFactor = 10;
            return VirtualTimeScheduler;
        }(AsyncScheduler_1.AsyncScheduler));
        exports.VirtualTimeScheduler = VirtualTimeScheduler;
        /**
         * We need this JSDoc comment for affecting ESDoc.
         * @ignore
         * @extends {Ignored}
         */
        var VirtualAction = /** @class */ (function (_super) {
            __extends(VirtualAction, _super);
            function VirtualAction(scheduler, work, index) {
                if (index === void 0) { index = scheduler.index += 1; }
                var _this = _super.call(this, scheduler, work) || this;
                _this.scheduler = scheduler;
                _this.work = work;
                _this.index = index;
                _this.active = true;
                _this.index = scheduler.index = index;
                return _this;
            }
            VirtualAction.prototype.schedule = function (state, delay) {
                if (delay === void 0) { delay = 0; }
                if (!this.id) {
                    return _super.prototype.schedule.call(this, state, delay);
                }
                this.active = false;
                // If an action is rescheduled, we save allocations by mutating its state,
                // pushing it to the end of the scheduler queue, and recycling the action.
                // But since the VirtualTimeScheduler is used for testing, VirtualActions
                // must be immutable so they can be inspected later.
                var action = new VirtualAction(this.scheduler, this.work);
                this.add(action);
                return action.schedule(state, delay);
            };
            VirtualAction.prototype.requestAsyncId = function (scheduler, id, delay) {
                if (delay === void 0) { delay = 0; }
                this.delay = scheduler.frame + delay;
                var actions = scheduler.actions;
                actions.push(this);
                actions.sort(VirtualAction.sortActions);
                return true;
            };
            VirtualAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
                if (delay === void 0) { delay = 0; }
                return undefined;
            };
            VirtualAction.prototype._execute = function (state, delay) {
                if (this.active === true) {
                    return _super.prototype._execute.call(this, state, delay);
                }
            };
            VirtualAction.sortActions = function (a, b) {
                if (a.delay === b.delay) {
                    if (a.index === b.index) {
                        return 0;
                    }
                    else if (a.index > b.index) {
                        return 1;
                    }
                    else {
                        return -1;
                    }
                }
                else if (a.delay > b.delay) {
                    return 1;
                }
                else {
                    return -1;
                }
            };
            return VirtualAction;
        }(AsyncAction_1.AsyncAction));
        exports.VirtualAction = VirtualAction;

    },{"./AsyncAction":92,"./AsyncScheduler":93}],97:[function(require,module,exports){
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var AnimationFrameAction_1 = require("./AnimationFrameAction");
        var AnimationFrameScheduler_1 = require("./AnimationFrameScheduler");
        /**
         *
         * Animation Frame Scheduler
         *
         * <span class="informal">Perform task when `window.requestAnimationFrame` would fire</span>
         *
         * When `animationFrame` scheduler is used with delay, it will fall back to {@link async} scheduler
         * behaviour.
         *
         * Without delay, `animationFrame` scheduler can be used to create smooth browser animations.
         * It makes sure scheduled task will happen just before next browser content repaint,
         * thus performing animations as efficiently as possible.
         *
         * @example <caption>Schedule div height animation</caption>
         * const div = document.querySelector('.some-div');
         *
         * Rx.Scheduler.animationFrame.schedule(function(height) {
 *   div.style.height = height + "px";
 *
 *   this.schedule(height + 1);  // `this` references currently executing Action,
 *                               // which we reschedule with new state
 * }, 0, 0);
         *
         * // You will see .some-div element growing in height
         *
         *
         * @static true
         * @name animationFrame
         * @owner Scheduler
         */
        exports.animationFrame = new AnimationFrameScheduler_1.AnimationFrameScheduler(AnimationFrameAction_1.AnimationFrameAction);

    },{"./AnimationFrameAction":88,"./AnimationFrameScheduler":89}],98:[function(require,module,exports){
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var AsapAction_1 = require("./AsapAction");
        var AsapScheduler_1 = require("./AsapScheduler");
        /**
         *
         * Asap Scheduler
         *
         * <span class="informal">Perform task as fast as it can be performed asynchronously</span>
         *
         * `asap` scheduler behaves the same as {@link async} scheduler when you use it to delay task
         * in time. If however you set delay to `0`, `asap` will wait for current synchronously executing
         * code to end and then it will try to execute given task as fast as possible.
         *
         * `asap` scheduler will do its best to minimize time between end of currently executing code
         * and start of scheduled task. This makes it best candidate for performing so called "deferring".
         * Traditionally this was achieved by calling `setTimeout(deferredTask, 0)`, but that technique involves
         * some (although minimal) unwanted delay.
         *
         * Note that using `asap` scheduler does not necessarily mean that your task will be first to process
         * after currently executing code. In particular, if some task was also scheduled with `asap` before,
         * that task will execute first. That being said, if you need to schedule task asynchronously, but
         * as soon as possible, `asap` scheduler is your best bet.
         *
         * @example <caption>Compare async and asap scheduler</caption>
         *
         * Rx.Scheduler.async.schedule(() => console.log('async')); // scheduling 'async' first...
         * Rx.Scheduler.asap.schedule(() => console.log('asap'));
         *
         * // Logs:
         * // "asap"
         * // "async"
         * // ... but 'asap' goes first!
         *
         * @static true
         * @name asap
         * @owner Scheduler
         */
        exports.asap = new AsapScheduler_1.AsapScheduler(AsapAction_1.AsapAction);

    },{"./AsapAction":90,"./AsapScheduler":91}],99:[function(require,module,exports){
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var AsyncAction_1 = require("./AsyncAction");
        var AsyncScheduler_1 = require("./AsyncScheduler");
        /**
         *
         * Async Scheduler
         *
         * <span class="informal">Schedule task as if you used setTimeout(task, duration)</span>
         *
         * `async` scheduler schedules tasks asynchronously, by putting them on the JavaScript
         * event loop queue. It is best used to delay tasks in time or to schedule tasks repeating
         * in intervals.
         *
         * If you just want to "defer" task, that is to perform it right after currently
         * executing synchronous code ends (commonly achieved by `setTimeout(deferredTask, 0)`),
         * better choice will be the {@link asap} scheduler.
         *
         * @example <caption>Use async scheduler to delay task</caption>
         * const task = () => console.log('it works!');
         *
         * Rx.Scheduler.async.schedule(task, 2000);
         *
         * // After 2 seconds logs:
         * // "it works!"
         *
         *
         * @example <caption>Use async scheduler to repeat task in intervals</caption>
         * function task(state) {
 *   console.log(state);
 *   this.schedule(state + 1, 1000); // `this` references currently executing Action,
 *                                   // which we reschedule with new state and delay
 * }
         *
         * Rx.Scheduler.async.schedule(task, 3000, 0);
         *
         * // Logs:
         * // 0 after 3s
         * // 1 after 4s
         * // 2 after 5s
         * // 3 after 6s
         *
         * @static true
         * @name async
         * @owner Scheduler
         */
        exports.async = new AsyncScheduler_1.AsyncScheduler(AsyncAction_1.AsyncAction);

    },{"./AsyncAction":92,"./AsyncScheduler":93}],100:[function(require,module,exports){
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var QueueAction_1 = require("./QueueAction");
        var QueueScheduler_1 = require("./QueueScheduler");
        /**
         *
         * Queue Scheduler
         *
         * <span class="informal">Put every next task on a queue, instead of executing it immediately</span>
         *
         * `queue` scheduler, when used with delay, behaves the same as {@link async} scheduler.
         *
         * When used without delay, it schedules given task synchronously - executes it right when
         * it is scheduled. However when called recursively, that is when inside the scheduled task,
         * another task is scheduled with queue scheduler, instead of executing immediately as well,
         * that task will be put on a queue and wait for current one to finish.
         *
         * This means that when you execute task with `queue` scheduler, you are sure it will end
         * before any other task scheduled with that scheduler will start.
         *
         * @examples <caption>Schedule recursively first, then do something</caption>
         *
         * Rx.Scheduler.queue.schedule(() => {
 *   Rx.Scheduler.queue.schedule(() => console.log('second')); // will not happen now, but will be put on a queue
 *
 *   console.log('first');
 * });
         *
         * // Logs:
         * // "first"
         * // "second"
         *
         *
         * @example <caption>Reschedule itself recursively</caption>
         *
         * Rx.Scheduler.queue.schedule(function(state) {
 *   if (state !== 0) {
 *     console.log('before', state);
 *     this.schedule(state - 1); // `this` references currently executing Action,
 *                               // which we reschedule with new state
 *     console.log('after', state);
 *   }
 * }, 0, 3);
         *
         * // In scheduler that runs recursively, you would expect:
         * // "before", 3
         * // "before", 2
         * // "before", 1
         * // "after", 1
         * // "after", 2
         * // "after", 3
         *
         * // But with queue it logs:
         * // "before", 3
         * // "after", 3
         * // "before", 2
         * // "after", 2
         * // "before", 1
         * // "after", 1
         *
         *
         * @static true
         * @name queue
         * @owner Scheduler
         */
        exports.queue = new QueueScheduler_1.QueueScheduler(QueueAction_1.QueueAction);

    },{"./QueueAction":94,"./QueueScheduler":95}],101:[function(require,module,exports){
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        function getSymbolIterator() {
            if (typeof Symbol !== 'function' || !Symbol.iterator) {
                return '@@iterator';
            }
            return Symbol.iterator;
        }
        exports.getSymbolIterator = getSymbolIterator;
        exports.iterator = getSymbolIterator();
        /**
         * @deprecated use {@link iterator} instead
         */
        exports.$$iterator = exports.iterator;

    },{}],102:[function(require,module,exports){
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        /** Symbol.observable or a string "@@observable". Used for interop */
        exports.observable = typeof Symbol === 'function' && Symbol.observable || '@@observable';

    },{}],103:[function(require,module,exports){
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.rxSubscriber = (typeof Symbol === 'function' && typeof Symbol.for === 'function')
                ? Symbol.for('rxSubscriber')
                : '@@rxSubscriber';
        /**
         * @deprecated use rxSubscriber instead
         */
        exports.$$rxSubscriber = exports.rxSubscriber;

    },{}],104:[function(require,module,exports){
        "use strict";
        var __extends = (this && this.__extends) || (function () {
                    var extendStatics = Object.setPrototypeOf ||
                            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
                    return function (d, b) {
                        extendStatics(d, b);
                        function __() { this.constructor = d; }
                        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                    };
                })();
        Object.defineProperty(exports, "__esModule", { value: true });
        /**
         * An error thrown when an element was queried at a certain index of an
         * Observable, but no such index or position exists in that sequence.
         *
         * @see {@link elementAt}
         * @see {@link take}
         * @see {@link takeLast}
         *
         * @class ArgumentOutOfRangeError
         */
        var ArgumentOutOfRangeError = /** @class */ (function (_super) {
            __extends(ArgumentOutOfRangeError, _super);
            function ArgumentOutOfRangeError() {
                var _this = _super.call(this, 'argument out of range') || this;
                _this.name = 'ArgumentOutOfRangeError';
                Object.setPrototypeOf(_this, ArgumentOutOfRangeError.prototype);
                return _this;
            }
            return ArgumentOutOfRangeError;
        }(Error));
        exports.ArgumentOutOfRangeError = ArgumentOutOfRangeError;

    },{}],105:[function(require,module,exports){
        "use strict";
        var __extends = (this && this.__extends) || (function () {
                    var extendStatics = Object.setPrototypeOf ||
                            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
                    return function (d, b) {
                        extendStatics(d, b);
                        function __() { this.constructor = d; }
                        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                    };
                })();
        Object.defineProperty(exports, "__esModule", { value: true });
        /**
         * An error thrown when an Observable or a sequence was queried but has no
         * elements.
         *
         * @see {@link first}
         * @see {@link last}
         * @see {@link single}
         *
         * @class EmptyError
         */
        var EmptyError = /** @class */ (function (_super) {
            __extends(EmptyError, _super);
            function EmptyError() {
                var _this = _super.call(this, 'no elements in sequence') || this;
                _this.name = 'EmptyError';
                Object.setPrototypeOf(_this, EmptyError.prototype);
                return _this;
            }
            return EmptyError;
        }(Error));
        exports.EmptyError = EmptyError;

    },{}],106:[function(require,module,exports){
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var nextHandle = 1;
        var tasksByHandle = {};
        function runIfPresent(handle) {
            var cb = tasksByHandle[handle];
            if (cb) {
                cb();
            }
        }
        exports.Immediate = {
            setImmediate: function (cb) {
                var handle = nextHandle++;
                tasksByHandle[handle] = cb;
                Promise.resolve().then(function () { return runIfPresent(handle); });
                return handle;
            },
            clearImmediate: function (handle) {
                delete tasksByHandle[handle];
            },
        };

    },{}],107:[function(require,module,exports){
        "use strict";
        var __extends = (this && this.__extends) || (function () {
                    var extendStatics = Object.setPrototypeOf ||
                            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
                    return function (d, b) {
                        extendStatics(d, b);
                        function __() { this.constructor = d; }
                        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                    };
                })();
        Object.defineProperty(exports, "__esModule", { value: true });
        /**
         * An error thrown when an action is invalid because the object has been
         * unsubscribed.
         *
         * @see {@link Subject}
         * @see {@link BehaviorSubject}
         *
         * @class ObjectUnsubscribedError
         */
        var ObjectUnsubscribedError = /** @class */ (function (_super) {
            __extends(ObjectUnsubscribedError, _super);
            function ObjectUnsubscribedError() {
                var _this = _super.call(this, 'object unsubscribed') || this;
                _this.name = 'ObjectUnsubscribedError';
                Object.setPrototypeOf(_this, ObjectUnsubscribedError.prototype);
                return _this;
            }
            return ObjectUnsubscribedError;
        }(Error));
        exports.ObjectUnsubscribedError = ObjectUnsubscribedError;

    },{}],108:[function(require,module,exports){
        "use strict";
        var __extends = (this && this.__extends) || (function () {
                    var extendStatics = Object.setPrototypeOf ||
                            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
                    return function (d, b) {
                        extendStatics(d, b);
                        function __() { this.constructor = d; }
                        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                    };
                })();
        Object.defineProperty(exports, "__esModule", { value: true });
        /**
         * An error thrown when duetime elapses.
         *
         * @see {@link timeout}
         *
         * @class TimeoutError
         */
        var TimeoutError = /** @class */ (function (_super) {
            __extends(TimeoutError, _super);
            function TimeoutError() {
                var _this = _super.call(this, 'Timeout has occurred') || this;
                _this.name = 'TimeoutError';
                Object.setPrototypeOf(_this, TimeoutError.prototype);
                return _this;
            }
            return TimeoutError;
        }(Error));
        exports.TimeoutError = TimeoutError;

    },{}],109:[function(require,module,exports){
        "use strict";
        var __extends = (this && this.__extends) || (function () {
                    var extendStatics = Object.setPrototypeOf ||
                            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
                    return function (d, b) {
                        extendStatics(d, b);
                        function __() { this.constructor = d; }
                        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                    };
                })();
        Object.defineProperty(exports, "__esModule", { value: true });
        /**
         * An error thrown when one or more errors have occurred during the
         * `unsubscribe` of a {@link Subscription}.
         */
        var UnsubscriptionError = /** @class */ (function (_super) {
            __extends(UnsubscriptionError, _super);
            function UnsubscriptionError(errors) {
                var _this = _super.call(this, errors ?
                                errors.length + " errors occurred during unsubscription:\n  " + errors.map(function (err, i) { return i + 1 + ") " + err.toString(); }).join('\n  ') : '') || this;
                _this.errors = errors;
                _this.name = 'UnsubscriptionError';
                Object.setPrototypeOf(_this, UnsubscriptionError.prototype);
                return _this;
            }
            return UnsubscriptionError;
        }(Error));
        exports.UnsubscriptionError = UnsubscriptionError;

    },{}],110:[function(require,module,exports){
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
// typeof any so that it we don't have to cast when comparing a result to the error object
        exports.errorObject = { e: {} };

    },{}],111:[function(require,module,exports){
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        /**
         * Throws an error on another job so that it's picked up by the runtime's
         * uncaught error handling mechanism.
         * @param err the error to throw
         */
        function hostReportError(err) {
            setTimeout(function () { throw err; });
        }
        exports.hostReportError = hostReportError;

    },{}],112:[function(require,module,exports){
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        function identity(x) {
            return x;
        }
        exports.identity = identity;

    },{}],113:[function(require,module,exports){
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.isArray = Array.isArray || (function (x) { return x && typeof x.length === 'number'; });

    },{}],114:[function(require,module,exports){
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.isArrayLike = (function (x) { return x && typeof x.length === 'number' && typeof x !== 'function'; });

    },{}],115:[function(require,module,exports){
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        function isFunction(x) {
            return typeof x === 'function';
        }
        exports.isFunction = isFunction;

    },{}],116:[function(require,module,exports){
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var observable_1 = require("../symbol/observable");
        /** Identifies an input as being Observable (but not necessary an Rx Observable) */
        function isInteropObservable(input) {
            return input && typeof input[observable_1.observable] === 'function';
        }
        exports.isInteropObservable = isInteropObservable;

    },{"../symbol/observable":102}],117:[function(require,module,exports){
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var iterator_1 = require("../symbol/iterator");
        /** Identifies an input as being an Iterable */
        function isIterable(input) {
            return input && typeof input[iterator_1.iterator] === 'function';
        }
        exports.isIterable = isIterable;

    },{"../symbol/iterator":101}],118:[function(require,module,exports){
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var isArray_1 = require("./isArray");
        function isNumeric(val) {
            // parseFloat NaNs numeric-cast false positives (null|true|false|"")
            // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
            // subtraction forces infinities to NaN
            // adding 1 corrects loss of precision from parseFloat (#15100)
            return !isArray_1.isArray(val) && (val - parseFloat(val) + 1) >= 0;
        }
        exports.isNumeric = isNumeric;

    },{"./isArray":113}],119:[function(require,module,exports){
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        function isObject(x) {
            return x != null && typeof x === 'object';
        }
        exports.isObject = isObject;

    },{}],120:[function(require,module,exports){
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var Observable_1 = require("../Observable");
        /**
         * Tests to see if the object is an RxJS {@link Observable}
         * @param obj the object to test
         */
        function isObservable(obj) {
            return !!obj && (obj instanceof Observable_1.Observable || (typeof obj.lift === 'function' && typeof obj.subscribe === 'function'));
        }
        exports.isObservable = isObservable;

    },{"../Observable":40}],121:[function(require,module,exports){
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        function isPromise(value) {
            return value && typeof value.subscribe !== 'function' && typeof value.then === 'function';
        }
        exports.isPromise = isPromise;

    },{}],122:[function(require,module,exports){
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        function isScheduler(value) {
            return value && typeof value.schedule === 'function';
        }
        exports.isScheduler = isScheduler;

    },{}],123:[function(require,module,exports){
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        /* tslint:disable:no-empty */
        function noop() { }
        exports.noop = noop;

    },{}],124:[function(require,module,exports){
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var noop_1 = require("./noop");
        /* tslint:enable:max-line-length */
        function pipe() {
            var fns = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                fns[_i] = arguments[_i];
            }
            return pipeFromArray(fns);
        }
        exports.pipe = pipe;
        /* @internal */
        function pipeFromArray(fns) {
            if (!fns) {
                return noop_1.noop;
            }
            if (fns.length === 1) {
                return fns[0];
            }
            return function piped(input) {
                return fns.reduce(function (prev, fn) { return fn(prev); }, input);
            };
        }
        exports.pipeFromArray = pipeFromArray;

    },{"./noop":123}],125:[function(require,module,exports){
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var Observable_1 = require("../Observable");
        var subscribeToArray_1 = require("./subscribeToArray");
        var subscribeToPromise_1 = require("./subscribeToPromise");
        var subscribeToIterable_1 = require("./subscribeToIterable");
        var subscribeToObservable_1 = require("./subscribeToObservable");
        var isArrayLike_1 = require("./isArrayLike");
        var isPromise_1 = require("./isPromise");
        var isObject_1 = require("./isObject");
        var iterator_1 = require("../symbol/iterator");
        var observable_1 = require("../symbol/observable");
        exports.subscribeTo = function (result) {
            if (result instanceof Observable_1.Observable) {
                return function (subscriber) {
                    if (result._isScalar) {
                        subscriber.next(result.value);
                        subscriber.complete();
                        return undefined;
                    }
                    else {
                        return result.subscribe(subscriber);
                    }
                };
            }
            else if (isArrayLike_1.isArrayLike(result)) {
                return subscribeToArray_1.subscribeToArray(result);
            }
            else if (isPromise_1.isPromise(result)) {
                return subscribeToPromise_1.subscribeToPromise(result);
            }
            else if (result && typeof result[iterator_1.iterator] === 'function') {
                return subscribeToIterable_1.subscribeToIterable(result);
            }
            else if (result && typeof result[observable_1.observable] === 'function') {
                return subscribeToObservable_1.subscribeToObservable(result);
            }
            else {
                var value = isObject_1.isObject(result) ? 'an invalid object' : "'" + result + "'";
                var msg = "You provided " + value + " where a stream was expected."
                        + ' You can provide an Observable, Promise, Array, or Iterable.';
                throw new TypeError(msg);
            }
        };

    },{"../Observable":40,"../symbol/iterator":101,"../symbol/observable":102,"./isArrayLike":114,"./isObject":119,"./isPromise":121,"./subscribeToArray":126,"./subscribeToIterable":127,"./subscribeToObservable":128,"./subscribeToPromise":129}],126:[function(require,module,exports){
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        /**
         * Subscribes to an ArrayLike with a subscriber
         * @param array The array or array-like to subscribe to
         */
        exports.subscribeToArray = function (array) { return function (subscriber) {
            for (var i = 0, len = array.length; i < len && !subscriber.closed; i++) {
                subscriber.next(array[i]);
            }
            if (!subscriber.closed) {
                subscriber.complete();
            }
        }; };

    },{}],127:[function(require,module,exports){
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var iterator_1 = require("../symbol/iterator");
        exports.subscribeToIterable = function (iterable) { return function (subscriber) {
            var iterator = iterable[iterator_1.iterator]();
            do {
                var item = iterator.next();
                if (item.done) {
                    subscriber.complete();
                    break;
                }
                subscriber.next(item.value);
                if (subscriber.closed) {
                    break;
                }
            } while (true);
            // Finalize the iterator if it happens to be a Generator
            if (typeof iterator.return === 'function') {
                subscriber.add(function () {
                    if (iterator.return) {
                        iterator.return();
                    }
                });
            }
            return subscriber;
        }; };

    },{"../symbol/iterator":101}],128:[function(require,module,exports){
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var observable_1 = require("../symbol/observable");
        /**
         * Subscribes to an object that implements Symbol.observable with the given
         * Subscriber.
         * @param obj An object that implements Symbol.observable
         */
        exports.subscribeToObservable = function (obj) { return function (subscriber) {
            var obs = obj[observable_1.observable]();
            if (typeof obs.subscribe !== 'function') {
                // Should be caught by observable subscribe function error handling.
                throw new TypeError('Provided object does not correctly implement Symbol.observable');
            }
            else {
                return obs.subscribe(subscriber);
            }
        }; };

    },{"../symbol/observable":102}],129:[function(require,module,exports){
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var hostReportError_1 = require("./hostReportError");
        exports.subscribeToPromise = function (promise) { return function (subscriber) {
            promise.then(function (value) {
                if (!subscriber.closed) {
                    subscriber.next(value);
                    subscriber.complete();
                }
            }, function (err) { return subscriber.error(err); })
                    .then(null, hostReportError_1.hostReportError);
            return subscriber;
        }; };

    },{"./hostReportError":111}],130:[function(require,module,exports){
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var InnerSubscriber_1 = require("../InnerSubscriber");
        var subscribeTo_1 = require("./subscribeTo");
        function subscribeToResult(outerSubscriber, result, outerValue, outerIndex) {
            var destination = new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex);
            return subscribeTo_1.subscribeTo(result)(destination);
        }
        exports.subscribeToResult = subscribeToResult;

    },{"../InnerSubscriber":38,"./subscribeTo":125}],131:[function(require,module,exports){
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var Subscriber_1 = require("../Subscriber");
        var rxSubscriber_1 = require("../symbol/rxSubscriber");
        var Observer_1 = require("../Observer");
        function toSubscriber(nextOrObserver, error, complete) {
            if (nextOrObserver) {
                if (nextOrObserver instanceof Subscriber_1.Subscriber) {
                    return nextOrObserver;
                }
                if (nextOrObserver[rxSubscriber_1.rxSubscriber]) {
                    return nextOrObserver[rxSubscriber_1.rxSubscriber]();
                }
            }
            if (!nextOrObserver && !error && !complete) {
                return new Subscriber_1.Subscriber(Observer_1.empty);
            }
            return new Subscriber_1.Subscriber(nextOrObserver, error, complete);
        }
        exports.toSubscriber = toSubscriber;

    },{"../Observer":41,"../Subscriber":47,"../symbol/rxSubscriber":103}],132:[function(require,module,exports){
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var errorObject_1 = require("./errorObject");
        var tryCatchTarget;
        function tryCatcher() {
            try {
                return tryCatchTarget.apply(this, arguments);
            }
            catch (e) {
                errorObject_1.errorObject.e = e;
                return errorObject_1.errorObject;
            }
        }
        function tryCatch(fn) {
            tryCatchTarget = fn;
            return tryCatcher;
        }
        exports.tryCatch = tryCatch;

    },{"./errorObject":110}],133:[function(require,module,exports){

        /**
         * Module dependencies.
         */

        var url = require('./url');
        var parser = require('socket.io-parser');
        var Manager = require('./manager');
        var debug = require('debug')('socket.io-client');

        /**
         * Module exports.
         */

        module.exports = exports = lookup;

        /**
         * Managers cache.
         */

        var cache = exports.managers = {};

        /**
         * Looks up an existing `Manager` for multiplexing.
         * If the user summons:
         *
         *   `io('http://localhost/a');`
         *   `io('http://localhost/b');`
         *
         * We reuse the existing instance based on same scheme/port/host,
         * and we initialize sockets for each namespace.
         *
         * @api public
         */

        function lookup (uri, opts) {
            if (typeof uri === 'object') {
                opts = uri;
                uri = undefined;
            }

            opts = opts || {};

            var parsed = url(uri);
            var source = parsed.source;
            var id = parsed.id;
            var path = parsed.path;
            var sameNamespace = cache[id] && path in cache[id].nsps;
            var newConnection = opts.forceNew || opts['force new connection'] ||
                    false === opts.multiplex || sameNamespace;

            var io;

            if (newConnection) {
                debug('ignoring socket cache for %s', source);
                io = Manager(source, opts);
            } else {
                if (!cache[id]) {
                    debug('new io instance for %s', source);
                    cache[id] = Manager(source, opts);
                }
                io = cache[id];
            }
            if (parsed.query && !opts.query) {
                opts.query = parsed.query;
            }
            return io.socket(parsed.path, opts);
        }

        /**
         * Protocol version.
         *
         * @api public
         */

        exports.protocol = parser.protocol;

        /**
         * `connect`.
         *
         * @param {String} uri
         * @api public
         */

        exports.connect = lookup;

        /**
         * Expose constructors for standalone build.
         *
         * @api public
         */

        exports.Manager = require('./manager');
        exports.Socket = require('./socket');

    },{"./manager":134,"./socket":136,"./url":137,"debug":12,"socket.io-parser":139}],134:[function(require,module,exports){

        /**
         * Module dependencies.
         */

        var eio = require('engine.io-client');
        var Socket = require('./socket');
        var Emitter = require('component-emitter');
        var parser = require('socket.io-parser');
        var on = require('./on');
        var bind = require('component-bind');
        var debug = require('debug')('socket.io-client:manager');
        var indexOf = require('indexof');
        var Backoff = require('backo2');

        /**
         * IE6+ hasOwnProperty
         */

        var has = Object.prototype.hasOwnProperty;

        /**
         * Module exports
         */

        module.exports = Manager;

        /**
         * `Manager` constructor.
         *
         * @param {String} engine instance or engine uri/opts
         * @param {Object} options
         * @api public
         */

        function Manager (uri, opts) {
            if (!(this instanceof Manager)) return new Manager(uri, opts);
            if (uri && ('object' === typeof uri)) {
                opts = uri;
                uri = undefined;
            }
            opts = opts || {};

            opts.path = opts.path || '/socket.io';
            this.nsps = {};
            this.subs = [];
            this.opts = opts;
            this.reconnection(opts.reconnection !== false);
            this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
            this.reconnectionDelay(opts.reconnectionDelay || 1000);
            this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);
            this.randomizationFactor(opts.randomizationFactor || 0.5);
            this.backoff = new Backoff({
                min: this.reconnectionDelay(),
                max: this.reconnectionDelayMax(),
                jitter: this.randomizationFactor()
            });
            this.timeout(null == opts.timeout ? 20000 : opts.timeout);
            this.readyState = 'closed';
            this.uri = uri;
            this.connecting = [];
            this.lastPing = null;
            this.encoding = false;
            this.packetBuffer = [];
            var _parser = opts.parser || parser;
            this.encoder = new _parser.Encoder();
            this.decoder = new _parser.Decoder();
            this.autoConnect = opts.autoConnect !== false;
            if (this.autoConnect) this.open();
        }

        /**
         * Propagate given event to sockets and emit on `this`
         *
         * @api private
         */

        Manager.prototype.emitAll = function () {
            this.emit.apply(this, arguments);
            for (var nsp in this.nsps) {
                if (has.call(this.nsps, nsp)) {
                    this.nsps[nsp].emit.apply(this.nsps[nsp], arguments);
                }
            }
        };

        /**
         * Update `socket.id` of all sockets
         *
         * @api private
         */

        Manager.prototype.updateSocketIds = function () {
            for (var nsp in this.nsps) {
                if (has.call(this.nsps, nsp)) {
                    this.nsps[nsp].id = this.generateId(nsp);
                }
            }
        };

        /**
         * generate `socket.id` for the given `nsp`
         *
         * @param {String} nsp
         * @return {String}
         * @api private
         */

        Manager.prototype.generateId = function (nsp) {
            return (nsp === '/' ? '' : (nsp + '#')) + this.engine.id;
        };

        /**
         * Mix in `Emitter`.
         */

        Emitter(Manager.prototype);

        /**
         * Sets the `reconnection` config.
         *
         * @param {Boolean} true/false if it should automatically reconnect
         * @return {Manager} self or value
         * @api public
         */

        Manager.prototype.reconnection = function (v) {
            if (!arguments.length) return this._reconnection;
            this._reconnection = !!v;
            return this;
        };

        /**
         * Sets the reconnection attempts config.
         *
         * @param {Number} max reconnection attempts before giving up
         * @return {Manager} self or value
         * @api public
         */

        Manager.prototype.reconnectionAttempts = function (v) {
            if (!arguments.length) return this._reconnectionAttempts;
            this._reconnectionAttempts = v;
            return this;
        };

        /**
         * Sets the delay between reconnections.
         *
         * @param {Number} delay
         * @return {Manager} self or value
         * @api public
         */

        Manager.prototype.reconnectionDelay = function (v) {
            if (!arguments.length) return this._reconnectionDelay;
            this._reconnectionDelay = v;
            this.backoff && this.backoff.setMin(v);
            return this;
        };

        Manager.prototype.randomizationFactor = function (v) {
            if (!arguments.length) return this._randomizationFactor;
            this._randomizationFactor = v;
            this.backoff && this.backoff.setJitter(v);
            return this;
        };

        /**
         * Sets the maximum delay between reconnections.
         *
         * @param {Number} delay
         * @return {Manager} self or value
         * @api public
         */

        Manager.prototype.reconnectionDelayMax = function (v) {
            if (!arguments.length) return this._reconnectionDelayMax;
            this._reconnectionDelayMax = v;
            this.backoff && this.backoff.setMax(v);
            return this;
        };

        /**
         * Sets the connection timeout. `false` to disable
         *
         * @return {Manager} self or value
         * @api public
         */

        Manager.prototype.timeout = function (v) {
            if (!arguments.length) return this._timeout;
            this._timeout = v;
            return this;
        };

        /**
         * Starts trying to reconnect if reconnection is enabled and we have not
         * started reconnecting yet
         *
         * @api private
         */

        Manager.prototype.maybeReconnectOnOpen = function () {
            // Only try to reconnect if it's the first time we're connecting
            if (!this.reconnecting && this._reconnection && this.backoff.attempts === 0) {
                // keeps reconnection from firing twice for the same reconnection loop
                this.reconnect();
            }
        };

        /**
         * Sets the current transport `socket`.
         *
         * @param {Function} optional, callback
         * @return {Manager} self
         * @api public
         */

        Manager.prototype.open =
                Manager.prototype.connect = function (fn, opts) {
                    debug('readyState %s', this.readyState);
                    if (~this.readyState.indexOf('open')) return this;

                    debug('opening %s', this.uri);
                    this.engine = eio(this.uri, this.opts);
                    var socket = this.engine;
                    var self = this;
                    this.readyState = 'opening';
                    this.skipReconnect = false;

                    // emit `open`
                    var openSub = on(socket, 'open', function () {
                        self.onopen();
                        fn && fn();
                    });

                    // emit `connect_error`
                    var errorSub = on(socket, 'error', function (data) {
                        debug('connect_error');
                        self.cleanup();
                        self.readyState = 'closed';
                        self.emitAll('connect_error', data);
                        if (fn) {
                            var err = new Error('Connection error');
                            err.data = data;
                            fn(err);
                        } else {
                            // Only do this if there is no fn to handle the error
                            self.maybeReconnectOnOpen();
                        }
                    });

                    // emit `connect_timeout`
                    if (false !== this._timeout) {
                        var timeout = this._timeout;
                        debug('connect attempt will timeout after %d', timeout);

                        // set timer
                        var timer = setTimeout(function () {
                            debug('connect attempt timed out after %d', timeout);
                            openSub.destroy();
                            socket.close();
                            socket.emit('error', 'timeout');
                            self.emitAll('connect_timeout', timeout);
                        }, timeout);

                        this.subs.push({
                            destroy: function () {
                                clearTimeout(timer);
                            }
                        });
                    }

                    this.subs.push(openSub);
                    this.subs.push(errorSub);

                    return this;
                };

        /**
         * Called upon transport open.
         *
         * @api private
         */

        Manager.prototype.onopen = function () {
            debug('open');

            // clear old subs
            this.cleanup();

            // mark as open
            this.readyState = 'open';
            this.emit('open');

            // add new subs
            var socket = this.engine;
            this.subs.push(on(socket, 'data', bind(this, 'ondata')));
            this.subs.push(on(socket, 'ping', bind(this, 'onping')));
            this.subs.push(on(socket, 'pong', bind(this, 'onpong')));
            this.subs.push(on(socket, 'error', bind(this, 'onerror')));
            this.subs.push(on(socket, 'close', bind(this, 'onclose')));
            this.subs.push(on(this.decoder, 'decoded', bind(this, 'ondecoded')));
        };

        /**
         * Called upon a ping.
         *
         * @api private
         */

        Manager.prototype.onping = function () {
            this.lastPing = new Date();
            this.emitAll('ping');
        };

        /**
         * Called upon a packet.
         *
         * @api private
         */

        Manager.prototype.onpong = function () {
            this.emitAll('pong', new Date() - this.lastPing);
        };

        /**
         * Called with data.
         *
         * @api private
         */

        Manager.prototype.ondata = function (data) {
            this.decoder.add(data);
        };

        /**
         * Called when parser fully decodes a packet.
         *
         * @api private
         */

        Manager.prototype.ondecoded = function (packet) {
            this.emit('packet', packet);
        };

        /**
         * Called upon socket error.
         *
         * @api private
         */

        Manager.prototype.onerror = function (err) {
            debug('error', err);
            this.emitAll('error', err);
        };

        /**
         * Creates a new socket for the given `nsp`.
         *
         * @return {Socket}
         * @api public
         */

        Manager.prototype.socket = function (nsp, opts) {
            var socket = this.nsps[nsp];
            if (!socket) {
                socket = new Socket(this, nsp, opts);
                this.nsps[nsp] = socket;
                var self = this;
                socket.on('connecting', onConnecting);
                socket.on('connect', function () {
                    socket.id = self.generateId(nsp);
                });

                if (this.autoConnect) {
                    // manually call here since connecting event is fired before listening
                    onConnecting();
                }
            }

            function onConnecting () {
                if (!~indexOf(self.connecting, socket)) {
                    self.connecting.push(socket);
                }
            }

            return socket;
        };

        /**
         * Called upon a socket close.
         *
         * @param {Socket} socket
         */

        Manager.prototype.destroy = function (socket) {
            var index = indexOf(this.connecting, socket);
            if (~index) this.connecting.splice(index, 1);
            if (this.connecting.length) return;

            this.close();
        };

        /**
         * Writes a packet.
         *
         * @param {Object} packet
         * @api private
         */

        Manager.prototype.packet = function (packet) {
            debug('writing packet %j', packet);
            var self = this;
            if (packet.query && packet.type === 0) packet.nsp += '?' + packet.query;

            if (!self.encoding) {
                // encode, then write to engine with result
                self.encoding = true;
                this.encoder.encode(packet, function (encodedPackets) {
                    for (var i = 0; i < encodedPackets.length; i++) {
                        self.engine.write(encodedPackets[i], packet.options);
                    }
                    self.encoding = false;
                    self.processPacketQueue();
                });
            } else { // add packet to the queue
                self.packetBuffer.push(packet);
            }
        };

        /**
         * If packet buffer is non-empty, begins encoding the
         * next packet in line.
         *
         * @api private
         */

        Manager.prototype.processPacketQueue = function () {
            if (this.packetBuffer.length > 0 && !this.encoding) {
                var pack = this.packetBuffer.shift();
                this.packet(pack);
            }
        };

        /**
         * Clean up transport subscriptions and packet buffer.
         *
         * @api private
         */

        Manager.prototype.cleanup = function () {
            debug('cleanup');

            var subsLength = this.subs.length;
            for (var i = 0; i < subsLength; i++) {
                var sub = this.subs.shift();
                sub.destroy();
            }

            this.packetBuffer = [];
            this.encoding = false;
            this.lastPing = null;

            this.decoder.destroy();
        };

        /**
         * Close the current socket.
         *
         * @api private
         */

        Manager.prototype.close =
                Manager.prototype.disconnect = function () {
                    debug('disconnect');
                    this.skipReconnect = true;
                    this.reconnecting = false;
                    if ('opening' === this.readyState) {
                        // `onclose` will not fire because
                        // an open event never happened
                        this.cleanup();
                    }
                    this.backoff.reset();
                    this.readyState = 'closed';
                    if (this.engine) this.engine.close();
                };

        /**
         * Called upon engine close.
         *
         * @api private
         */

        Manager.prototype.onclose = function (reason) {
            debug('onclose');

            this.cleanup();
            this.backoff.reset();
            this.readyState = 'closed';
            this.emit('close', reason);

            if (this._reconnection && !this.skipReconnect) {
                this.reconnect();
            }
        };

        /**
         * Attempt a reconnection.
         *
         * @api private
         */

        Manager.prototype.reconnect = function () {
            if (this.reconnecting || this.skipReconnect) return this;

            var self = this;

            if (this.backoff.attempts >= this._reconnectionAttempts) {
                debug('reconnect failed');
                this.backoff.reset();
                this.emitAll('reconnect_failed');
                this.reconnecting = false;
            } else {
                var delay = this.backoff.duration();
                debug('will wait %dms before reconnect attempt', delay);

                this.reconnecting = true;
                var timer = setTimeout(function () {
                    if (self.skipReconnect) return;

                    debug('attempting reconnect');
                    self.emitAll('reconnect_attempt', self.backoff.attempts);
                    self.emitAll('reconnecting', self.backoff.attempts);

                    // check again for the case socket closed in above events
                    if (self.skipReconnect) return;

                    self.open(function (err) {
                        if (err) {
                            debug('reconnect attempt error');
                            self.reconnecting = false;
                            self.reconnect();
                            self.emitAll('reconnect_error', err.data);
                        } else {
                            debug('reconnect success');
                            self.onreconnect();
                        }
                    });
                }, delay);

                this.subs.push({
                    destroy: function () {
                        clearTimeout(timer);
                    }
                });
            }
        };

        /**
         * Called upon successful reconnect.
         *
         * @api private
         */

        Manager.prototype.onreconnect = function () {
            var attempt = this.backoff.attempts;
            this.reconnecting = false;
            this.backoff.reset();
            this.updateSocketIds();
            this.emitAll('reconnect', attempt);
        };

    },{"./on":135,"./socket":136,"backo2":3,"component-bind":9,"component-emitter":10,"debug":12,"engine.io-client":14,"indexof":30,"socket.io-parser":139}],135:[function(require,module,exports){

        /**
         * Module exports.
         */

        module.exports = on;

        /**
         * Helper for subscriptions.
         *
         * @param {Object|EventEmitter} obj with `Emitter` mixin or `EventEmitter`
         * @param {String} event name
         * @param {Function} callback
         * @api public
         */

        function on (obj, ev, fn) {
            obj.on(ev, fn);
            return {
                destroy: function () {
                    obj.removeListener(ev, fn);
                }
            };
        }

    },{}],136:[function(require,module,exports){

        /**
         * Module dependencies.
         */

        var parser = require('socket.io-parser');
        var Emitter = require('component-emitter');
        var toArray = require('to-array');
        var on = require('./on');
        var bind = require('component-bind');
        var debug = require('debug')('socket.io-client:socket');
        var parseqs = require('parseqs');
        var hasBin = require('has-binary2');

        /**
         * Module exports.
         */

        module.exports = exports = Socket;

        /**
         * Internal events (blacklisted).
         * These events can't be emitted by the user.
         *
         * @api private
         */

        var events = {
            connect: 1,
            connect_error: 1,
            connect_timeout: 1,
            connecting: 1,
            disconnect: 1,
            error: 1,
            reconnect: 1,
            reconnect_attempt: 1,
            reconnect_failed: 1,
            reconnect_error: 1,
            reconnecting: 1,
            ping: 1,
            pong: 1
        };

        /**
         * Shortcut to `Emitter#emit`.
         */

        var emit = Emitter.prototype.emit;

        /**
         * `Socket` constructor.
         *
         * @api public
         */

        function Socket (io, nsp, opts) {
            this.io = io;
            this.nsp = nsp;
            this.json = this; // compat
            this.ids = 0;
            this.acks = {};
            this.receiveBuffer = [];
            this.sendBuffer = [];
            this.connected = false;
            this.disconnected = true;
            this.flags = {};
            if (opts && opts.query) {
                this.query = opts.query;
            }
            if (this.io.autoConnect) this.open();
        }

        /**
         * Mix in `Emitter`.
         */

        Emitter(Socket.prototype);

        /**
         * Subscribe to open, close and packet events
         *
         * @api private
         */

        Socket.prototype.subEvents = function () {
            if (this.subs) return;

            var io = this.io;
            this.subs = [
                on(io, 'open', bind(this, 'onopen')),
                on(io, 'packet', bind(this, 'onpacket')),
                on(io, 'close', bind(this, 'onclose'))
            ];
        };

        /**
         * "Opens" the socket.
         *
         * @api public
         */

        Socket.prototype.open =
                Socket.prototype.connect = function () {
                    if (this.connected) return this;

                    this.subEvents();
                    this.io.open(); // ensure open
                    if ('open' === this.io.readyState) this.onopen();
                    this.emit('connecting');
                    return this;
                };

        /**
         * Sends a `message` event.
         *
         * @return {Socket} self
         * @api public
         */

        Socket.prototype.send = function () {
            var args = toArray(arguments);
            args.unshift('message');
            this.emit.apply(this, args);
            return this;
        };

        /**
         * Override `emit`.
         * If the event is in `events`, it's emitted normally.
         *
         * @param {String} event name
         * @return {Socket} self
         * @api public
         */

        Socket.prototype.emit = function (ev) {
            if (events.hasOwnProperty(ev)) {
                emit.apply(this, arguments);
                return this;
            }

            var args = toArray(arguments);
            var packet = {
                type: (this.flags.binary !== undefined ? this.flags.binary : hasBin(args)) ? parser.BINARY_EVENT : parser.EVENT,
                data: args
            };

            packet.options = {};
            packet.options.compress = !this.flags || false !== this.flags.compress;

            // event ack callback
            if ('function' === typeof args[args.length - 1]) {
                debug('emitting packet with ack id %d', this.ids);
                this.acks[this.ids] = args.pop();
                packet.id = this.ids++;
            }

            if (this.connected) {
                this.packet(packet);
            } else {
                this.sendBuffer.push(packet);
            }

            this.flags = {};

            return this;
        };

        /**
         * Sends a packet.
         *
         * @param {Object} packet
         * @api private
         */

        Socket.prototype.packet = function (packet) {
            packet.nsp = this.nsp;
            this.io.packet(packet);
        };

        /**
         * Called upon engine `open`.
         *
         * @api private
         */

        Socket.prototype.onopen = function () {
            debug('transport is open - connecting');

            // write connect packet if necessary
            if ('/' !== this.nsp) {
                if (this.query) {
                    var query = typeof this.query === 'object' ? parseqs.encode(this.query) : this.query;
                    debug('sending connect packet with query %s', query);
                    this.packet({type: parser.CONNECT, query: query});
                } else {
                    this.packet({type: parser.CONNECT});
                }
            }
        };

        /**
         * Called upon engine `close`.
         *
         * @param {String} reason
         * @api private
         */

        Socket.prototype.onclose = function (reason) {
            debug('close (%s)', reason);
            this.connected = false;
            this.disconnected = true;
            delete this.id;
            this.emit('disconnect', reason);
        };

        /**
         * Called with socket packet.
         *
         * @param {Object} packet
         * @api private
         */

        Socket.prototype.onpacket = function (packet) {
            var sameNamespace = packet.nsp === this.nsp;
            var rootNamespaceError = packet.type === parser.ERROR && packet.nsp === '/';

            if (!sameNamespace && !rootNamespaceError) return;

            switch (packet.type) {
                case parser.CONNECT:
                    this.onconnect();
                    break;

                case parser.EVENT:
                    this.onevent(packet);
                    break;

                case parser.BINARY_EVENT:
                    this.onevent(packet);
                    break;

                case parser.ACK:
                    this.onack(packet);
                    break;

                case parser.BINARY_ACK:
                    this.onack(packet);
                    break;

                case parser.DISCONNECT:
                    this.ondisconnect();
                    break;

                case parser.ERROR:
                    this.emit('error', packet.data);
                    break;
            }
        };

        /**
         * Called upon a server event.
         *
         * @param {Object} packet
         * @api private
         */

        Socket.prototype.onevent = function (packet) {
            var args = packet.data || [];
            debug('emitting event %j', args);

            if (null != packet.id) {
                debug('attaching ack callback to event');
                args.push(this.ack(packet.id));
            }

            if (this.connected) {
                emit.apply(this, args);
            } else {
                this.receiveBuffer.push(args);
            }
        };

        /**
         * Produces an ack callback to emit with an event.
         *
         * @api private
         */

        Socket.prototype.ack = function (id) {
            var self = this;
            var sent = false;
            return function () {
                // prevent double callbacks
                if (sent) return;
                sent = true;
                var args = toArray(arguments);
                debug('sending ack %j', args);

                self.packet({
                    type: hasBin(args) ? parser.BINARY_ACK : parser.ACK,
                    id: id,
                    data: args
                });
            };
        };

        /**
         * Called upon a server acknowlegement.
         *
         * @param {Object} packet
         * @api private
         */

        Socket.prototype.onack = function (packet) {
            var ack = this.acks[packet.id];
            if ('function' === typeof ack) {
                debug('calling ack %s with %j', packet.id, packet.data);
                ack.apply(this, packet.data);
                delete this.acks[packet.id];
            } else {
                debug('bad ack %s', packet.id);
            }
        };

        /**
         * Called upon server connect.
         *
         * @api private
         */

        Socket.prototype.onconnect = function () {
            this.connected = true;
            this.disconnected = false;
            this.emit('connect');
            this.emitBuffered();
        };

        /**
         * Emit buffered events (received and emitted).
         *
         * @api private
         */

        Socket.prototype.emitBuffered = function () {
            var i;
            for (i = 0; i < this.receiveBuffer.length; i++) {
                emit.apply(this, this.receiveBuffer[i]);
            }
            this.receiveBuffer = [];

            for (i = 0; i < this.sendBuffer.length; i++) {
                this.packet(this.sendBuffer[i]);
            }
            this.sendBuffer = [];
        };

        /**
         * Called upon server disconnect.
         *
         * @api private
         */

        Socket.prototype.ondisconnect = function () {
            debug('server disconnect (%s)', this.nsp);
            this.destroy();
            this.onclose('io server disconnect');
        };

        /**
         * Called upon forced client/server side disconnections,
         * this method ensures the manager stops tracking us and
         * that reconnections don't get triggered for this.
         *
         * @api private.
         */

        Socket.prototype.destroy = function () {
            if (this.subs) {
                // clean subscriptions to avoid reconnections
                for (var i = 0; i < this.subs.length; i++) {
                    this.subs[i].destroy();
                }
                this.subs = null;
            }

            this.io.destroy(this);
        };

        /**
         * Disconnects the socket manually.
         *
         * @return {Socket} self
         * @api public
         */

        Socket.prototype.close =
                Socket.prototype.disconnect = function () {
                    if (this.connected) {
                        debug('performing disconnect (%s)', this.nsp);
                        this.packet({ type: parser.DISCONNECT });
                    }

                    // remove socket from pool
                    this.destroy();

                    if (this.connected) {
                        // fire events
                        this.onclose('io client disconnect');
                    }
                    return this;
                };

        /**
         * Sets the compress flag.
         *
         * @param {Boolean} if `true`, compresses the sending data
         * @return {Socket} self
         * @api public
         */

        Socket.prototype.compress = function (compress) {
            this.flags.compress = compress;
            return this;
        };

        /**
         * Sets the binary flag
         *
         * @param {Boolean} whether the emitted data contains binary
         * @return {Socket} self
         * @api public
         */

        Socket.prototype.binary = function (binary) {
            this.flags.binary = binary;
            return this;
        };

    },{"./on":135,"component-bind":9,"component-emitter":10,"debug":12,"has-binary2":26,"parseqs":32,"socket.io-parser":139,"to-array":142}],137:[function(require,module,exports){
        (function (global){

            /**
             * Module dependencies.
             */

            var parseuri = require('parseuri');
            var debug = require('debug')('socket.io-client:url');

            /**
             * Module exports.
             */

            module.exports = url;

            /**
             * URL parser.
             *
             * @param {String} url
             * @param {Object} An object meant to mimic window.location.
             *                 Defaults to window.location.
             * @api public
             */

            function url (uri, loc) {
                var obj = uri;

                // default to window.location
                loc = loc || global.location;
                if (null == uri) uri = loc.protocol + '//' + loc.host;

                // relative path support
                if ('string' === typeof uri) {
                    if ('/' === uri.charAt(0)) {
                        if ('/' === uri.charAt(1)) {
                            uri = loc.protocol + uri;
                        } else {
                            uri = loc.host + uri;
                        }
                    }

                    if (!/^(https?|wss?):\/\//.test(uri)) {
                        debug('protocol-less url %s', uri);
                        if ('undefined' !== typeof loc) {
                            uri = loc.protocol + '//' + uri;
                        } else {
                            uri = 'https://' + uri;
                        }
                    }

                    // parse
                    debug('parse %s', uri);
                    obj = parseuri(uri);
                }

                // make sure we treat `localhost:80` and `localhost` equally
                if (!obj.port) {
                    if (/^(http|ws)$/.test(obj.protocol)) {
                        obj.port = '80';
                    } else if (/^(http|ws)s$/.test(obj.protocol)) {
                        obj.port = '443';
                    }
                }

                obj.path = obj.path || '/';

                var ipv6 = obj.host.indexOf(':') !== -1;
                var host = ipv6 ? '[' + obj.host + ']' : obj.host;

                // define unique id
                obj.id = obj.protocol + '://' + host + ':' + obj.port;
                // define href
                obj.href = obj.protocol + '://' + host + (loc && loc.port === obj.port ? '' : (':' + obj.port));

                return obj;
            }

        }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
    },{"debug":12,"parseuri":33}],138:[function(require,module,exports){
        (function (global){
            /*global Blob,File*/

            /**
             * Module requirements
             */

            var isArray = require('isarray');
            var isBuf = require('./is-buffer');
            var toString = Object.prototype.toString;
            var withNativeBlob = typeof global.Blob === 'function' || toString.call(global.Blob) === '[object BlobConstructor]';
            var withNativeFile = typeof global.File === 'function' || toString.call(global.File) === '[object FileConstructor]';

            /**
             * Replaces every Buffer | ArrayBuffer in packet with a numbered placeholder.
             * Anything with blobs or files should be fed through removeBlobs before coming
             * here.
             *
             * @param {Object} packet - socket.io event packet
             * @return {Object} with deconstructed packet and list of buffers
             * @api public
             */

            exports.deconstructPacket = function(packet) {
                var buffers = [];
                var packetData = packet.data;
                var pack = packet;
                pack.data = _deconstructPacket(packetData, buffers);
                pack.attachments = buffers.length; // number of binary 'attachments'
                return {packet: pack, buffers: buffers};
            };

            function _deconstructPacket(data, buffers) {
                if (!data) return data;

                if (isBuf(data)) {
                    var placeholder = { _placeholder: true, num: buffers.length };
                    buffers.push(data);
                    return placeholder;
                } else if (isArray(data)) {
                    var newData = new Array(data.length);
                    for (var i = 0; i < data.length; i++) {
                        newData[i] = _deconstructPacket(data[i], buffers);
                    }
                    return newData;
                } else if (typeof data === 'object' && !(data instanceof Date)) {
                    var newData = {};
                    for (var key in data) {
                        newData[key] = _deconstructPacket(data[key], buffers);
                    }
                    return newData;
                }
                return data;
            }

            /**
             * Reconstructs a binary packet from its placeholder packet and buffers
             *
             * @param {Object} packet - event packet with placeholders
             * @param {Array} buffers - binary buffers to put in placeholder positions
             * @return {Object} reconstructed packet
             * @api public
             */

            exports.reconstructPacket = function(packet, buffers) {
                packet.data = _reconstructPacket(packet.data, buffers);
                packet.attachments = undefined; // no longer useful
                return packet;
            };

            function _reconstructPacket(data, buffers) {
                if (!data) return data;

                if (data && data._placeholder) {
                    return buffers[data.num]; // appropriate buffer (should be natural order anyway)
                } else if (isArray(data)) {
                    for (var i = 0; i < data.length; i++) {
                        data[i] = _reconstructPacket(data[i], buffers);
                    }
                } else if (typeof data === 'object') {
                    for (var key in data) {
                        data[key] = _reconstructPacket(data[key], buffers);
                    }
                }

                return data;
            }

            /**
             * Asynchronously removes Blobs or Files from data via
             * FileReader's readAsArrayBuffer method. Used before encoding
             * data as msgpack. Calls callback with the blobless data.
             *
             * @param {Object} data
             * @param {Function} callback
             * @api private
             */

            exports.removeBlobs = function(data, callback) {
                function _removeBlobs(obj, curKey, containingObject) {
                    if (!obj) return obj;

                    // convert any blob
                    if ((withNativeBlob && obj instanceof Blob) ||
                            (withNativeFile && obj instanceof File)) {
                        pendingBlobs++;

                        // async filereader
                        var fileReader = new FileReader();
                        fileReader.onload = function() { // this.result == arraybuffer
                            if (containingObject) {
                                containingObject[curKey] = this.result;
                            }
                            else {
                                bloblessData = this.result;
                            }

                            // if nothing pending its callback time
                            if(! --pendingBlobs) {
                                callback(bloblessData);
                            }
                        };

                        fileReader.readAsArrayBuffer(obj); // blob -> arraybuffer
                    } else if (isArray(obj)) { // handle array
                        for (var i = 0; i < obj.length; i++) {
                            _removeBlobs(obj[i], i, obj);
                        }
                    } else if (typeof obj === 'object' && !isBuf(obj)) { // and object
                        for (var key in obj) {
                            _removeBlobs(obj[key], key, obj);
                        }
                    }
                }

                var pendingBlobs = 0;
                var bloblessData = data;
                _removeBlobs(bloblessData);
                if (!pendingBlobs) {
                    callback(bloblessData);
                }
            };

        }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
    },{"./is-buffer":140,"isarray":141}],139:[function(require,module,exports){

        /**
         * Module dependencies.
         */

        var debug = require('debug')('socket.io-parser');
        var Emitter = require('component-emitter');
        var binary = require('./binary');
        var isArray = require('isarray');
        var isBuf = require('./is-buffer');

        /**
         * Protocol version.
         *
         * @api public
         */

        exports.protocol = 4;

        /**
         * Packet types.
         *
         * @api public
         */

        exports.types = [
            'CONNECT',
            'DISCONNECT',
            'EVENT',
            'ACK',
            'ERROR',
            'BINARY_EVENT',
            'BINARY_ACK'
        ];

        /**
         * Packet type `connect`.
         *
         * @api public
         */

        exports.CONNECT = 0;

        /**
         * Packet type `disconnect`.
         *
         * @api public
         */

        exports.DISCONNECT = 1;

        /**
         * Packet type `event`.
         *
         * @api public
         */

        exports.EVENT = 2;

        /**
         * Packet type `ack`.
         *
         * @api public
         */

        exports.ACK = 3;

        /**
         * Packet type `error`.
         *
         * @api public
         */

        exports.ERROR = 4;

        /**
         * Packet type 'binary event'
         *
         * @api public
         */

        exports.BINARY_EVENT = 5;

        /**
         * Packet type `binary ack`. For acks with binary arguments.
         *
         * @api public
         */

        exports.BINARY_ACK = 6;

        /**
         * Encoder constructor.
         *
         * @api public
         */

        exports.Encoder = Encoder;

        /**
         * Decoder constructor.
         *
         * @api public
         */

        exports.Decoder = Decoder;

        /**
         * A socket.io Encoder instance
         *
         * @api public
         */

        function Encoder() {}

        var ERROR_PACKET = exports.ERROR + '"encode error"';

        /**
         * Encode a packet as a single string if non-binary, or as a
         * buffer sequence, depending on packet type.
         *
         * @param {Object} obj - packet object
         * @param {Function} callback - function to handle encodings (likely engine.write)
         * @return Calls callback with Array of encodings
         * @api public
         */

        Encoder.prototype.encode = function(obj, callback){
            debug('encoding packet %j', obj);

            if (exports.BINARY_EVENT === obj.type || exports.BINARY_ACK === obj.type) {
                encodeAsBinary(obj, callback);
            } else {
                var encoding = encodeAsString(obj);
                callback([encoding]);
            }
        };

        /**
         * Encode packet as string.
         *
         * @param {Object} packet
         * @return {String} encoded
         * @api private
         */

        function encodeAsString(obj) {

            // first is type
            var str = '' + obj.type;

            // attachments if we have them
            if (exports.BINARY_EVENT === obj.type || exports.BINARY_ACK === obj.type) {
                str += obj.attachments + '-';
            }

            // if we have a namespace other than `/`
            // we append it followed by a comma `,`
            if (obj.nsp && '/' !== obj.nsp) {
                str += obj.nsp + ',';
            }

            // immediately followed by the id
            if (null != obj.id) {
                str += obj.id;
            }

            // json data
            if (null != obj.data) {
                var payload = tryStringify(obj.data);
                if (payload !== false) {
                    str += payload;
                } else {
                    return ERROR_PACKET;
                }
            }

            debug('encoded %j as %s', obj, str);
            return str;
        }

        function tryStringify(str) {
            try {
                return JSON.stringify(str);
            } catch(e){
                return false;
            }
        }

        /**
         * Encode packet as 'buffer sequence' by removing blobs, and
         * deconstructing packet into object with placeholders and
         * a list of buffers.
         *
         * @param {Object} packet
         * @return {Buffer} encoded
         * @api private
         */

        function encodeAsBinary(obj, callback) {

            function writeEncoding(bloblessData) {
                var deconstruction = binary.deconstructPacket(bloblessData);
                var pack = encodeAsString(deconstruction.packet);
                var buffers = deconstruction.buffers;

                buffers.unshift(pack); // add packet info to beginning of data list
                callback(buffers); // write all the buffers
            }

            binary.removeBlobs(obj, writeEncoding);
        }

        /**
         * A socket.io Decoder instance
         *
         * @return {Object} decoder
         * @api public
         */

        function Decoder() {
            this.reconstructor = null;
        }

        /**
         * Mix in `Emitter` with Decoder.
         */

        Emitter(Decoder.prototype);

        /**
         * Decodes an ecoded packet string into packet JSON.
         *
         * @param {String} obj - encoded packet
         * @return {Object} packet
         * @api public
         */

        Decoder.prototype.add = function(obj) {
            var packet;
            if (typeof obj === 'string') {
                packet = decodeString(obj);
                if (exports.BINARY_EVENT === packet.type || exports.BINARY_ACK === packet.type) { // binary packet's json
                    this.reconstructor = new BinaryReconstructor(packet);

                    // no attachments, labeled binary but no binary data to follow
                    if (this.reconstructor.reconPack.attachments === 0) {
                        this.emit('decoded', packet);
                    }
                } else { // non-binary full packet
                    this.emit('decoded', packet);
                }
            }
            else if (isBuf(obj) || obj.base64) { // raw binary data
                if (!this.reconstructor) {
                    throw new Error('got binary data when not reconstructing a packet');
                } else {
                    packet = this.reconstructor.takeBinaryData(obj);
                    if (packet) { // received final buffer
                        this.reconstructor = null;
                        this.emit('decoded', packet);
                    }
                }
            }
            else {
                throw new Error('Unknown type: ' + obj);
            }
        };

        /**
         * Decode a packet String (JSON data)
         *
         * @param {String} str
         * @return {Object} packet
         * @api private
         */

        function decodeString(str) {
            var i = 0;
            // look up type
            var p = {
                type: Number(str.charAt(0))
            };

            if (null == exports.types[p.type]) {
                return error('unknown packet type ' + p.type);
            }

            // look up attachments if type binary
            if (exports.BINARY_EVENT === p.type || exports.BINARY_ACK === p.type) {
                var buf = '';
                while (str.charAt(++i) !== '-') {
                    buf += str.charAt(i);
                    if (i == str.length) break;
                }
                if (buf != Number(buf) || str.charAt(i) !== '-') {
                    throw new Error('Illegal attachments');
                }
                p.attachments = Number(buf);
            }

            // look up namespace (if any)
            if ('/' === str.charAt(i + 1)) {
                p.nsp = '';
                while (++i) {
                    var c = str.charAt(i);
                    if (',' === c) break;
                    p.nsp += c;
                    if (i === str.length) break;
                }
            } else {
                p.nsp = '/';
            }

            // look up id
            var next = str.charAt(i + 1);
            if ('' !== next && Number(next) == next) {
                p.id = '';
                while (++i) {
                    var c = str.charAt(i);
                    if (null == c || Number(c) != c) {
                        --i;
                        break;
                    }
                    p.id += str.charAt(i);
                    if (i === str.length) break;
                }
                p.id = Number(p.id);
            }

            // look up json data
            if (str.charAt(++i)) {
                var payload = tryParse(str.substr(i));
                var isPayloadValid = payload !== false && (p.type === exports.ERROR || isArray(payload));
                if (isPayloadValid) {
                    p.data = payload;
                } else {
                    return error('invalid payload');
                }
            }

            debug('decoded %s as %j', str, p);
            return p;
        }

        function tryParse(str) {
            try {
                return JSON.parse(str);
            } catch(e){
                return false;
            }
        }

        /**
         * Deallocates a parser's resources
         *
         * @api public
         */

        Decoder.prototype.destroy = function() {
            if (this.reconstructor) {
                this.reconstructor.finishedReconstruction();
            }
        };

        /**
         * A manager of a binary event's 'buffer sequence'. Should
         * be constructed whenever a packet of type BINARY_EVENT is
         * decoded.
         *
         * @param {Object} packet
         * @return {BinaryReconstructor} initialized reconstructor
         * @api private
         */

        function BinaryReconstructor(packet) {
            this.reconPack = packet;
            this.buffers = [];
        }

        /**
         * Method to be called when binary data received from connection
         * after a BINARY_EVENT packet.
         *
         * @param {Buffer | ArrayBuffer} binData - the raw binary data received
         * @return {null | Object} returns null if more binary data is expected or
         *   a reconstructed packet object if all buffers have been received.
         * @api private
         */

        BinaryReconstructor.prototype.takeBinaryData = function(binData) {
            this.buffers.push(binData);
            if (this.buffers.length === this.reconPack.attachments) { // done with buffer list
                var packet = binary.reconstructPacket(this.reconPack, this.buffers);
                this.finishedReconstruction();
                return packet;
            }
            return null;
        };

        /**
         * Cleans up binary packet reconstruction variables.
         *
         * @api private
         */

        BinaryReconstructor.prototype.finishedReconstruction = function() {
            this.reconPack = null;
            this.buffers = [];
        };

        function error(msg) {
            return {
                type: exports.ERROR,
                data: 'parser error: ' + msg
            };
        }

    },{"./binary":138,"./is-buffer":140,"component-emitter":10,"debug":12,"isarray":141}],140:[function(require,module,exports){
        (function (global){

            module.exports = isBuf;

            var withNativeBuffer = typeof global.Buffer === 'function' && typeof global.Buffer.isBuffer === 'function';
            var withNativeArrayBuffer = typeof global.ArrayBuffer === 'function';

            var isView = (function () {
                if (withNativeArrayBuffer && typeof global.ArrayBuffer.isView === 'function') {
                    return global.ArrayBuffer.isView;
                } else {
                    return function (obj) { return obj.buffer instanceof global.ArrayBuffer; };
                }
            })();

            /**
             * Returns true if obj is a buffer or an arraybuffer.
             *
             * @api private
             */

            function isBuf(obj) {
                return (withNativeBuffer && global.Buffer.isBuffer(obj)) ||
                        (withNativeArrayBuffer && (obj instanceof global.ArrayBuffer || isView(obj)));
            }

        }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
    },{}],141:[function(require,module,exports){
        arguments[4][27][0].apply(exports,arguments)
    },{"dup":27}],142:[function(require,module,exports){
        module.exports = toArray

        function toArray(list, index) {
            var array = []

            index = index || 0

            for (var i = index || 0; i < list.length; i++) {
                array[i - index] = list[i]
            }

            return array
        }

    },{}],143:[function(require,module,exports){
        'use strict';

        var alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_'.split('')
                , length = 64
                , map = {}
                , seed = 0
                , i = 0
                , prev;

        /**
         * Return a string representing the specified number.
         *
         * @param {Number} num The number to convert.
         * @returns {String} The string representation of the number.
         * @api public
         */
        function encode(num) {
            var encoded = '';

            do {
                encoded = alphabet[num % length] + encoded;
                num = Math.floor(num / length);
            } while (num > 0);

            return encoded;
        }

        /**
         * Return the integer value specified by the given string.
         *
         * @param {String} str The string to convert.
         * @returns {Number} The integer value represented by the string.
         * @api public
         */
        function decode(str) {
            var decoded = 0;

            for (i = 0; i < str.length; i++) {
                decoded = decoded * length + map[str.charAt(i)];
            }

            return decoded;
        }

        /**
         * Yeast: A tiny growing id generator.
         *
         * @returns {String} A unique id.
         * @api public
         */
        function yeast() {
            var now = encode(+new Date());

            if (now !== prev) return seed = 0, prev = now;
            return now +'.'+ encode(seed++);
        }

//
// Map each character to its index.
//
        for (; i < length; i++) map[alphabet[i]] = i;

//
// Expose the `yeast`, `encode` and `decode` functions.
//
        yeast.encode = encode;
        yeast.decode = decode;
        module.exports = yeast;

    },{}],144:[function(require,module,exports){
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.host_protocol = 'http';
        exports.host = 'localhost';
        exports.host_port = 3000;
        exports.host_websocket_port = 3001;
        exports.host_url = exports.host_protocol + '://' + exports.host + ':' + exports.host_port;
        exports.host_websocket_url = exports.host_protocol + '://' + exports.host + ':' + exports.host_websocket_port;

    },{}],145:[function(require,module,exports){
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        const index_1 = require("rxjs/index");
        const socketIo = require("socket.io-client");
        const config_1 = require("../config");
        const user_config_1 = require("./user.config");
        class SocketService {
            initSocket() {
                this.socket = socketIo(config_1.host_websocket_url);
            }
            send(message) {
                this.socket.emit(user_config_1.namespace, message);
            }
            onMessage() {
                return new index_1.Observable(observer => {
                    this.socket.on(user_config_1.namespace, (data) => observer.next(data));
                });
            }
            onEvent(event) {
                return new index_1.Observable(observer => {
                    this.socket.on(event, () => observer.next());
                });
            }
        }
        exports.SocketService = SocketService;
        const ss = new SocketService();
        ss.initSocket();
        ss.send({ id: 234, email: 'sfd', password_hash: 'sdf' });

    },{"../config":144,"./user.config":146,"rxjs/index":35,"socket.io-client":133}],146:[function(require,module,exports){
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.namespace = 'user';

    },{}]},{},[145]);

</script>
</html>
